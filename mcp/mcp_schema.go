// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package mcp

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

type CategoryItem struct {
	// Category description
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Category name
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Category slug
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CategoryItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in CategoryItem: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in CategoryItem: required")
	}
	type Plain CategoryItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = CategoryItem(plain)
	return nil
}

type DatagraphItemKindYaml string

const DatagraphItemKindYamlCollection DatagraphItemKindYaml = "collection"
const DatagraphItemKindYamlEvent DatagraphItemKindYaml = "event"
const DatagraphItemKindYamlNode DatagraphItemKindYaml = "node"
const DatagraphItemKindYamlPost DatagraphItemKindYaml = "post"
const DatagraphItemKindYamlProfile DatagraphItemKindYaml = "profile"
const DatagraphItemKindYamlReply DatagraphItemKindYaml = "reply"
const DatagraphItemKindYamlThread DatagraphItemKindYaml = "thread"

var enumValues_DatagraphItemKindYaml = []interface{}{
	"post",
	"thread",
	"reply",
	"node",
	"collection",
	"profile",
	"event",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatagraphItemKindYaml) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DatagraphItemKindYaml {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DatagraphItemKindYaml, v)
	}
	*j = DatagraphItemKindYaml(v)
	return nil
}

type DatagraphItemRef struct {
	// Unique identifier of the datagraph item
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Type of datagraph item (thread, node, profile, collection, etc.)
	Kind DatagraphItemKindYaml `json:"kind" yaml:"kind" mapstructure:"kind"`

	// URL-friendly slug of the datagraph item
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatagraphItemRef) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in DatagraphItemRef: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in DatagraphItemRef: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in DatagraphItemRef: required")
	}
	type Plain DatagraphItemRef
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = DatagraphItemRef(plain)
	return nil
}

type LibraryPageSearchItem struct {
	// Page content excerpt
	Content *string `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Brief description
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Page name/title
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// URL-friendly identifier
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LibraryPageSearchItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in LibraryPageSearchItem: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in LibraryPageSearchItem: required")
	}
	type Plain LibraryPageSearchItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = LibraryPageSearchItem(plain)
	return nil
}

type LibraryPageTreeNode struct {
	// Brief description of the page
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// Display name of the page
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Slug of the parent page (omitted for root pages)
	Parent *string `json:"parent,omitempty" yaml:"parent,omitempty" mapstructure:"parent,omitempty"`

	// URL-friendly identifier for the page
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Tags associated with this page
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LibraryPageTreeNode) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in LibraryPageTreeNode: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in LibraryPageTreeNode: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in LibraryPageTreeNode: required")
	}
	type Plain LibraryPageTreeNode
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = LibraryPageTreeNode(plain)
	return nil
}

type PropertySchemaField struct {
	// Unique identifier for this field
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Display name of the field
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Sort key for ordering fields
	Sort *string `json:"sort,omitempty" yaml:"sort,omitempty" mapstructure:"sort,omitempty"`

	// Data type of the field
	Type PropertySchemaFieldType `json:"type" yaml:"type" mapstructure:"type"`
}

type PropertySchemaFieldMutation struct {
	// Field ID - if provided, updates an existing field. If omitted, creates a new
	// field.
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Display name of the field
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Data type of the field
	Type PropertySchemaFieldMutationType `json:"type" yaml:"type" mapstructure:"type"`
}

type PropertySchemaFieldMutationType string

const PropertySchemaFieldMutationTypeBoolean PropertySchemaFieldMutationType = "boolean"
const PropertySchemaFieldMutationTypeNumber PropertySchemaFieldMutationType = "number"
const PropertySchemaFieldMutationTypeText PropertySchemaFieldMutationType = "text"
const PropertySchemaFieldMutationTypeTimestamp PropertySchemaFieldMutationType = "timestamp"

var enumValues_PropertySchemaFieldMutationType = []interface{}{
	"text",
	"number",
	"timestamp",
	"boolean",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PropertySchemaFieldMutationType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PropertySchemaFieldMutationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PropertySchemaFieldMutationType, v)
	}
	*j = PropertySchemaFieldMutationType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PropertySchemaFieldMutation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in PropertySchemaFieldMutation: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in PropertySchemaFieldMutation: required")
	}
	type Plain PropertySchemaFieldMutation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	*j = PropertySchemaFieldMutation(plain)
	return nil
}

type PropertySchemaFieldResult struct {
	// Unique identifier for this field
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Display name of the field
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Data type of the field
	Type PropertySchemaFieldResultType `json:"type" yaml:"type" mapstructure:"type"`
}

type PropertySchemaFieldResultType string

const PropertySchemaFieldResultTypeBoolean PropertySchemaFieldResultType = "boolean"
const PropertySchemaFieldResultTypeNumber PropertySchemaFieldResultType = "number"
const PropertySchemaFieldResultTypeText PropertySchemaFieldResultType = "text"
const PropertySchemaFieldResultTypeTimestamp PropertySchemaFieldResultType = "timestamp"

var enumValues_PropertySchemaFieldResultType = []interface{}{
	"text",
	"number",
	"timestamp",
	"boolean",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PropertySchemaFieldResultType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PropertySchemaFieldResultType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PropertySchemaFieldResultType, v)
	}
	*j = PropertySchemaFieldResultType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PropertySchemaFieldResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in PropertySchemaFieldResult: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in PropertySchemaFieldResult: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in PropertySchemaFieldResult: required")
	}
	type Plain PropertySchemaFieldResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PropertySchemaFieldResult(plain)
	return nil
}

type PropertySchemaFieldType string

const PropertySchemaFieldTypeBoolean PropertySchemaFieldType = "boolean"
const PropertySchemaFieldTypeNumber PropertySchemaFieldType = "number"
const PropertySchemaFieldTypeText PropertySchemaFieldType = "text"
const PropertySchemaFieldTypeTimestamp PropertySchemaFieldType = "timestamp"

var enumValues_PropertySchemaFieldType = []interface{}{
	"text",
	"number",
	"timestamp",
	"boolean",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PropertySchemaFieldType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PropertySchemaFieldType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PropertySchemaFieldType, v)
	}
	*j = PropertySchemaFieldType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PropertySchemaField) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in PropertySchemaField: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in PropertySchemaField: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in PropertySchemaField: required")
	}
	type Plain PropertySchemaField
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PropertySchemaField(plain)
	return nil
}

type PropertyValueMutation struct {
	// The ID of the schema field this property value is for
	FieldId string `json:"field_id" yaml:"field_id" mapstructure:"field_id"`

	// The value to set for this property
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PropertyValueMutation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["field_id"]; raw != nil && !ok {
		return fmt.Errorf("field field_id in PropertyValueMutation: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in PropertyValueMutation: required")
	}
	type Plain PropertyValueMutation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PropertyValueMutation(plain)
	return nil
}

type PropertyValueResult struct {
	// The ID of the schema field
	FieldId string `json:"field_id" yaml:"field_id" mapstructure:"field_id"`

	// The name of the field
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Data type of the field
	Type *PropertyValueResultType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// The current value of this property
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

type PropertyValueResultType string

const PropertyValueResultTypeBoolean PropertyValueResultType = "boolean"
const PropertyValueResultTypeNumber PropertyValueResultType = "number"
const PropertyValueResultTypeText PropertyValueResultType = "text"
const PropertyValueResultTypeTimestamp PropertyValueResultType = "timestamp"

var enumValues_PropertyValueResultType = []interface{}{
	"text",
	"number",
	"timestamp",
	"boolean",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PropertyValueResultType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PropertyValueResultType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PropertyValueResultType, v)
	}
	*j = PropertyValueResultType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PropertyValueResult) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["field_id"]; raw != nil && !ok {
		return fmt.Errorf("field field_id in PropertyValueResult: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in PropertyValueResult: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in PropertyValueResult: required")
	}
	type Plain PropertyValueResult
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PropertyValueResult(plain)
	return nil
}

type RobotChatContext struct {
	// Optional reference to a datagraph item if the user is viewing one (e.g., a
	// thread, library page, profile)
	DatagraphItem *DatagraphItemRef `json:"datagraph_item,omitempty" yaml:"datagraph_item,omitempty" mapstructure:"datagraph_item,omitempty"`

	// Human-readable page type if not viewing a specific datagraph item. Examples:
	// 'Index page', 'Settings page', 'Admin page', 'Search page'. This is free-form
	// text since the backend doesn't know about frontend routes.
	PageType *string `json:"page_type,omitempty" yaml:"page_type,omitempty" mapstructure:"page_type,omitempty"`
}

type RobotItem struct {
	// Human-readable description of the Robot's purpose
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Unique identifier
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Robot name
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RobotItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in RobotItem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RobotItem: required")
	}
	type Plain RobotItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RobotItem(plain)
	return nil
}

type SearchedItem struct {
	// Brief description or excerpt
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Unique identifier
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Type of content
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Title or name
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// URL friendly identifier
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SearchedItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in SearchedItem: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in SearchedItem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SearchedItem: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in SearchedItem: required")
	}
	type Plain SearchedItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SearchedItem(plain)
	return nil
}

type TagItem struct {
	// Number of items tagged with this tag
	ItemCount int `json:"item_count" yaml:"item_count" mapstructure:"item_count"`

	// The tag name
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TagItem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["item_count"]; raw != nil && !ok {
		return fmt.Errorf("field item_count in TagItem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in TagItem: required")
	}
	type Plain TagItem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TagItem(plain)
	return nil
}

type ThreadSummary struct {
	// Author handle
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// Category name
	Category string `json:"category" yaml:"category" mapstructure:"category"`

	// Short excerpt of the thread
	Excerpt string `json:"excerpt" yaml:"excerpt" mapstructure:"excerpt"`

	// Slug corresponds to the JSON schema field "slug".
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Title corresponds to the JSON schema field "title".
	Title string `json:"title" yaml:"title" mapstructure:"title"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThreadSummary) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in ThreadSummary: required")
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ThreadSummary: required")
	}
	if _, ok := raw["excerpt"]; raw != nil && !ok {
		return fmt.Errorf("field excerpt in ThreadSummary: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ThreadSummary: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in ThreadSummary: required")
	}
	type Plain ThreadSummary
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ThreadSummary(plain)
	return nil
}

type ToolCategoryListOutput struct {
	// Categories corresponds to the JSON schema field "categories".
	Categories []CategoryItem `json:"categories" yaml:"categories" mapstructure:"categories"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolCategoryListOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["categories"]; raw != nil && !ok {
		return fmt.Errorf("field categories in ToolCategoryListOutput: required")
	}
	type Plain ToolCategoryListOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolCategoryListOutput(plain)
	return nil
}

// List all thread categories with their names and descriptions
type ToolCategoryListYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input map[string]interface{} `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolCategoryListOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolCategoryListYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolCategoryListYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolCategoryListYaml: required")
	}
	type Plain ToolCategoryListYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolCategoryListYaml(plain)
	return nil
}

type ToolInfo struct {
	// Brief description of what the tool does
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// The tool name identifier
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolInfo) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in ToolInfo: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolInfo: required")
	}
	type Plain ToolInfo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolInfo(plain)
	return nil
}

type ToolLibraryPageCreateInput struct {
	// The content of the page in HTML format
	Content *string `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// The name/title of the page
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Slug of the parent page. Only include if you already have a parent slug
	// available. Leave empty to create a root-level page.
	Parent *string `json:"parent,omitempty" yaml:"parent,omitempty" mapstructure:"parent,omitempty"`

	// The unique slug for this page. If not provided, one will be generated from the
	// name.
	Slug *string `json:"slug,omitempty" yaml:"slug,omitempty" mapstructure:"slug,omitempty"`

	// Optional tags to categorise this page
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Optional external URL if this page references a topic on another website
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Visibility of the page (default: published)
	Visibility *ToolLibraryPageCreateInputVisibility `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

type ToolLibraryPageCreateInputVisibility string

const ToolLibraryPageCreateInputVisibilityDraft ToolLibraryPageCreateInputVisibility = "draft"
const ToolLibraryPageCreateInputVisibilityPublished ToolLibraryPageCreateInputVisibility = "published"

var enumValues_ToolLibraryPageCreateInputVisibility = []interface{}{
	"published",
	"draft",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageCreateInputVisibility) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolLibraryPageCreateInputVisibility {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolLibraryPageCreateInputVisibility, v)
	}
	*j = ToolLibraryPageCreateInputVisibility(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageCreateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolLibraryPageCreateInput: required")
	}
	type Plain ToolLibraryPageCreateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	*j = ToolLibraryPageCreateInput(plain)
	return nil
}

type ToolLibraryPageCreateOutput struct {
	// The name of the created page
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The slug of the created page
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageCreateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolLibraryPageCreateOutput: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolLibraryPageCreateOutput: required")
	}
	type Plain ToolLibraryPageCreateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageCreateOutput(plain)
	return nil
}

// Create a new page in the library. A slug will be generated automatically if not
// provided.
type ToolLibraryPageCreateYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPageCreateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPageCreateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageCreateYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPageCreateYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPageCreateYaml: required")
	}
	type Plain ToolLibraryPageCreateYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageCreateYaml(plain)
	return nil
}

type ToolLibraryPageGetInput struct {
	// The unique identifier of the library page to retrieve
	Id string `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageGetInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolLibraryPageGetInput: required")
	}
	type Plain ToolLibraryPageGetInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	*j = ToolLibraryPageGetInput(plain)
	return nil
}

type ToolLibraryPageGetOutput struct {
	// Slugs of child pages
	ChildPages []string `json:"child_pages" yaml:"child_pages" mapstructure:"child_pages"`

	// Brief description of the page
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Display name of the page
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// URL-friendly identifier for the page
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Tags associated with this page
	Tags []string `json:"tags" yaml:"tags" mapstructure:"tags"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageGetOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["child_pages"]; raw != nil && !ok {
		return fmt.Errorf("field child_pages in ToolLibraryPageGetOutput: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolLibraryPageGetOutput: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolLibraryPageGetOutput: required")
	}
	if _, ok := raw["tags"]; raw != nil && !ok {
		return fmt.Errorf("field tags in ToolLibraryPageGetOutput: required")
	}
	type Plain ToolLibraryPageGetOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageGetOutput(plain)
	return nil
}

// Get detailed information about a specific library page by its slug.
type ToolLibraryPageGetYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPageGetInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPageGetOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageGetYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPageGetYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPageGetYaml: required")
	}
	type Plain ToolLibraryPageGetYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageGetYaml(plain)
	return nil
}

// Get the full tree structure of pages in the library. Returns a hierarchical view
// of all wiki pages showing their parent-child relationships.
type ToolLibraryPageListYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPageTreeInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPageTreeOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageListYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPageListYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPageListYaml: required")
	}
	type Plain ToolLibraryPageListYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageListYaml(plain)
	return nil
}

type ToolLibraryPagePropertiesUpdateInput struct {
	// The slug or ID of the library page to update properties on
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The property values to set
	Properties []PropertyValueMutation `json:"properties" yaml:"properties" mapstructure:"properties"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPagePropertiesUpdateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolLibraryPagePropertiesUpdateInput: required")
	}
	if _, ok := raw["properties"]; raw != nil && !ok {
		return fmt.Errorf("field properties in ToolLibraryPagePropertiesUpdateInput: required")
	}
	type Plain ToolLibraryPagePropertiesUpdateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	*j = ToolLibraryPagePropertiesUpdateInput(plain)
	return nil
}

type ToolLibraryPagePropertiesUpdateOutput struct {
	// The updated property values
	Properties []PropertyValueResult `json:"properties" yaml:"properties" mapstructure:"properties"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPagePropertiesUpdateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["properties"]; raw != nil && !ok {
		return fmt.Errorf("field properties in ToolLibraryPagePropertiesUpdateOutput: required")
	}
	type Plain ToolLibraryPagePropertiesUpdateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPagePropertiesUpdateOutput(plain)
	return nil
}

// Update property values on a library page. The page must have a property schema
// defined by its parent. Each property value corresponds to a field in the schema.
type ToolLibraryPagePropertiesUpdateYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPagePropertiesUpdateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPagePropertiesUpdateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPagePropertiesUpdateYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPagePropertiesUpdateYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPagePropertiesUpdateYaml: required")
	}
	type Plain ToolLibraryPagePropertiesUpdateYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPagePropertiesUpdateYaml(plain)
	return nil
}

type ToolLibraryPagePropertySchemaGetInput struct {
	// The slug or ID of the library page to get the property schema for
	Id string `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPagePropertySchemaGetInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolLibraryPagePropertySchemaGetInput: required")
	}
	type Plain ToolLibraryPagePropertySchemaGetInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	*j = ToolLibraryPagePropertySchemaGetInput(plain)
	return nil
}

type ToolLibraryPagePropertySchemaGetOutput struct {
	// The schema fields that define properties for child pages
	Fields []PropertySchemaField `json:"fields" yaml:"fields" mapstructure:"fields"`

	// Whether this page has a property schema defined for its children
	HasSchema *bool `json:"has_schema,omitempty" yaml:"has_schema,omitempty" mapstructure:"has_schema,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPagePropertySchemaGetOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["fields"]; raw != nil && !ok {
		return fmt.Errorf("field fields in ToolLibraryPagePropertySchemaGetOutput: required")
	}
	type Plain ToolLibraryPagePropertySchemaGetOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPagePropertySchemaGetOutput(plain)
	return nil
}

// Get the property schema for a library page's children. This returns the schema
// fields that define what properties child pages can have.
type ToolLibraryPagePropertySchemaGetYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPagePropertySchemaGetInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPagePropertySchemaGetOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPagePropertySchemaGetYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPagePropertySchemaGetYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPagePropertySchemaGetYaml: required")
	}
	type Plain ToolLibraryPagePropertySchemaGetYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPagePropertySchemaGetYaml(plain)
	return nil
}

type ToolLibraryPagePropertySchemaUpdateInput struct {
	// The schema fields to set. Fields with an ID update existing fields, fields
	// without an ID create new ones. Omitted existing fields will be removed.
	Fields []PropertySchemaFieldMutation `json:"fields" yaml:"fields" mapstructure:"fields"`

	// The slug or ID of the parent library page whose children's schema to update
	Id string `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPagePropertySchemaUpdateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["fields"]; raw != nil && !ok {
		return fmt.Errorf("field fields in ToolLibraryPagePropertySchemaUpdateInput: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolLibraryPagePropertySchemaUpdateInput: required")
	}
	type Plain ToolLibraryPagePropertySchemaUpdateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	*j = ToolLibraryPagePropertySchemaUpdateInput(plain)
	return nil
}

type ToolLibraryPagePropertySchemaUpdateOutput struct {
	// The updated schema fields
	Fields []PropertySchemaFieldResult `json:"fields" yaml:"fields" mapstructure:"fields"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPagePropertySchemaUpdateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["fields"]; raw != nil && !ok {
		return fmt.Errorf("field fields in ToolLibraryPagePropertySchemaUpdateOutput: required")
	}
	type Plain ToolLibraryPagePropertySchemaUpdateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPagePropertySchemaUpdateOutput(plain)
	return nil
}

// Update the property schema for a library page's children. This defines what
// properties child pages can have. Fields without an ID will be created as new
// fields. Fields with an ID will be updated. Existing fields not in the list will
// be removed.
type ToolLibraryPagePropertySchemaUpdateYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPagePropertySchemaUpdateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPagePropertySchemaUpdateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPagePropertySchemaUpdateYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPagePropertySchemaUpdateYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPagePropertySchemaUpdateYaml: required")
	}
	type Plain ToolLibraryPagePropertySchemaUpdateYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPagePropertySchemaUpdateYaml(plain)
	return nil
}

type ToolLibraryPageSearchInput struct {
	// The search query text
	Query string `json:"query" yaml:"query" mapstructure:"query"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageSearchInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["query"]; raw != nil && !ok {
		return fmt.Errorf("field query in ToolLibraryPageSearchInput: required")
	}
	type Plain ToolLibraryPageSearchInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Query) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "query", 1)
	}
	*j = ToolLibraryPageSearchInput(plain)
	return nil
}

type ToolLibraryPageSearchOutput struct {
	// List of matching library pages
	Items []LibraryPageSearchItem `json:"items" yaml:"items" mapstructure:"items"`

	// Total number of results found
	Results int `json:"results" yaml:"results" mapstructure:"results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageSearchOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["items"]; raw != nil && !ok {
		return fmt.Errorf("field items in ToolLibraryPageSearchOutput: required")
	}
	if _, ok := raw["results"]; raw != nil && !ok {
		return fmt.Errorf("field results in ToolLibraryPageSearchOutput: required")
	}
	type Plain ToolLibraryPageSearchOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageSearchOutput(plain)
	return nil
}

type ToolLibraryPageTreeInput struct {
	// Maximum depth to traverse (-1 for unlimited, 0 for root only, 1 for root +
	// children, etc.)
	Depth *int `json:"depth,omitempty" yaml:"depth,omitempty" mapstructure:"depth,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageTreeInput) UnmarshalJSON(value []byte) error {
	type Plain ToolLibraryPageTreeInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Depth != nil && -1 > *plain.Depth {
		return fmt.Errorf("field %s: must be >= %v", "depth", -1)
	}
	*j = ToolLibraryPageTreeInput(plain)
	return nil
}

type ToolLibraryPageTreeOutput struct {
	// List of pages in tree structure
	Pages []LibraryPageTreeNode `json:"pages" yaml:"pages" mapstructure:"pages"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageTreeOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["pages"]; raw != nil && !ok {
		return fmt.Errorf("field pages in ToolLibraryPageTreeOutput: required")
	}
	type Plain ToolLibraryPageTreeOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageTreeOutput(plain)
	return nil
}

type ToolLibraryPageUpdateInput struct {
	// The new content of the page in HTML format
	Content *string `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// The unique identifier of the page to update
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The new name/title of the page
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// New parent page slug. Provide to move the page to a different parent.
	Parent *string `json:"parent,omitempty" yaml:"parent,omitempty" mapstructure:"parent,omitempty"`

	// New tags to categorise this page
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// New external URL reference
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// New visibility of the page
	Visibility *ToolLibraryPageUpdateInputVisibility `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

type ToolLibraryPageUpdateInputVisibility string

const ToolLibraryPageUpdateInputVisibilityDraft ToolLibraryPageUpdateInputVisibility = "draft"
const ToolLibraryPageUpdateInputVisibilityPublished ToolLibraryPageUpdateInputVisibility = "published"

var enumValues_ToolLibraryPageUpdateInputVisibility = []interface{}{
	"published",
	"draft",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageUpdateInputVisibility) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolLibraryPageUpdateInputVisibility {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolLibraryPageUpdateInputVisibility, v)
	}
	*j = ToolLibraryPageUpdateInputVisibility(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageUpdateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolLibraryPageUpdateInput: required")
	}
	type Plain ToolLibraryPageUpdateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	if plain.Name != nil && len(*plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	*j = ToolLibraryPageUpdateInput(plain)
	return nil
}

type ToolLibraryPageUpdateOutput struct {
	// The name of the updated page
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The slug of the updated page
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageUpdateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolLibraryPageUpdateOutput: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolLibraryPageUpdateOutput: required")
	}
	type Plain ToolLibraryPageUpdateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageUpdateOutput(plain)
	return nil
}

// Update an existing page in the library. Only provide the fields you want to
// change.
type ToolLibraryPageUpdateYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPageUpdateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPageUpdateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLibraryPageUpdateYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLibraryPageUpdateYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLibraryPageUpdateYaml: required")
	}
	type Plain ToolLibraryPageUpdateYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLibraryPageUpdateYaml(plain)
	return nil
}

type ToolLinkCreateInput struct {
	// The URL to create a bookmark for. Must be a valid HTTP/HTTPS URL.
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLinkCreateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in ToolLinkCreateInput: required")
	}
	type Plain ToolLinkCreateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLinkCreateInput(plain)
	return nil
}

type ToolLinkCreateOutput struct {
	// Description extracted from OpenGraph metadata
	OpengraphDescription *string `json:"opengraph_description,omitempty" yaml:"opengraph_description,omitempty" mapstructure:"opengraph_description,omitempty"`

	// Title extracted from OpenGraph metadata
	OpengraphTitle *string `json:"opengraph_title,omitempty" yaml:"opengraph_title,omitempty" mapstructure:"opengraph_title,omitempty"`

	// Plain text content extracted from the page
	PlainText *string `json:"plain_text,omitempty" yaml:"plain_text,omitempty" mapstructure:"plain_text,omitempty"`

	// Unique identifier for the link
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// The bookmarked URL
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLinkCreateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolLinkCreateOutput: required")
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in ToolLinkCreateOutput: required")
	}
	type Plain ToolLinkCreateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLinkCreateOutput(plain)
	return nil
}

// Create or update a link in the shared bookmarks list. Fetches the URL and
// extracts OpenGraph metadata (title, description) and plain text content. Useful
// for bookmarking websites, articles, or any web content.
type ToolLinkCreateYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLinkCreateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLinkCreateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolLinkCreateYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolLinkCreateYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolLinkCreateYaml: required")
	}
	type Plain ToolLinkCreateYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolLinkCreateYaml(plain)
	return nil
}

type ToolRobotCreateInput struct {
	// Optional human-readable description of the Robot's purpose and capabilities
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// The name of the Robot - should be descriptive and help identify its purpose
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The directive/system prompt that defines how the Robot behaves, what it helps
	// with, and its personality. This is the primary instruction that guides the
	// Robot's behavior.
	Playbook string `json:"playbook" yaml:"playbook" mapstructure:"playbook"`

	// List of tool names that the Robot can use.
	Tools []string `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotCreateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in ToolRobotCreateInput: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolRobotCreateInput: required")
	}
	if _, ok := raw["playbook"]; raw != nil && !ok {
		return fmt.Errorf("field playbook in ToolRobotCreateInput: required")
	}
	type Plain ToolRobotCreateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Playbook) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "playbook", 1)
	}
	*j = ToolRobotCreateInput(plain)
	return nil
}

type ToolRobotCreateOutput struct {
	// The unique identifier of the created Robot
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The name of the Robot
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotCreateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotCreateOutput: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolRobotCreateOutput: required")
	}
	type Plain ToolRobotCreateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotCreateOutput(plain)
	return nil
}

// Create a new Robot (agent) with a specific purpose and behavior. Robots are
// customizable automations that can help users with specific workflows using
// tailored tools and instructions.
type ToolRobotCreateYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotCreateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotCreateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotCreateYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotCreateYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotCreateYaml: required")
	}
	type Plain ToolRobotCreateYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotCreateYaml(plain)
	return nil
}

type ToolRobotDeleteInput struct {
	// The unique identifier of the Robot to delete. Must be a valid XID format (20
	// character alphanumeric string).
	Id string `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotDeleteInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotDeleteInput: required")
	}
	type Plain ToolRobotDeleteInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0-9a-v]{20}$`, string(plain.Id)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Id", `^[0-9a-v]{20}$`)
	}
	*j = ToolRobotDeleteInput(plain)
	return nil
}

type ToolRobotDeleteOutput struct {
	// The ID of the deleted Robot
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Whether the deletion was successful
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotDeleteOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotDeleteOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in ToolRobotDeleteOutput: required")
	}
	type Plain ToolRobotDeleteOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotDeleteOutput(plain)
	return nil
}

// Delete a Robot permanently.
type ToolRobotDeleteYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotDeleteInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotDeleteOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotDeleteYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotDeleteYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotDeleteYaml: required")
	}
	type Plain ToolRobotDeleteYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotDeleteYaml(plain)
	return nil
}

// List of all available tools with their names and descriptions
type ToolRobotGetAllToolNamesOutput struct {
	// Tools corresponds to the JSON schema field "tools".
	Tools []ToolInfo `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`
}

type ToolRobotGetInput struct {
	// The unique identifier of the Robot to retrieve. Must be a valid XID format (20
	// character alphanumeric string). Example: cq3pqt0q91s73dq8r000
	Id string `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotGetInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotGetInput: required")
	}
	type Plain ToolRobotGetInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0-9a-v]{20}$`, string(plain.Id)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Id", `^[0-9a-v]{20}$`)
	}
	*j = ToolRobotGetInput(plain)
	return nil
}

type ToolRobotGetOutput struct {
	// Human-readable description of the Robot's purpose
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The unique identifier of the Robot
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The name of the Robot
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The Robot's directive
	Playbook string `json:"playbook" yaml:"playbook" mapstructure:"playbook"`

	// List of tool names that the Robot can use
	Tools []string `json:"tools" yaml:"tools" mapstructure:"tools"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotGetOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotGetOutput: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolRobotGetOutput: required")
	}
	if _, ok := raw["playbook"]; raw != nil && !ok {
		return fmt.Errorf("field playbook in ToolRobotGetOutput: required")
	}
	if _, ok := raw["tools"]; raw != nil && !ok {
		return fmt.Errorf("field tools in ToolRobotGetOutput: required")
	}
	type Plain ToolRobotGetOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotGetOutput(plain)
	return nil
}

// Get details of a specific Robot by its ID. Use this to view the full
// configuration of a Robot.
type ToolRobotGetYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotGetInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotGetOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotGetYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotGetYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotGetYaml: required")
	}
	type Plain ToolRobotGetYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotGetYaml(plain)
	return nil
}

type ToolRobotListInput struct {
	// Maximum number of Robots to return (default 20)
	Limit *int `json:"limit,omitempty" yaml:"limit,omitempty" mapstructure:"limit,omitempty"`
}

type ToolRobotListOutput struct {
	// List of Robots
	Robots []RobotItem `json:"robots" yaml:"robots" mapstructure:"robots"`

	// Total number of Robots found
	Total int `json:"total" yaml:"total" mapstructure:"total"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotListOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["robots"]; raw != nil && !ok {
		return fmt.Errorf("field robots in ToolRobotListOutput: required")
	}
	if _, ok := raw["total"]; raw != nil && !ok {
		return fmt.Errorf("field total in ToolRobotListOutput: required")
	}
	type Plain ToolRobotListOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotListOutput(plain)
	return nil
}

// List all available Robots. Use this to see what Robots have been created and
// what they do.
type ToolRobotListYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotListInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotListOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotListYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotListYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotListYaml: required")
	}
	type Plain ToolRobotListYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotListYaml(plain)
	return nil
}

type ToolRobotSwitchInput struct {
	// The ID of the Robot (agent) to switch to. Must be a valid XID format (20
	// character alphanumeric string). Use robot_list to see available Robot IDs.
	RobotId string `json:"robot_id" yaml:"robot_id" mapstructure:"robot_id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotSwitchInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["robot_id"]; raw != nil && !ok {
		return fmt.Errorf("field robot_id in ToolRobotSwitchInput: required")
	}
	type Plain ToolRobotSwitchInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0-9a-v]{20}$`, string(plain.RobotId)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "RobotId", `^[0-9a-v]{20}$`)
	}
	*j = ToolRobotSwitchInput(plain)
	return nil
}

type ToolRobotSwitchOutput struct {
	// The ID of the robot that was switched to
	RobotId string `json:"robot_id" yaml:"robot_id" mapstructure:"robot_id"`

	// Whether the agent switch was successful
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotSwitchOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["robot_id"]; raw != nil && !ok {
		return fmt.Errorf("field robot_id in ToolRobotSwitchOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in ToolRobotSwitchOutput: required")
	}
	type Plain ToolRobotSwitchOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotSwitchOutput(plain)
	return nil
}

// Switch the current conversation to a different Robot (agent). Use this when the
// user wants to talk to a different specialized agent or when a different agent
// would be better suited to help with the user's request.
type ToolRobotSwitchYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotSwitchInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotSwitchOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotSwitchYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotSwitchYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotSwitchYaml: required")
	}
	type Plain ToolRobotSwitchYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotSwitchYaml(plain)
	return nil
}

type ToolRobotUpdateInput struct {
	// The new description for the Robot
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The unique identifier of the Robot to update. Must be a valid XID format (20
	// character alphanumeric string).
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The new name for the Robot
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The new directive/system prompt for the Robot
	Playbook *string `json:"playbook,omitempty" yaml:"playbook,omitempty" mapstructure:"playbook,omitempty"`

	// The new list of tool names that the Robot can use.
	Tools []string `json:"tools,omitempty" yaml:"tools,omitempty" mapstructure:"tools,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotUpdateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotUpdateInput: required")
	}
	type Plain ToolRobotUpdateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[0-9a-v]{20}$`, string(plain.Id)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Id", `^[0-9a-v]{20}$`)
	}
	if plain.Name != nil && len(*plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if plain.Playbook != nil && len(*plain.Playbook) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "playbook", 1)
	}
	*j = ToolRobotUpdateInput(plain)
	return nil
}

type ToolRobotUpdateOutput struct {
	// The unique identifier of the updated Robot
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The Robot's name
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotUpdateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolRobotUpdateOutput: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolRobotUpdateOutput: required")
	}
	type Plain ToolRobotUpdateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotUpdateOutput(plain)
	return nil
}

// Update a Robot's configuration. You can modify its name, description, playbook
// (directive), or tools. Only provide the fields you want to change.
type ToolRobotUpdateYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolRobotUpdateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotUpdateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolRobotUpdateYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolRobotUpdateYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolRobotUpdateYaml: required")
	}
	type Plain ToolRobotUpdateYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolRobotUpdateYaml(plain)
	return nil
}

type ToolSearchInput struct {
	// Filter by author handles (usernames). Do not use '@' prefix.
	Authors []string `json:"authors,omitempty" yaml:"authors,omitempty" mapstructure:"authors,omitempty"`

	// Filter by category names (for forum threads). Category names are
	// case-insensitive.
	Categories []string `json:"categories,omitempty" yaml:"categories,omitempty" mapstructure:"categories,omitempty"`

	// Filter by content types.
	Kind []DatagraphItemKindYaml `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Maximum number of results to return (default 10, max 100)
	MaxResults *int `json:"max_results,omitempty" yaml:"max_results,omitempty" mapstructure:"max_results,omitempty"`

	// The search query text
	Query string `json:"query" yaml:"query" mapstructure:"query"`

	// Filter by tag names. Tags are case-sensitive.
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolSearchInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["query"]; raw != nil && !ok {
		return fmt.Errorf("field query in ToolSearchInput: required")
	}
	type Plain ToolSearchInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.MaxResults != nil && 100 < *plain.MaxResults {
		return fmt.Errorf("field %s: must be <= %v", "max_results", 100)
	}
	if plain.MaxResults != nil && 1 > *plain.MaxResults {
		return fmt.Errorf("field %s: must be >= %v", "max_results", 1)
	}
	if len(plain.Query) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "query", 1)
	}
	*j = ToolSearchInput(plain)
	return nil
}

// Search for pages in the library wiki. Returns matching pages based on the search
// query.
type ToolSearchLibraryPagesYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolLibraryPageSearchInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolLibraryPageSearchOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolSearchLibraryPagesYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolSearchLibraryPagesYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolSearchLibraryPagesYaml: required")
	}
	type Plain ToolSearchLibraryPagesYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolSearchLibraryPagesYaml(plain)
	return nil
}

type ToolSearchOutput struct {
	// List of search results
	Items []SearchedItem `json:"items" yaml:"items" mapstructure:"items"`

	// Total number of results found
	Results int `json:"results" yaml:"results" mapstructure:"results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolSearchOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["items"]; raw != nil && !ok {
		return fmt.Errorf("field items in ToolSearchOutput: required")
	}
	if _, ok := raw["results"]; raw != nil && !ok {
		return fmt.Errorf("field results in ToolSearchOutput: required")
	}
	type Plain ToolSearchOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolSearchOutput(plain)
	return nil
}

// Search the Storyden knowledge base for library pages, forum threads, and other
// content. Returns relevant results matching the query.
type ToolSearchYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolSearchInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolSearchOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolSearchYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolSearchYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolSearchYaml: required")
	}
	type Plain ToolSearchYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolSearchYaml(plain)
	return nil
}

// Get a list of all available tool names and their descriptions. This is useful
// when creating or updating a Robot to know what tools are available without
// loading full schemas. Returns a lightweight list of tool names and brief
// descriptions.
type ToolSystemAllToolNamesYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input map[string]interface{} `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolRobotGetAllToolNamesOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolSystemAllToolNamesYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolSystemAllToolNamesYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolSystemAllToolNamesYaml: required")
	}
	type Plain ToolSystemAllToolNamesYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolSystemAllToolNamesYaml(plain)
	return nil
}

type ToolTagListInput struct {
	// Optional search query to filter tags by name. If not provided, returns all
	// tags.
	Query *string `json:"query,omitempty" yaml:"query,omitempty" mapstructure:"query,omitempty"`
}

type ToolTagListOutput struct {
	// List of tags
	Tags []TagItem `json:"tags" yaml:"tags" mapstructure:"tags"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolTagListOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["tags"]; raw != nil && !ok {
		return fmt.Errorf("field tags in ToolTagListOutput: required")
	}
	type Plain ToolTagListOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolTagListOutput(plain)
	return nil
}

// Get a list of all tags on the site or search for tags by name. Tags are labels
// used to categorize and organize content. Each tag includes its name and the
// number of items tagged with it.
type ToolTagListYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolTagListInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolTagListOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolTagListYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolTagListYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolTagListYaml: required")
	}
	type Plain ToolTagListYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolTagListYaml(plain)
	return nil
}

type ToolThreadCreateInput struct {
	// The content of the thread in HTML format
	Body string `json:"body" yaml:"body" mapstructure:"body"`

	// The category slug for the thread. Use category_list to see available
	// categories.
	Category string `json:"category" yaml:"category" mapstructure:"category"`

	// Optional tags for the thread
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// The title of the thread
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// Optional URL if this thread is about a specific link
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Thread visibility (default: published)
	Visibility *ToolThreadCreateInputVisibility `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

type ToolThreadCreateInputVisibility string

const ToolThreadCreateInputVisibilityDraft ToolThreadCreateInputVisibility = "draft"
const ToolThreadCreateInputVisibilityPublished ToolThreadCreateInputVisibility = "published"

var enumValues_ToolThreadCreateInputVisibility = []interface{}{
	"published",
	"draft",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadCreateInputVisibility) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolThreadCreateInputVisibility {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolThreadCreateInputVisibility, v)
	}
	*j = ToolThreadCreateInputVisibility(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadCreateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["body"]; raw != nil && !ok {
		return fmt.Errorf("field body in ToolThreadCreateInput: required")
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ToolThreadCreateInput: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in ToolThreadCreateInput: required")
	}
	type Plain ToolThreadCreateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Body) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "body", 1)
	}
	if len(plain.Title) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "title", 1)
	}
	*j = ToolThreadCreateInput(plain)
	return nil
}

type ToolThreadCreateOutput struct {
	// Author handle
	Author *string `json:"author,omitempty" yaml:"author,omitempty" mapstructure:"author,omitempty"`

	// Category name
	Category *string `json:"category,omitempty" yaml:"category,omitempty" mapstructure:"category,omitempty"`

	// Thread content as plain text
	Content *string `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Creation timestamp
	CreatedAt *string `json:"created_at,omitempty" yaml:"created_at,omitempty" mapstructure:"created_at,omitempty"`

	// The thread slug
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// The thread title
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// Associated URL if present
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Thread visibility
	Visibility *string `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadCreateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolThreadCreateOutput: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in ToolThreadCreateOutput: required")
	}
	type Plain ToolThreadCreateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadCreateOutput(plain)
	return nil
}

// Create a new discussion thread in the forum. Threads are discussions organized
// by category with tags for better discovery.
type ToolThreadCreateYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolThreadCreateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolThreadCreateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadCreateYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolThreadCreateYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolThreadCreateYaml: required")
	}
	type Plain ToolThreadCreateYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadCreateYaml(plain)
	return nil
}

type ToolThreadGetInput struct {
	// The unique identifier of the thread to retrieve
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Page number for replies (default: 1)
	Page *int `json:"page,omitempty" yaml:"page,omitempty" mapstructure:"page,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadGetInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolThreadGetInput: required")
	}
	type Plain ToolThreadGetInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	if plain.Page != nil && 1 > *plain.Page {
		return fmt.Errorf("field %s: must be >= %v", "page", 1)
	}
	*j = ToolThreadGetInput(plain)
	return nil
}

type ToolThreadGetOutput struct {
	// Author handle
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// Category name
	Category string `json:"category" yaml:"category" mapstructure:"category"`

	// Thread content as plain text
	Content string `json:"content" yaml:"content" mapstructure:"content"`

	// Creation timestamp
	CreatedAt string `json:"created_at" yaml:"created_at" mapstructure:"created_at"`

	// Slug corresponds to the JSON schema field "slug".
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []string `json:"tags" yaml:"tags" mapstructure:"tags"`

	// Title corresponds to the JSON schema field "title".
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// Associated URL if present
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Visibility corresponds to the JSON schema field "visibility".
	Visibility string `json:"visibility" yaml:"visibility" mapstructure:"visibility"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadGetOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in ToolThreadGetOutput: required")
	}
	if _, ok := raw["category"]; raw != nil && !ok {
		return fmt.Errorf("field category in ToolThreadGetOutput: required")
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in ToolThreadGetOutput: required")
	}
	if _, ok := raw["created_at"]; raw != nil && !ok {
		return fmt.Errorf("field created_at in ToolThreadGetOutput: required")
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolThreadGetOutput: required")
	}
	if _, ok := raw["tags"]; raw != nil && !ok {
		return fmt.Errorf("field tags in ToolThreadGetOutput: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in ToolThreadGetOutput: required")
	}
	if _, ok := raw["visibility"]; raw != nil && !ok {
		return fmt.Errorf("field visibility in ToolThreadGetOutput: required")
	}
	type Plain ToolThreadGetOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadGetOutput(plain)
	return nil
}

// Get a specific thread with its content. Returns the thread details including
// author, content, and category information.
type ToolThreadGetYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolThreadGetInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolThreadGetOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadGetYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolThreadGetYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolThreadGetYaml: required")
	}
	type Plain ToolThreadGetYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadGetYaml(plain)
	return nil
}

type ToolThreadListInput struct {
	// Page number (default: 1)
	Page *int `json:"page,omitempty" yaml:"page,omitempty" mapstructure:"page,omitempty"`

	// Search query to filter threads
	Query *string `json:"query,omitempty" yaml:"query,omitempty" mapstructure:"query,omitempty"`

	// Filter by visibility
	Visibility *ToolThreadListInputVisibility `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

type ToolThreadListInputVisibility string

const ToolThreadListInputVisibilityDraft ToolThreadListInputVisibility = "draft"
const ToolThreadListInputVisibilityPublished ToolThreadListInputVisibility = "published"

var enumValues_ToolThreadListInputVisibility = []interface{}{
	"draft",
	"published",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadListInputVisibility) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolThreadListInputVisibility {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolThreadListInputVisibility, v)
	}
	*j = ToolThreadListInputVisibility(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadListInput) UnmarshalJSON(value []byte) error {
	type Plain ToolThreadListInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Page != nil && 1 > *plain.Page {
		return fmt.Errorf("field %s: must be >= %v", "page", 1)
	}
	*j = ToolThreadListInput(plain)
	return nil
}

type ToolThreadListOutput struct {
	// CurrentPage corresponds to the JSON schema field "current_page".
	CurrentPage int `json:"current_page" yaml:"current_page" mapstructure:"current_page"`

	// Next page number if available
	NextPage *int `json:"next_page,omitempty" yaml:"next_page,omitempty" mapstructure:"next_page,omitempty"`

	// Threads corresponds to the JSON schema field "threads".
	Threads []ThreadSummary `json:"threads" yaml:"threads" mapstructure:"threads"`

	// TotalPages corresponds to the JSON schema field "total_pages".
	TotalPages int `json:"total_pages" yaml:"total_pages" mapstructure:"total_pages"`

	// TotalResults corresponds to the JSON schema field "total_results".
	TotalResults int `json:"total_results" yaml:"total_results" mapstructure:"total_results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadListOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["current_page"]; raw != nil && !ok {
		return fmt.Errorf("field current_page in ToolThreadListOutput: required")
	}
	if _, ok := raw["threads"]; raw != nil && !ok {
		return fmt.Errorf("field threads in ToolThreadListOutput: required")
	}
	if _, ok := raw["total_pages"]; raw != nil && !ok {
		return fmt.Errorf("field total_pages in ToolThreadListOutput: required")
	}
	if _, ok := raw["total_results"]; raw != nil && !ok {
		return fmt.Errorf("field total_results in ToolThreadListOutput: required")
	}
	type Plain ToolThreadListOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadListOutput(plain)
	return nil
}

// List and search discussion threads with filtering and pagination.
type ToolThreadListYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolThreadListInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolThreadListOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadListYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolThreadListYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolThreadListYaml: required")
	}
	type Plain ToolThreadListYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadListYaml(plain)
	return nil
}

type ToolThreadReplyInput struct {
	// The reply content in HTML format
	Body string `json:"body" yaml:"body" mapstructure:"body"`

	// The unique identifier of the thread to reply to
	Id string `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadReplyInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["body"]; raw != nil && !ok {
		return fmt.Errorf("field body in ToolThreadReplyInput: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolThreadReplyInput: required")
	}
	type Plain ToolThreadReplyInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Body) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "body", 1)
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	*j = ToolThreadReplyInput(plain)
	return nil
}

type ToolThreadReplyOutput struct {
	// Author handle
	Author string `json:"author" yaml:"author" mapstructure:"author"`

	// Reply content as plain text
	Content string `json:"content" yaml:"content" mapstructure:"content"`

	// Creation timestamp
	CreatedAt string `json:"created_at" yaml:"created_at" mapstructure:"created_at"`

	// Update timestamp
	UpdatedAt string `json:"updated_at" yaml:"updated_at" mapstructure:"updated_at"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadReplyOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["author"]; raw != nil && !ok {
		return fmt.Errorf("field author in ToolThreadReplyOutput: required")
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in ToolThreadReplyOutput: required")
	}
	if _, ok := raw["created_at"]; raw != nil && !ok {
		return fmt.Errorf("field created_at in ToolThreadReplyOutput: required")
	}
	if _, ok := raw["updated_at"]; raw != nil && !ok {
		return fmt.Errorf("field updated_at in ToolThreadReplyOutput: required")
	}
	type Plain ToolThreadReplyOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadReplyOutput(plain)
	return nil
}

// Add a reply to an existing thread
type ToolThreadReplyYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolThreadReplyInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolThreadReplyOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadReplyYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolThreadReplyYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolThreadReplyYaml: required")
	}
	type Plain ToolThreadReplyYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadReplyYaml(plain)
	return nil
}

type ToolThreadUpdateInput struct {
	// New content for the thread in HTML format
	Body *string `json:"body,omitempty" yaml:"body,omitempty" mapstructure:"body,omitempty"`

	// The unique identifier of the thread to update
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// New tags for the thread
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// New title for the thread
	Title *string `json:"title,omitempty" yaml:"title,omitempty" mapstructure:"title,omitempty"`

	// New visibility: published or draft
	Visibility *ToolThreadUpdateInputVisibility `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

type ToolThreadUpdateInputVisibility string

const ToolThreadUpdateInputVisibilityDraft ToolThreadUpdateInputVisibility = "draft"
const ToolThreadUpdateInputVisibilityPublished ToolThreadUpdateInputVisibility = "published"

var enumValues_ToolThreadUpdateInputVisibility = []interface{}{
	"published",
	"draft",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadUpdateInputVisibility) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolThreadUpdateInputVisibility {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolThreadUpdateInputVisibility, v)
	}
	*j = ToolThreadUpdateInputVisibility(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadUpdateInput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ToolThreadUpdateInput: required")
	}
	type Plain ToolThreadUpdateInput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Body != nil && len(*plain.Body) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "body", 1)
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	*j = ToolThreadUpdateInput(plain)
	return nil
}

type ToolThreadUpdateOutput struct {
	// Author handle
	Author *string `json:"author,omitempty" yaml:"author,omitempty" mapstructure:"author,omitempty"`

	// Category name
	Category *string `json:"category,omitempty" yaml:"category,omitempty" mapstructure:"category,omitempty"`

	// Thread content as plain text
	Content *string `json:"content,omitempty" yaml:"content,omitempty" mapstructure:"content,omitempty"`

	// Creation timestamp
	CreatedAt *string `json:"created_at,omitempty" yaml:"created_at,omitempty" mapstructure:"created_at,omitempty"`

	// The thread slug
	Slug string `json:"slug" yaml:"slug" mapstructure:"slug"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// The thread title
	Title string `json:"title" yaml:"title" mapstructure:"title"`

	// Associated URL if present
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Thread visibility
	Visibility *string `json:"visibility,omitempty" yaml:"visibility,omitempty" mapstructure:"visibility,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadUpdateOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["slug"]; raw != nil && !ok {
		return fmt.Errorf("field slug in ToolThreadUpdateOutput: required")
	}
	if _, ok := raw["title"]; raw != nil && !ok {
		return fmt.Errorf("field title in ToolThreadUpdateOutput: required")
	}
	type Plain ToolThreadUpdateOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadUpdateOutput(plain)
	return nil
}

// Update an existing thread's properties
type ToolThreadUpdateYaml struct {
	// Input corresponds to the JSON schema field "input".
	Input ToolThreadUpdateInput `json:"input" yaml:"input" mapstructure:"input"`

	// Output corresponds to the JSON schema field "output".
	Output ToolThreadUpdateOutput `json:"output" yaml:"output" mapstructure:"output"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolThreadUpdateYaml) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in ToolThreadUpdateYaml: required")
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in ToolThreadUpdateYaml: required")
	}
	type Plain ToolThreadUpdateYaml
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ToolThreadUpdateYaml(plain)
	return nil
}
