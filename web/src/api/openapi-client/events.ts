/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.26.3-canary
 */
import useSwr from "swr";
import type { Arguments, Key, SWRConfiguration } from "swr";
import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import { fetcher } from "../client";
import type {
  EventCreateBody,
  EventCreateOKResponse,
  EventGetOKResponse,
  EventListOKResponse,
  EventListParams,
  EventParticipantUpdateBody,
  EventUpdateBody,
  EventUpdateOKResponse,
  InternalServerErrorResponse,
  NotFoundResponse,
  UnauthorisedResponse,
} from "../openapi-schema";

/**
 * List all events using the filtering options.
 */
export const eventList = (params?: EventListParams) => {
  return fetcher<EventListOKResponse>({
    url: `/events`,
    method: "GET",
    params,
  });
};

export const getEventListKey = (params?: EventListParams) =>
  [`/events`, ...(params ? [params] : [])] as const;

export type EventListQueryResult = NonNullable<
  Awaited<ReturnType<typeof eventList>>
>;
export type EventListQueryError =
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useEventList = <
  TError = NotFoundResponse | InternalServerErrorResponse,
>(
  params?: EventListParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof eventList>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getEventListKey(params) : null));
  const swrFn = () => eventList(params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Create a new event. When an event is created, a thread is also created
which provides the means for discussion via the thread and reply APIs.

 */
export const eventCreate = (eventCreateBody: EventCreateBody) => {
  return fetcher<EventCreateOKResponse>({
    url: `/events`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: eventCreateBody,
  });
};

export const getEventCreateMutationFetcher = () => {
  return (
    _: Key,
    { arg }: { arg: EventCreateBody },
  ): Promise<EventCreateOKResponse> => {
    return eventCreate(arg);
  };
};
export const getEventCreateMutationKey = () => [`/events`] as const;

export type EventCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventCreate>>
>;
export type EventCreateMutationError =
  | UnauthorisedResponse
  | InternalServerErrorResponse;

export const useEventCreate = <
  TError = UnauthorisedResponse | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof eventCreate>>,
    TError,
    Key,
    EventCreateBody,
    Awaited<ReturnType<typeof eventCreate>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getEventCreateMutationKey();
  const swrFn = getEventCreateMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get an event by its ID.
 */
export const eventGet = (eventMark: string) => {
  return fetcher<EventGetOKResponse>({
    url: `/events/${eventMark}`,
    method: "GET",
  });
};

export const getEventGetKey = (eventMark: string) =>
  [`/events/${eventMark}`] as const;

export type EventGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof eventGet>>
>;
export type EventGetQueryError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useEventGet = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  eventMark: string,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof eventGet>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!eventMark;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getEventGetKey(eventMark) : null));
  const swrFn = () => eventGet(eventMark);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Update an event. If the content field is updated, this is stored on the
thread associated with the event, rather than the event itself. It's 
possible to update that thread directly using `threads` operations.

 */
export const eventUpdate = (
  eventMark: string,
  eventUpdateBody: EventUpdateBody,
) => {
  return fetcher<EventUpdateOKResponse>({
    url: `/events/${eventMark}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: eventUpdateBody,
  });
};

export const getEventUpdateMutationFetcher = (eventMark: string) => {
  return (
    _: Key,
    { arg }: { arg: EventUpdateBody },
  ): Promise<EventUpdateOKResponse> => {
    return eventUpdate(eventMark, arg);
  };
};
export const getEventUpdateMutationKey = (eventMark: string) =>
  [`/events/${eventMark}`] as const;

export type EventUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventUpdate>>
>;
export type EventUpdateMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useEventUpdate = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  eventMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof eventUpdate>>,
      TError,
      Key,
      EventUpdateBody,
      Awaited<ReturnType<typeof eventUpdate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getEventUpdateMutationKey(eventMark);
  const swrFn = getEventUpdateMutationFetcher(eventMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Delete an event.
 */
export const eventDelete = (eventMark: string) => {
  return fetcher<void>({ url: `/events/${eventMark}`, method: "DELETE" });
};

export const getEventDeleteMutationFetcher = (eventMark: string) => {
  return (_: Key, __: { arg: Arguments }): Promise<void> => {
    return eventDelete(eventMark);
  };
};
export const getEventDeleteMutationKey = (eventMark: string) =>
  [`/events/${eventMark}`] as const;

export type EventDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventDelete>>
>;
export type EventDeleteMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useEventDelete = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  eventMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof eventDelete>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof eventDelete>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getEventDeleteMutationKey(eventMark);
  const swrFn = getEventDeleteMutationFetcher(eventMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Add a participant to an event or change an existing participant's state.

If the requesting account is an admin or holds MANAGE_EVENTS permission,
they can change the participation properties of any account. Otherwise,
they can only change their own participation properties.

For non-managing members (i.e. not an admin and not a host) this will
follow a stricter state machine for the participation status. If the
participation status is not set (no participation record is present) or
set to "declined", the member may only set their status to "requested"
if the event policy is set to "invite_only". Otherwise, they may set it
to "attending". If the member is already set to one of these states,
they may change it to "declined".

A non-managing member cannot change their role and the default is
"attendee", only managing members can change participant roles.

If the event participation policy is set to "invite_only" then members
can only set their status to "requested" or delete their participation.

If the event participation policy is set to "closed", it's a no-op.

Requests to this resource are idempotent given identical request bodies.
It acts as a create-or-update action as participation is account-unique.

 */
export const eventParticipantUpdate = (
  eventMark: string,
  accountId: string,
  eventParticipantUpdateBody: EventParticipantUpdateBody,
) => {
  return fetcher<void>({
    url: `/events/${eventMark}/participants/${accountId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: eventParticipantUpdateBody,
  });
};

export const getEventParticipantUpdateMutationFetcher = (
  eventMark: string,
  accountId: string,
) => {
  return (
    _: Key,
    { arg }: { arg: EventParticipantUpdateBody },
  ): Promise<void> => {
    return eventParticipantUpdate(eventMark, accountId, arg);
  };
};
export const getEventParticipantUpdateMutationKey = (
  eventMark: string,
  accountId: string,
) => [`/events/${eventMark}/participants/${accountId}`] as const;

export type EventParticipantUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventParticipantUpdate>>
>;
export type EventParticipantUpdateMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useEventParticipantUpdate = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  eventMark: string,
  accountId: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof eventParticipantUpdate>>,
      TError,
      Key,
      EventParticipantUpdateBody,
      Awaited<ReturnType<typeof eventParticipantUpdate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getEventParticipantUpdateMutationKey(eventMark, accountId);
  const swrFn = getEventParticipantUpdateMutationFetcher(eventMark, accountId);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Remove a participant from an event. Same rules as EventParticipantUpdate
where non-managing members may only remove themselves. Not soft-delete.

 */
export const eventParticipantRemove = (
  eventMark: string,
  accountId: string,
) => {
  return fetcher<void>({
    url: `/events/${eventMark}/participants/${accountId}`,
    method: "DELETE",
  });
};

export const getEventParticipantRemoveMutationFetcher = (
  eventMark: string,
  accountId: string,
) => {
  return (_: Key, __: { arg: Arguments }): Promise<void> => {
    return eventParticipantRemove(eventMark, accountId);
  };
};
export const getEventParticipantRemoveMutationKey = (
  eventMark: string,
  accountId: string,
) => [`/events/${eventMark}/participants/${accountId}`] as const;

export type EventParticipantRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventParticipantRemove>>
>;
export type EventParticipantRemoveMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useEventParticipantRemove = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  eventMark: string,
  accountId: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof eventParticipantRemove>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof eventParticipantRemove>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getEventParticipantRemoveMutationKey(eventMark, accountId);
  const swrFn = getEventParticipantRemoveMutationFetcher(eventMark, accountId);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
