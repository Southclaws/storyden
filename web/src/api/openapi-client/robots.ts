/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.26.3-canary
 */
import useSwr from "swr";
import type { Key, SWRConfiguration } from "swr";
import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import { fetcher } from "../client";
import type {
  ForbiddenResponse,
  InternalServerErrorResponse,
  NotFoundResponse,
  RobotChatStartBody,
  RobotChatStreamResponse,
  RobotCreateBody,
  RobotCreateOKResponse,
  RobotGetOKResponse,
  RobotSessionGetOKResponse,
  RobotSessionGetParams,
  RobotSessionsListOKResponse,
  RobotSessionsListParams,
  RobotUpdateBody,
  RobotsListOKResponse,
  RobotsListParams,
  UnauthorisedResponse,
} from "../openapi-schema";

/**
 * Get a paginated list of all available robots.
 * @summary List robots
 */
export const robotsList = (params?: RobotsListParams) => {
  return fetcher<RobotsListOKResponse>({
    url: `/robots`,
    method: "GET",
    params,
  });
};

export const getRobotsListKey = (params?: RobotsListParams) =>
  [`/robots`, ...(params ? [params] : [])] as const;

export type RobotsListQueryResult = NonNullable<
  Awaited<ReturnType<typeof robotsList>>
>;
export type RobotsListQueryError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | InternalServerErrorResponse;

/**
 * @summary List robots
 */
export const useRobotsList = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | InternalServerErrorResponse,
>(
  params?: RobotsListParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof robotsList>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getRobotsListKey(params) : null));
  const swrFn = () => robotsList(params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Create a new Robot with the specified configuration. A Robot in Storyden
consists of a name and description (for humans) as well as a playbook,
and a set of available tools to interact with Storyden or plugins. The
playbook is a detailed set of instructions that guides behaviour of the
Robot to help it assist members in achieving a specific automation goal.
Tools are available from either Storyden or plugins that allow it to
perform actions or query data. Robots never need all tools and it's best
to build goal-specific Robots with minimal sets of tools.

 * @summary Create a robot
 */
export const robotCreate = (robotCreateBody: RobotCreateBody) => {
  return fetcher<RobotCreateOKResponse>({
    url: `/robots`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: robotCreateBody,
  });
};

export const getRobotCreateMutationFetcher = () => {
  return (
    _: Key,
    { arg }: { arg: RobotCreateBody },
  ): Promise<RobotCreateOKResponse> => {
    return robotCreate(arg);
  };
};
export const getRobotCreateMutationKey = () => [`/robots`] as const;

export type RobotCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof robotCreate>>
>;
export type RobotCreateMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | InternalServerErrorResponse;

/**
 * @summary Create a robot
 */
export const useRobotCreate = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof robotCreate>>,
    TError,
    Key,
    RobotCreateBody,
    Awaited<ReturnType<typeof robotCreate>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getRobotCreateMutationKey();
  const swrFn = getRobotCreateMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Send a message to a Robot and receive its response. This endpoint
manages sessions automatically, creating new sessions as needed or
continuing existing sessions based on the provided session ID.

Each message sent to the Robot is processed according to its playbook
and available tools, allowing it to perform actions or retrieve data
as part of the conversation. The response from the Robot includes its
reply message along with any actions taken during the interaction.

This endpoint is a Server Sent Events (SSE) stream, meaning that the
response is streamed back to the client in real-time as the Robot
generates its reply.

 */
export const robotChatSSE = (robotChatStartBody: RobotChatStartBody) => {
  return fetcher<RobotChatStreamResponse>({
    url: `/robots/chat/sse`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: robotChatStartBody,
  });
};

export const getRobotChatSSEMutationFetcher = () => {
  return (
    _: Key,
    { arg }: { arg: RobotChatStartBody },
  ): Promise<RobotChatStreamResponse> => {
    return robotChatSSE(arg);
  };
};
export const getRobotChatSSEMutationKey = () => [`/robots/chat/sse`] as const;

export type RobotChatSSEMutationResult = NonNullable<
  Awaited<ReturnType<typeof robotChatSSE>>
>;
export type RobotChatSSEMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useRobotChatSSE = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof robotChatSSE>>,
    TError,
    Key,
    RobotChatStartBody,
    Awaited<ReturnType<typeof robotChatSSE>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getRobotChatSSEMutationKey();
  const swrFn = getRobotChatSSEMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Retrieve a specific Robot by its ID. Does not include any messages or
sessions associated with the Robot, just provides metadata about it.

 * @summary Get a robot
 */
export const robotGet = (robotId: string) => {
  return fetcher<RobotGetOKResponse>({
    url: `/robots/${robotId}`,
    method: "GET",
  });
};

export const getRobotGetKey = (robotId: string) =>
  [`/robots/${robotId}`] as const;

export type RobotGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof robotGet>>
>;
export type RobotGetQueryError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

/**
 * @summary Get a robot
 */
export const useRobotGet = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  robotId: string,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof robotGet>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!robotId;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getRobotGetKey(robotId) : null));
  const swrFn = () => robotGet(robotId);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Update a Robot's name, description, playbook or available tools.

 * @summary Update a robot
 */
export const robotUpdate = (
  robotId: string,
  robotUpdateBody: RobotUpdateBody,
) => {
  return fetcher<RobotGetOKResponse>({
    url: `/robots/${robotId}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: robotUpdateBody,
  });
};

export const getRobotUpdateMutationFetcher = (robotId: string) => {
  return (
    _: Key,
    { arg }: { arg: RobotUpdateBody },
  ): Promise<RobotGetOKResponse> => {
    return robotUpdate(robotId, arg);
  };
};
export const getRobotUpdateMutationKey = (robotId: string) =>
  [`/robots/${robotId}`] as const;

export type RobotUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof robotUpdate>>
>;
export type RobotUpdateMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

/**
 * @summary Update a robot
 */
export const useRobotUpdate = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  robotId: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof robotUpdate>>,
      TError,
      Key,
      RobotUpdateBody,
      Awaited<ReturnType<typeof robotUpdate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getRobotUpdateMutationKey(robotId);
  const swrFn = getRobotUpdateMutationFetcher(robotId);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get a paginated list of Robot sessions. These are chat sessions with the
Robot system. One session may span multiple Robots as members can switch
which Robot they are talking to mid conversation, or the Robot itself
may choose to switch to another Robot to achieve a goal. A session is a
representation of an entire conversation thread with the Robot system.

You may include an account ID to filter sessions by account. Only those
with "USE_ROBOTS" permission can use Robots, however sessions, messages
and usage is not considered hidden to other accounts with the usage
permission. Robots are intended as administrative or moderation tools
to be shared among the team rather than private assistants.

 * @summary List robot sessions
 */
export const robotSessionsList = (params?: RobotSessionsListParams) => {
  return fetcher<RobotSessionsListOKResponse>({
    url: `/robots/sessions`,
    method: "GET",
    params,
  });
};

export const getRobotSessionsListKey = (params?: RobotSessionsListParams) =>
  [`/robots/sessions`, ...(params ? [params] : [])] as const;

export type RobotSessionsListQueryResult = NonNullable<
  Awaited<ReturnType<typeof robotSessionsList>>
>;
export type RobotSessionsListQueryError =
  | UnauthorisedResponse
  | InternalServerErrorResponse;

/**
 * @summary List robot sessions
 */
export const useRobotSessionsList = <
  TError = UnauthorisedResponse | InternalServerErrorResponse,
>(
  params?: RobotSessionsListParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof robotSessionsList>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getRobotSessionsListKey(params) : null));
  const swrFn = () => robotSessionsList(params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Retrieve a specific robot session with all of its messages. Sessions can
involve interactions with multiple Robots so the Robot is specified on
each message. Messages may not be representative of exactly what is sent
into a language model, as certain optimisations may be performed before
this such as compaction, summarisation or removal of irrelevant context.

Any member with "USE_ROBOTS" can see any other members' sessions and
messages with a Robot. Robots are not considered private assistants, but
rather shared tools for the team to use for managing their community.

 * @summary Get a robot session
 */
export const robotSessionGet = (
  sessionId: string,
  params?: RobotSessionGetParams,
) => {
  return fetcher<RobotSessionGetOKResponse>({
    url: `/robots/sessions/${sessionId}`,
    method: "GET",
    params,
  });
};

export const getRobotSessionGetKey = (
  sessionId: string,
  params?: RobotSessionGetParams,
) => [`/robots/sessions/${sessionId}`, ...(params ? [params] : [])] as const;

export type RobotSessionGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof robotSessionGet>>
>;
export type RobotSessionGetQueryError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

/**
 * @summary Get a robot session
 */
export const useRobotSessionGet = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  sessionId: string,
  params?: RobotSessionGetParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof robotSessionGet>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!sessionId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getRobotSessionGetKey(sessionId, params) : null));
  const swrFn = () => robotSessionGet(sessionId, params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
