/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.26.3-canary
 */
import useSwr from "swr";
import type { Key, SWRConfiguration } from "swr";
import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import { fetcher } from "../client";
import type {
  AssetGetOKResponse,
  AssetUploadBody,
  BeaconBody,
  GetInfoOKResponse,
  GetSpec200,
  InternalServerErrorResponse,
  UnauthorisedResponse,
} from "../openapi-schema";

/**
 * The version number includes the date and time of the release build as
well as a short representation of the Git commit hash.

 * @summary Get the software version string.
 */
export const getVersion = () => {
  return fetcher<string>({ url: `/version`, method: "GET" });
};

export const getGetVersionKey = () => [`/version`] as const;

export type GetVersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVersion>>
>;
export type GetVersionQueryError = InternalServerErrorResponse;

/**
 * @summary Get the software version string.
 */
export const useGetVersion = <TError = InternalServerErrorResponse>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getVersion>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
}) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetVersionKey() : null));
  const swrFn = () => getVersion();

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * This endpoint returns the OpenAPI specification for the Storyden API in
JSON format. This is useful for clients that want to dynamically load
the API specification for documentation or code generation.

 * @summary OpenAPI specification
 */
export const getSpec = () => {
  return fetcher<GetSpec200>({ url: `/openapi.json`, method: "GET" });
};

export const getGetSpecKey = () => [`/openapi.json`] as const;

export type GetSpecQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpec>>
>;
export type GetSpecQueryError = InternalServerErrorResponse;

/**
 * @summary OpenAPI specification
 */
export const useGetSpec = <TError = InternalServerErrorResponse>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getSpec>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
}) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetSpecKey() : null));
  const swrFn = () => getSpec();

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * This endpoint returns the OpenAPI documentation for the Storyden API in
an interactive HTML format. This is useful for developers who want to
explore the API and test endpoints without writing code.

 * @summary API documentation
 */
export const getDocs = () => {
  return fetcher<string>({ url: `/docs`, method: "GET" });
};

export const getGetDocsKey = () => [`/docs`] as const;

export type GetDocsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDocs>>
>;
export type GetDocsQueryError = InternalServerErrorResponse;

/**
 * @summary API documentation
 */
export const useGetDocs = <TError = InternalServerErrorResponse>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getDocs>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
}) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetDocsKey() : null));
  const swrFn = () => getDocs();

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get the basic forum installation info such as title, description, etc.

This is a fully public endpoint as it drives the ability to render stuff
like OpenGraph metadata, favicon, titles, descriptions, for crawlers.

 */
export const getInfo = () => {
  return fetcher<GetInfoOKResponse>({ url: `/info`, method: "GET" });
};

export const getGetInfoKey = () => [`/info`] as const;

export type GetInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInfo>>
>;
export type GetInfoQueryError = InternalServerErrorResponse;

export const useGetInfo = <TError = InternalServerErrorResponse>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getInfo>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
}) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetInfoKey() : null));
  const swrFn = () => getInfo();

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get the logo icon image.
 */
export const iconGet = (
  iconSize: "512x512" | "32x32" | "180x180" | "120x120" | "167x167" | "152x152",
) => {
  return fetcher<AssetGetOKResponse>({
    url: `/info/icon/${iconSize}`,
    method: "GET",
  });
};

export const getIconGetKey = (
  iconSize: "512x512" | "32x32" | "180x180" | "120x120" | "167x167" | "152x152",
) => [`/info/icon/${iconSize}`] as const;

export type IconGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof iconGet>>
>;
export type IconGetQueryError = InternalServerErrorResponse;

export const useIconGet = <TError = InternalServerErrorResponse>(
  iconSize: "512x512" | "32x32" | "180x180" | "120x120" | "167x167" | "152x152",
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof iconGet>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!iconSize;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getIconGetKey(iconSize) : null));
  const swrFn = () => iconGet(iconSize);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Upload and process the installation's logo image.
 */
export const iconUpload = (assetUploadBody: AssetUploadBody) => {
  return fetcher<void>({
    url: `/info/icon`,
    method: "POST",
    headers: { "Content-Type": "application/octet-stream" },
    data: assetUploadBody,
  });
};

export const getIconUploadMutationFetcher = () => {
  return (_: Key, { arg }: { arg: AssetUploadBody }): Promise<void> => {
    return iconUpload(arg);
  };
};
export const getIconUploadMutationKey = () => [`/info/icon`] as const;

export type IconUploadMutationResult = NonNullable<
  Awaited<ReturnType<typeof iconUpload>>
>;
export type IconUploadMutationError =
  | UnauthorisedResponse
  | InternalServerErrorResponse;

export const useIconUpload = <
  TError = UnauthorisedResponse | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof iconUpload>>,
    TError,
    Key,
    AssetUploadBody,
    Awaited<ReturnType<typeof iconUpload>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getIconUploadMutationKey();
  const swrFn = getIconUploadMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get the banner image.
 */
export const bannerGet = () => {
  return fetcher<AssetGetOKResponse>({ url: `/info/banner`, method: "GET" });
};

export const getBannerGetKey = () => [`/info/banner`] as const;

export type BannerGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof bannerGet>>
>;
export type BannerGetQueryError = InternalServerErrorResponse;

export const useBannerGet = <TError = InternalServerErrorResponse>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof bannerGet>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
}) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getBannerGetKey() : null));
  const swrFn = () => bannerGet();

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Upload and process the installation's banner image.
 */
export const bannerUpload = (assetUploadBody: AssetUploadBody) => {
  return fetcher<void>({
    url: `/info/banner`,
    method: "POST",
    headers: { "Content-Type": "application/octet-stream" },
    data: assetUploadBody,
  });
};

export const getBannerUploadMutationFetcher = () => {
  return (_: Key, { arg }: { arg: AssetUploadBody }): Promise<void> => {
    return bannerUpload(arg);
  };
};
export const getBannerUploadMutationKey = () => [`/info/banner`] as const;

export type BannerUploadMutationResult = NonNullable<
  Awaited<ReturnType<typeof bannerUpload>>
>;
export type BannerUploadMutationError =
  | UnauthorisedResponse
  | InternalServerErrorResponse;

export const useBannerUpload = <
  TError = UnauthorisedResponse | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof bannerUpload>>,
    TError,
    Key,
    AssetUploadBody,
    Awaited<ReturnType<typeof bannerUpload>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getBannerUploadMutationKey();
  const swrFn = getBannerUploadMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * A catch-all endpoint for tracking read states and other things that are
not critical to the functioning of the platform. This endpoint is fire
and forget and does not return any meaningful data. It is designed to
be used with the `navigator.sendBeacon` API in browsers to mark things
such as how far down a thread a member has read, or whether or not a
Library Page has been visited recently. It may queue the work for later
processing and is not guaranteed to be processed immediately or at all.

 */
export const sendBeacon = (beaconBody: BeaconBody) => {
  return fetcher<void>({
    url: `/beacon`,
    method: "POST",
    headers: { "Content-Type": "text/plain" },
    data: beaconBody,
  });
};

export const getSendBeaconMutationFetcher = () => {
  return (_: Key, { arg }: { arg: BeaconBody }): Promise<void> => {
    return sendBeacon(arg);
  };
};
export const getSendBeaconMutationKey = () => [`/beacon`] as const;

export type SendBeaconMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendBeacon>>
>;
export type SendBeaconMutationError = InternalServerErrorResponse;

export const useSendBeacon = <TError = InternalServerErrorResponse>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof sendBeacon>>,
    TError,
    Key,
    BeaconBody,
    Awaited<ReturnType<typeof sendBeacon>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getSendBeaconMutationKey();
  const swrFn = getSendBeaconMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
