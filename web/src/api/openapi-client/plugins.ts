/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.26.3-canary
 */
import useSwr from "swr";
import type { Arguments, Key, SWRConfiguration } from "swr";
import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import { fetcher } from "../client";
import type {
  BadRequestResponse,
  InternalServerErrorResponse,
  NoContentResponse,
  NotFoundResponse,
  PluginAddBody,
  PluginCycleTokenOKResponse,
  PluginGetConfigurationOKResponse,
  PluginGetConfigurationSchemaOKResponse,
  PluginGetLogsOKResponse,
  PluginGetOKResponse,
  PluginListOKResponse,
  PluginSetActiveStateBody,
  PluginUpdateConfigurationBody,
  PluginUpdateManifestBody,
  PluginUpdatePackageBody,
  UnauthorisedResponse,
} from "../openapi-schema";

/**
 * List all plugins that are installed on the instance.
 */
export const pluginList = () => {
  return fetcher<PluginListOKResponse>({ url: `/plugins`, method: "GET" });
};

export const getPluginListKey = () => [`/plugins`] as const;

export type PluginListQueryResult = NonNullable<
  Awaited<ReturnType<typeof pluginList>>
>;
export type PluginListQueryError = InternalServerErrorResponse;

export const usePluginList = <TError = InternalServerErrorResponse>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof pluginList>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
}) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getPluginListKey() : null));
  const swrFn = () => pluginList();

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Add a plugin to the instance. This will not install or activate the
plugin immediately. It will validate and prepare the plugin for install.

Plugins can be uploaded directly as files or via a URL to a repository.

 */
export const pluginAdd = (pluginAddBody: PluginAddBody) => {
  return fetcher<PluginGetOKResponse>({
    url: `/plugins`,
    method: "POST",
    headers: { "Content-Type": "application/zip" },
    data: pluginAddBody,
  });
};

export const getPluginAddMutationFetcher = () => {
  return (
    _: Key,
    { arg }: { arg: PluginAddBody },
  ): Promise<PluginGetOKResponse> => {
    return pluginAdd(arg);
  };
};
export const getPluginAddMutationKey = () => [`/plugins`] as const;

export type PluginAddMutationResult = NonNullable<
  Awaited<ReturnType<typeof pluginAdd>>
>;
export type PluginAddMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | InternalServerErrorResponse;

export const usePluginAdd = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof pluginAdd>>,
    TError,
    Key,
    PluginAddBody,
    Awaited<ReturnType<typeof pluginAdd>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getPluginAddMutationKey();
  const swrFn = getPluginAddMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get information about a specific plugin.
 */
export const pluginGet = (pluginInstanceId: string) => {
  return fetcher<PluginGetOKResponse>({
    url: `/plugins/${pluginInstanceId}`,
    method: "GET",
  });
};

export const getPluginGetKey = (pluginInstanceId: string) =>
  [`/plugins/${pluginInstanceId}`] as const;

export type PluginGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof pluginGet>>
>;
export type PluginGetQueryError =
  | NotFoundResponse
  | InternalServerErrorResponse;

export const usePluginGet = <
  TError = NotFoundResponse | InternalServerErrorResponse,
>(
  pluginInstanceId: string,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof pluginGet>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!pluginInstanceId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getPluginGetKey(pluginInstanceId) : null));
  const swrFn = () => pluginGet(pluginInstanceId);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Completely delete a plugin from the instance. This will uninstall the
plugin first then remove its binary file from the storage backend.

Some plugins may write additional data to the instance, this will not
be removed by this operation unless the plugin cleans up after itself.

 */
export const pluginDelete = (pluginInstanceId: string) => {
  return fetcher<NoContentResponse>({
    url: `/plugins/${pluginInstanceId}`,
    method: "DELETE",
  });
};

export const getPluginDeleteMutationFetcher = (pluginInstanceId: string) => {
  return (_: Key, __: { arg: Arguments }): Promise<NoContentResponse> => {
    return pluginDelete(pluginInstanceId);
  };
};
export const getPluginDeleteMutationKey = (pluginInstanceId: string) =>
  [`/plugins/${pluginInstanceId}`] as const;

export type PluginDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof pluginDelete>>
>;
export type PluginDeleteMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const usePluginDelete = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  pluginInstanceId: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof pluginDelete>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof pluginDelete>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getPluginDeleteMutationKey(pluginInstanceId);
  const swrFn = getPluginDeleteMutationFetcher(pluginInstanceId);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Change the active state of a plugin. When activated, the plugin will
install itself and become available for use. When deactivated, This will
uninstall the plugin but keep its data and config for reactivation.

 */
export const pluginSetActiveState = (
  pluginInstanceId: string,
  pluginSetActiveStateBody: PluginSetActiveStateBody,
) => {
  return fetcher<PluginGetOKResponse>({
    url: `/plugins/${pluginInstanceId}/active`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: pluginSetActiveStateBody,
  });
};

export const getPluginSetActiveStateMutationFetcher = (
  pluginInstanceId: string,
) => {
  return (
    _: Key,
    { arg }: { arg: PluginSetActiveStateBody },
  ): Promise<PluginGetOKResponse> => {
    return pluginSetActiveState(pluginInstanceId, arg);
  };
};
export const getPluginSetActiveStateMutationKey = (pluginInstanceId: string) =>
  [`/plugins/${pluginInstanceId}/active`] as const;

export type PluginSetActiveStateMutationResult = NonNullable<
  Awaited<ReturnType<typeof pluginSetActiveState>>
>;
export type PluginSetActiveStateMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const usePluginSetActiveState = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  pluginInstanceId: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof pluginSetActiveState>>,
      TError,
      Key,
      PluginSetActiveStateBody,
      Awaited<ReturnType<typeof pluginSetActiveState>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getPluginSetActiveStateMutationKey(pluginInstanceId);
  const swrFn = getPluginSetActiveStateMutationFetcher(pluginInstanceId);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Stream the logs for the specified plugin. If the plugin is running, this
endpoint will stream live logs after the existing logs have been sent.

 */
export const pluginGetLogs = (pluginInstanceId: string) => {
  return fetcher<PluginGetLogsOKResponse>({
    url: `/plugins/${pluginInstanceId}/logs`,
    method: "GET",
  });
};

export const getPluginGetLogsKey = (pluginInstanceId: string) =>
  [`/plugins/${pluginInstanceId}/logs`] as const;

export type PluginGetLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof pluginGetLogs>>
>;
export type PluginGetLogsQueryError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const usePluginGetLogs = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  pluginInstanceId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof pluginGetLogs>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!pluginInstanceId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getPluginGetLogsKey(pluginInstanceId) : null));
  const swrFn = () => pluginGetLogs(pluginInstanceId);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Cycles the static bearer token for an external plugin and returns the
newly generated token. This operation is only valid for external
plugins. Supervised plugins cycle their connection token automatically.

 */
export const pluginCycleToken = (pluginInstanceId: string) => {
  return fetcher<PluginCycleTokenOKResponse>({
    url: `/plugins/${pluginInstanceId}/token`,
    method: "POST",
  });
};

export const getPluginCycleTokenMutationFetcher = (
  pluginInstanceId: string,
) => {
  return (
    _: Key,
    __: { arg: Arguments },
  ): Promise<PluginCycleTokenOKResponse> => {
    return pluginCycleToken(pluginInstanceId);
  };
};
export const getPluginCycleTokenMutationKey = (pluginInstanceId: string) =>
  [`/plugins/${pluginInstanceId}/token`] as const;

export type PluginCycleTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof pluginCycleToken>>
>;
export type PluginCycleTokenMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const usePluginCycleToken = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  pluginInstanceId: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof pluginCycleToken>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof pluginCycleToken>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getPluginCycleTokenMutationKey(pluginInstanceId);
  const swrFn = getPluginCycleTokenMutationFetcher(pluginInstanceId);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Update the manifest for a plugin. This is used for development of plugins
where the manifest may change frequently and it's useful to be able to
update it without re-uploading the entire plugin bundle.

This only works for External plugins that were created by uploading a 
manifest directly. It does not work for Supervised plugins.

 */
export const pluginUpdateManifest = (
  pluginInstanceId: string,
  pluginUpdateManifestBody: PluginUpdateManifestBody,
) => {
  return fetcher<PluginGetOKResponse>({
    url: `/plugins/${pluginInstanceId}/manifest`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: pluginUpdateManifestBody,
  });
};

export const getPluginUpdateManifestMutationFetcher = (
  pluginInstanceId: string,
) => {
  return (
    _: Key,
    { arg }: { arg: PluginUpdateManifestBody },
  ): Promise<PluginGetOKResponse> => {
    return pluginUpdateManifest(pluginInstanceId, arg);
  };
};
export const getPluginUpdateManifestMutationKey = (pluginInstanceId: string) =>
  [`/plugins/${pluginInstanceId}/manifest`] as const;

export type PluginUpdateManifestMutationResult = NonNullable<
  Awaited<ReturnType<typeof pluginUpdateManifest>>
>;
export type PluginUpdateManifestMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const usePluginUpdateManifest = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  pluginInstanceId: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof pluginUpdateManifest>>,
      TError,
      Key,
      PluginUpdateManifestBody,
      Awaited<ReturnType<typeof pluginUpdateManifest>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getPluginUpdateManifestMutationKey(pluginInstanceId);
  const swrFn = getPluginUpdateManifestMutationFetcher(pluginInstanceId);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Replace the package archive for a supervised plugin installation.

The uploaded package manifest must have the same plugin ID as the
currently installed plugin. If the plugin is active, it is restarted
using the new package. If inactive, the package is replaced without
changing active state.

 */
export const pluginUpdatePackage = (
  pluginInstanceId: string,
  pluginUpdatePackageBody: PluginUpdatePackageBody,
) => {
  return fetcher<PluginGetOKResponse>({
    url: `/plugins/${pluginInstanceId}/package`,
    method: "PATCH",
    headers: { "Content-Type": "application/zip" },
    data: pluginUpdatePackageBody,
  });
};

export const getPluginUpdatePackageMutationFetcher = (
  pluginInstanceId: string,
) => {
  return (
    _: Key,
    { arg }: { arg: PluginUpdatePackageBody },
  ): Promise<PluginGetOKResponse> => {
    return pluginUpdatePackage(pluginInstanceId, arg);
  };
};
export const getPluginUpdatePackageMutationKey = (pluginInstanceId: string) =>
  [`/plugins/${pluginInstanceId}/package`] as const;

export type PluginUpdatePackageMutationResult = NonNullable<
  Awaited<ReturnType<typeof pluginUpdatePackage>>
>;
export type PluginUpdatePackageMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const usePluginUpdatePackage = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  pluginInstanceId: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof pluginUpdatePackage>>,
      TError,
      Key,
      PluginUpdatePackageBody,
      Awaited<ReturnType<typeof pluginUpdatePackage>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getPluginUpdatePackageMutationKey(pluginInstanceId);
  const swrFn = getPluginUpdatePackageMutationFetcher(pluginInstanceId);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Returns the configuration schema for a plugin as defined in its manifest
file. The schema should be used to render a configuration form for the
plugin in the client so that administrators can configure the plugin.

 */
export const pluginGetConfigurationSchema = (pluginInstanceId: string) => {
  return fetcher<PluginGetConfigurationSchemaOKResponse>({
    url: `/plugins/${pluginInstanceId}/configuration-schema`,
    method: "GET",
  });
};

export const getPluginGetConfigurationSchemaKey = (pluginInstanceId: string) =>
  [`/plugins/${pluginInstanceId}/configuration-schema`] as const;

export type PluginGetConfigurationSchemaQueryResult = NonNullable<
  Awaited<ReturnType<typeof pluginGetConfigurationSchema>>
>;
export type PluginGetConfigurationSchemaQueryError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const usePluginGetConfigurationSchema = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  pluginInstanceId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof pluginGetConfigurationSchema>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!pluginInstanceId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getPluginGetConfigurationSchemaKey(pluginInstanceId) : null);
  const swrFn = () => pluginGetConfigurationSchema(pluginInstanceId);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get the current configuration values for a plugin. The shape of the
object is defined by the plugin's manifest and should be used to render
the current configuration state in the client, using the layout driven
by the result of `PluginGetConfigurationSchema` to build a form-like UI.

 */
export const pluginGetConfiguration = (pluginInstanceId: string) => {
  return fetcher<PluginGetConfigurationOKResponse>({
    url: `/plugins/${pluginInstanceId}/configuration`,
    method: "GET",
  });
};

export const getPluginGetConfigurationKey = (pluginInstanceId: string) =>
  [`/plugins/${pluginInstanceId}/configuration`] as const;

export type PluginGetConfigurationQueryResult = NonNullable<
  Awaited<ReturnType<typeof pluginGetConfiguration>>
>;
export type PluginGetConfigurationQueryError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const usePluginGetConfiguration = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  pluginInstanceId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof pluginGetConfiguration>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!pluginInstanceId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getPluginGetConfigurationKey(pluginInstanceId) : null));
  const swrFn = () => pluginGetConfiguration(pluginInstanceId);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Update the configuration for a plugin. Each plugin defines its own set
of configuration parameters in its manifest and this endpoint accepts
any object validated against that schema. When a valid configuration is
received, it is sent to the plugin via RPC and the plugin is expected to
apply the new configuration to itself internally.

 */
export const pluginUpdateConfiguration = (
  pluginInstanceId: string,
  pluginUpdateConfigurationBody: PluginUpdateConfigurationBody,
) => {
  return fetcher<PluginGetConfigurationOKResponse>({
    url: `/plugins/${pluginInstanceId}/configuration`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: pluginUpdateConfigurationBody,
  });
};

export const getPluginUpdateConfigurationMutationFetcher = (
  pluginInstanceId: string,
) => {
  return (
    _: Key,
    { arg }: { arg: PluginUpdateConfigurationBody },
  ): Promise<PluginGetConfigurationOKResponse> => {
    return pluginUpdateConfiguration(pluginInstanceId, arg);
  };
};
export const getPluginUpdateConfigurationMutationKey = (
  pluginInstanceId: string,
) => [`/plugins/${pluginInstanceId}/configuration`] as const;

export type PluginUpdateConfigurationMutationResult = NonNullable<
  Awaited<ReturnType<typeof pluginUpdateConfiguration>>
>;
export type PluginUpdateConfigurationMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const usePluginUpdateConfiguration = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  pluginInstanceId: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof pluginUpdateConfiguration>>,
      TError,
      Key,
      PluginUpdateConfigurationBody,
      Awaited<ReturnType<typeof pluginUpdateConfiguration>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getPluginUpdateConfigurationMutationKey(pluginInstanceId);
  const swrFn = getPluginUpdateConfigurationMutationFetcher(pluginInstanceId);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
