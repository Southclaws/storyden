/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.26.2-canary
 */
import useSwr from "swr";
import type { Arguments, Key, SWRConfiguration } from "swr";
import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import { fetcher } from "../client";
import type {
  InternalServerErrorResponse,
  NotFoundResponse,
  NotModifiedResponse,
  ThreadCreateBody,
  ThreadCreateOKResponse,
  ThreadGetParams,
  ThreadGetResponse,
  ThreadListOKResponse,
  ThreadListParams,
  ThreadUpdateBody,
  ThreadUpdateOKResponse,
  UnauthorisedResponse,
} from "../openapi-schema";

/**
 * Create a new thread within the specified category.
 */
export const threadCreate = (threadCreateBody: ThreadCreateBody) => {
  return fetcher<ThreadCreateOKResponse>({
    url: `/threads`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: threadCreateBody,
  });
};

export const getThreadCreateMutationFetcher = () => {
  return (
    _: Key,
    { arg }: { arg: ThreadCreateBody },
  ): Promise<ThreadCreateOKResponse> => {
    return threadCreate(arg);
  };
};
export const getThreadCreateMutationKey = () => [`/threads`] as const;

export type ThreadCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof threadCreate>>
>;
export type ThreadCreateMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useThreadCreate = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof threadCreate>>,
    TError,
    Key,
    ThreadCreateBody,
    Awaited<ReturnType<typeof threadCreate>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getThreadCreateMutationKey();
  const swrFn = getThreadCreateMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get a list of all threads.
 */
export const threadList = (params?: ThreadListParams) => {
  return fetcher<ThreadListOKResponse>({
    url: `/threads`,
    method: "GET",
    params,
  });
};

export const getThreadListKey = (params?: ThreadListParams) =>
  [`/threads`, ...(params ? [params] : [])] as const;

export type ThreadListQueryResult = NonNullable<
  Awaited<ReturnType<typeof threadList>>
>;
export type ThreadListQueryError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useThreadList = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  params?: ThreadListParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof threadList>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getThreadListKey(params) : null));
  const swrFn = () => threadList(params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get information about a thread such as its title, author, when it was
created as well as a list of the posts within the thread.

 * @summary Get information about a thread and the posts within the thread.
 */
export const threadGet = (threadMark: string, params?: ThreadGetParams) => {
  return fetcher<ThreadGetResponse>({
    url: `/threads/${threadMark}`,
    method: "GET",
    params,
  });
};

export const getThreadGetKey = (threadMark: string, params?: ThreadGetParams) =>
  [`/threads/${threadMark}`, ...(params ? [params] : [])] as const;

export type ThreadGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof threadGet>>
>;
export type ThreadGetQueryError =
  | NotModifiedResponse
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

/**
 * @summary Get information about a thread and the posts within the thread.
 */
export const useThreadGet = <
  TError =
    | NotModifiedResponse
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  threadMark: string,
  params?: ThreadGetParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof threadGet>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!threadMark;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getThreadGetKey(threadMark, params) : null));
  const swrFn = () => threadGet(threadMark, params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Publish changes to a thread.
 */
export const threadUpdate = (
  threadMark: string,
  threadUpdateBody: ThreadUpdateBody,
) => {
  return fetcher<ThreadUpdateOKResponse>({
    url: `/threads/${threadMark}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: threadUpdateBody,
  });
};

export const getThreadUpdateMutationFetcher = (threadMark: string) => {
  return (
    _: Key,
    { arg }: { arg: ThreadUpdateBody },
  ): Promise<ThreadUpdateOKResponse> => {
    return threadUpdate(threadMark, arg);
  };
};
export const getThreadUpdateMutationKey = (threadMark: string) =>
  [`/threads/${threadMark}`] as const;

export type ThreadUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof threadUpdate>>
>;
export type ThreadUpdateMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useThreadUpdate = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  threadMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof threadUpdate>>,
      TError,
      Key,
      ThreadUpdateBody,
      Awaited<ReturnType<typeof threadUpdate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getThreadUpdateMutationKey(threadMark);
  const swrFn = getThreadUpdateMutationFetcher(threadMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Archive a thread using soft-delete.
 */
export const threadDelete = (threadMark: string) => {
  return fetcher<void>({ url: `/threads/${threadMark}`, method: "DELETE" });
};

export const getThreadDeleteMutationFetcher = (threadMark: string) => {
  return (_: Key, __: { arg: Arguments }): Promise<void> => {
    return threadDelete(threadMark);
  };
};
export const getThreadDeleteMutationKey = (threadMark: string) =>
  [`/threads/${threadMark}`] as const;

export type ThreadDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof threadDelete>>
>;
export type ThreadDeleteMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useThreadDelete = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  threadMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof threadDelete>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof threadDelete>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getThreadDeleteMutationKey(threadMark);
  const swrFn = getThreadDeleteMutationFetcher(threadMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
