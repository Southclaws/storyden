/**
 * Generated by orval v6.31.0 🍺
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: rolling
 */
import useSwr from "swr";
import type { Key, SWRConfiguration } from "swr";
import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import { fetcher } from "../client";
import type {
  AuthEmailBody,
  AuthEmailPasswordBody,
  AuthEmailVerifyBody,
  AuthPasswordBody,
  AuthPasswordCreateBody,
  AuthPasswordUpdateBody,
  AuthProviderListOKResponse,
  AuthSuccessOKResponse,
  BadRequestResponse,
  InternalServerErrorResponse,
  NotFoundResponse,
  OAuthProviderCallbackBody,
  PhoneRequestCodeBody,
  PhoneSubmitCodeBody,
  UnauthorisedResponse,
  WebAuthnGetAssertionOKResponse,
  WebAuthnMakeAssertionBody,
  WebAuthnMakeCredentialBody,
  WebAuthnRequestCredentialOKResponse,
} from "../openapi-schema";

/**
 * Retrieve a list of authentication providers. Storyden supports a few
ways to authenticate, from simple passwords to OAuth and WebAuthn. This
endpoint tells a client which auth capabilities are enabled.

 */
export const authProviderList = () => {
  return fetcher<AuthProviderListOKResponse>({ url: `/auth`, method: "GET" });
};

export const getAuthProviderListKey = () => [`/auth`] as const;

export type AuthProviderListQueryResult = NonNullable<
  Awaited<ReturnType<typeof authProviderList>>
>;
export type AuthProviderListQueryError =
  | BadRequestResponse
  | InternalServerErrorResponse;

export const useAuthProviderList = <
  TError = BadRequestResponse | InternalServerErrorResponse,
>(options?: {
  swr?: SWRConfiguration<
    Awaited<ReturnType<typeof authProviderList>>,
    TError
  > & { swrKey?: Key; enabled?: boolean };
}) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getAuthProviderListKey() : null));
  const swrFn = () => authProviderList();

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Register a new account with a username and password.
 */
export const authPasswordSignup = (authPasswordBody: AuthPasswordBody) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/password/signup`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authPasswordBody,
  });
};

export const getAuthPasswordSignupMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: AuthPasswordBody },
  ): Promise<AuthSuccessOKResponse> => {
    return authPasswordSignup(arg);
  };
};
export const getAuthPasswordSignupMutationKey = () =>
  `/auth/password/signup` as const;

export type AuthPasswordSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasswordSignup>>
>;
export type AuthPasswordSignupMutationError =
  | BadRequestResponse
  | InternalServerErrorResponse;

export const useAuthPasswordSignup = <
  TError = BadRequestResponse | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof authPasswordSignup>>,
    TError,
    string,
    AuthPasswordBody,
    Awaited<ReturnType<typeof authPasswordSignup>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getAuthPasswordSignupMutationKey();
  const swrFn = getAuthPasswordSignupMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Sign in to an existing account with a username and password.
 */
export const authPasswordSignin = (authPasswordBody: AuthPasswordBody) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/password/signin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authPasswordBody,
  });
};

export const getAuthPasswordSigninMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: AuthPasswordBody },
  ): Promise<AuthSuccessOKResponse> => {
    return authPasswordSignin(arg);
  };
};
export const getAuthPasswordSigninMutationKey = () =>
  `/auth/password/signin` as const;

export type AuthPasswordSigninMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasswordSignin>>
>;
export type AuthPasswordSigninMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useAuthPasswordSignin = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof authPasswordSignin>>,
    TError,
    string,
    AuthPasswordBody,
    Awaited<ReturnType<typeof authPasswordSignin>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getAuthPasswordSigninMutationKey();
  const swrFn = getAuthPasswordSigninMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Given the requesting account does not have a password authentication,
add a password authentication method to it with the given password.

 */
export const authPasswordCreate = (
  authPasswordCreateBody: AuthPasswordCreateBody,
) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/password`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authPasswordCreateBody,
  });
};

export const getAuthPasswordCreateMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: AuthPasswordCreateBody },
  ): Promise<AuthSuccessOKResponse> => {
    return authPasswordCreate(arg);
  };
};
export const getAuthPasswordCreateMutationKey = () => `/auth/password` as const;

export type AuthPasswordCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasswordCreate>>
>;
export type AuthPasswordCreateMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useAuthPasswordCreate = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof authPasswordCreate>>,
    TError,
    string,
    AuthPasswordCreateBody,
    Awaited<ReturnType<typeof authPasswordCreate>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getAuthPasswordCreateMutationKey();
  const swrFn = getAuthPasswordCreateMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Given the requesting account has a password authentication, update the
password on file.

 */
export const authPasswordUpdate = (
  authPasswordUpdateBody: AuthPasswordUpdateBody,
) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/password`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: authPasswordUpdateBody,
  });
};

export const getAuthPasswordUpdateMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: AuthPasswordUpdateBody },
  ): Promise<AuthSuccessOKResponse> => {
    return authPasswordUpdate(arg);
  };
};
export const getAuthPasswordUpdateMutationKey = () => `/auth/password` as const;

export type AuthPasswordUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasswordUpdate>>
>;
export type AuthPasswordUpdateMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useAuthPasswordUpdate = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof authPasswordUpdate>>,
    TError,
    string,
    AuthPasswordUpdateBody,
    Awaited<ReturnType<typeof authPasswordUpdate>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getAuthPasswordUpdateMutationKey();
  const swrFn = getAuthPasswordUpdateMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Register a new account with a email and password.
 */
export const authEmailPasswordSignup = (
  authEmailPasswordBody: AuthEmailPasswordBody,
) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/email-password/signup`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authEmailPasswordBody,
  });
};

export const getAuthEmailPasswordSignupMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: AuthEmailPasswordBody },
  ): Promise<AuthSuccessOKResponse> => {
    return authEmailPasswordSignup(arg);
  };
};
export const getAuthEmailPasswordSignupMutationKey = () =>
  `/auth/email-password/signup` as const;

export type AuthEmailPasswordSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof authEmailPasswordSignup>>
>;
export type AuthEmailPasswordSignupMutationError =
  | BadRequestResponse
  | InternalServerErrorResponse;

export const useAuthEmailPasswordSignup = <
  TError = BadRequestResponse | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof authEmailPasswordSignup>>,
    TError,
    string,
    AuthEmailPasswordBody,
    Awaited<ReturnType<typeof authEmailPasswordSignup>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getAuthEmailPasswordSignupMutationKey();
  const swrFn = getAuthEmailPasswordSignupMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Sign in to an existing account with a email and password.
 */
export const authEmailPasswordSignin = (
  authEmailPasswordBody: AuthEmailPasswordBody,
) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/email-password/signin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authEmailPasswordBody,
  });
};

export const getAuthEmailPasswordSigninMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: AuthEmailPasswordBody },
  ): Promise<AuthSuccessOKResponse> => {
    return authEmailPasswordSignin(arg);
  };
};
export const getAuthEmailPasswordSigninMutationKey = () =>
  `/auth/email-password/signin` as const;

export type AuthEmailPasswordSigninMutationResult = NonNullable<
  Awaited<ReturnType<typeof authEmailPasswordSignin>>
>;
export type AuthEmailPasswordSigninMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useAuthEmailPasswordSignin = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof authEmailPasswordSignin>>,
    TError,
    string,
    AuthEmailPasswordBody,
    Awaited<ReturnType<typeof authEmailPasswordSignin>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getAuthEmailPasswordSigninMutationKey();
  const swrFn = getAuthEmailPasswordSigninMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Register a new account with an email and optional password. The password
requirement is dependent on how the instance is configured for account
authentication with email addresses (password vs magic link.)

When the email address has not been registered, this endpoint will send
a verification email however it will also return a session cookie to
facilitate pre-verification usage of the platform. If the email address
already exists, no session cookie will be returned in order to prevent
arbitrary account control by a malicious actor. In this case, the email
will be sent again with the same OTP for the case where the user has
cleared their cookies or switched device but hasn't yet verified due to
missing the email or a delivery failure. In this sense, the endpoint can
act as a "resend verification email" operation as well as registration.

In the first case, a 200 response is provided with the session cookie,
in the second case, a 422 response is provided without a session cookie.

Given that this is an unauthenticated endpoint that triggers an email to
be sent to any public address, it MUST be heavily rate limited.

 */
export const authEmailSignup = (authEmailBody: AuthEmailBody) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/email/signup`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authEmailBody,
  });
};

export const getAuthEmailSignupMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: AuthEmailBody },
  ): Promise<AuthSuccessOKResponse> => {
    return authEmailSignup(arg);
  };
};
export const getAuthEmailSignupMutationKey = () =>
  `/auth/email/signup` as const;

export type AuthEmailSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof authEmailSignup>>
>;
export type AuthEmailSignupMutationError =
  | BadRequestResponse
  | void
  | InternalServerErrorResponse;

export const useAuthEmailSignup = <
  TError = BadRequestResponse | void | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof authEmailSignup>>,
    TError,
    string,
    AuthEmailBody,
    Awaited<ReturnType<typeof authEmailSignup>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getAuthEmailSignupMutationKey();
  const swrFn = getAuthEmailSignupMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Sign in to an existing account with an email and optional password. The
behaviour of this endpoint depends on how the instance is configured. If
email+password is the preferred method, a cookie is returned on success
but if magic links are preferred, the endpoint will start the code flow.

 */
export const authEmailSignin = (authEmailBody: AuthEmailBody) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/email/signin`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authEmailBody,
  });
};

export const getAuthEmailSigninMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: AuthEmailBody },
  ): Promise<AuthSuccessOKResponse> => {
    return authEmailSignin(arg);
  };
};
export const getAuthEmailSigninMutationKey = () =>
  `/auth/email/signin` as const;

export type AuthEmailSigninMutationResult = NonNullable<
  Awaited<ReturnType<typeof authEmailSignin>>
>;
export type AuthEmailSigninMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useAuthEmailSignin = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof authEmailSignin>>,
    TError,
    string,
    AuthEmailBody,
    Awaited<ReturnType<typeof authEmailSignin>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getAuthEmailSigninMutationKey();
  const swrFn = getAuthEmailSigninMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Verify an email address using a token that was emailed to one of the
account's email addresses either set via sign up or added later.

 */
export const authEmailVerify = (authEmailVerifyBody: AuthEmailVerifyBody) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/email/verify`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: authEmailVerifyBody,
  });
};

export const getAuthEmailVerifyMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: AuthEmailVerifyBody },
  ): Promise<AuthSuccessOKResponse> => {
    return authEmailVerify(arg);
  };
};
export const getAuthEmailVerifyMutationKey = () =>
  `/auth/email/verify` as const;

export type AuthEmailVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof authEmailVerify>>
>;
export type AuthEmailVerifyMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useAuthEmailVerify = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof authEmailVerify>>,
    TError,
    string,
    AuthEmailVerifyBody,
    Awaited<ReturnType<typeof authEmailVerify>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getAuthEmailVerifyMutationKey();
  const swrFn = getAuthEmailVerifyMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * OAuth2 callback.
 */
export const oAuthProviderCallback = (
  oauthProvider: string,
  oAuthProviderCallbackBody: OAuthProviderCallbackBody,
) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/oauth/${oauthProvider}/callback`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: oAuthProviderCallbackBody,
  });
};

export const getOAuthProviderCallbackMutationFetcher = (
  oauthProvider: string,
) => {
  return (
    _: string,
    { arg }: { arg: OAuthProviderCallbackBody },
  ): Promise<AuthSuccessOKResponse> => {
    return oAuthProviderCallback(oauthProvider, arg);
  };
};
export const getOAuthProviderCallbackMutationKey = (oauthProvider: string) =>
  `/auth/oauth/${oauthProvider}/callback` as const;

export type OAuthProviderCallbackMutationResult = NonNullable<
  Awaited<ReturnType<typeof oAuthProviderCallback>>
>;
export type OAuthProviderCallbackMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useOAuthProviderCallback = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  oauthProvider: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof oAuthProviderCallback>>,
      TError,
      string,
      OAuthProviderCallbackBody,
      Awaited<ReturnType<typeof oAuthProviderCallback>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getOAuthProviderCallbackMutationKey(oauthProvider);
  const swrFn = getOAuthProviderCallbackMutationFetcher(oauthProvider);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Start the WebAuthn registration process by requesting a credential.

 */
export const webAuthnRequestCredential = (accountHandle: string) => {
  return fetcher<WebAuthnRequestCredentialOKResponse>({
    url: `/auth/webauthn/make/${accountHandle}`,
    method: "GET",
  });
};

export const getWebAuthnRequestCredentialKey = (accountHandle: string) =>
  [`/auth/webauthn/make/${accountHandle}`] as const;

export type WebAuthnRequestCredentialQueryResult = NonNullable<
  Awaited<ReturnType<typeof webAuthnRequestCredential>>
>;
export type WebAuthnRequestCredentialQueryError =
  | BadRequestResponse
  | InternalServerErrorResponse;

export const useWebAuthnRequestCredential = <
  TError = BadRequestResponse | InternalServerErrorResponse,
>(
  accountHandle: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof webAuthnRequestCredential>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountHandle;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getWebAuthnRequestCredentialKey(accountHandle) : null));
  const swrFn = () => webAuthnRequestCredential(accountHandle);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Complete WebAuthn registration by creating a new credential.
 */
export const webAuthnMakeCredential = (
  webAuthnMakeCredentialBody: WebAuthnMakeCredentialBody,
) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/webauthn/make`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: webAuthnMakeCredentialBody,
  });
};

export const getWebAuthnMakeCredentialMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: WebAuthnMakeCredentialBody },
  ): Promise<AuthSuccessOKResponse> => {
    return webAuthnMakeCredential(arg);
  };
};
export const getWebAuthnMakeCredentialMutationKey = () =>
  `/auth/webauthn/make` as const;

export type WebAuthnMakeCredentialMutationResult = NonNullable<
  Awaited<ReturnType<typeof webAuthnMakeCredential>>
>;
export type WebAuthnMakeCredentialMutationError =
  | BadRequestResponse
  | InternalServerErrorResponse;

export const useWebAuthnMakeCredential = <
  TError = BadRequestResponse | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof webAuthnMakeCredential>>,
    TError,
    string,
    WebAuthnMakeCredentialBody,
    Awaited<ReturnType<typeof webAuthnMakeCredential>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getWebAuthnMakeCredentialMutationKey();
  const swrFn = getWebAuthnMakeCredentialMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Start the WebAuthn assertion for an existing account.
 */
export const webAuthnGetAssertion = (accountHandle: string) => {
  return fetcher<WebAuthnGetAssertionOKResponse>({
    url: `/auth/webauthn/assert/${accountHandle}`,
    method: "GET",
  });
};

export const getWebAuthnGetAssertionKey = (accountHandle: string) =>
  [`/auth/webauthn/assert/${accountHandle}`] as const;

export type WebAuthnGetAssertionQueryResult = NonNullable<
  Awaited<ReturnType<typeof webAuthnGetAssertion>>
>;
export type WebAuthnGetAssertionQueryError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useWebAuthnGetAssertion = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  accountHandle: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof webAuthnGetAssertion>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountHandle;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getWebAuthnGetAssertionKey(accountHandle) : null));
  const swrFn = () => webAuthnGetAssertion(accountHandle);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Complete the credential assertion and sign in to an account.
 */
export const webAuthnMakeAssertion = (
  webAuthnMakeAssertionBody: WebAuthnMakeAssertionBody,
) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/webauthn/assert`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: webAuthnMakeAssertionBody,
  });
};

export const getWebAuthnMakeAssertionMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: WebAuthnMakeAssertionBody },
  ): Promise<AuthSuccessOKResponse> => {
    return webAuthnMakeAssertion(arg);
  };
};
export const getWebAuthnMakeAssertionMutationKey = () =>
  `/auth/webauthn/assert` as const;

export type WebAuthnMakeAssertionMutationResult = NonNullable<
  Awaited<ReturnType<typeof webAuthnMakeAssertion>>
>;
export type WebAuthnMakeAssertionMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useWebAuthnMakeAssertion = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof webAuthnMakeAssertion>>,
    TError,
    string,
    WebAuthnMakeAssertionBody,
    Awaited<ReturnType<typeof webAuthnMakeAssertion>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getWebAuthnMakeAssertionMutationKey();
  const swrFn = getWebAuthnMakeAssertionMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Start the authentication flow with a phone number. The handler will send
a one-time code to the provided phone number which must then be sent to
the other phone endpoint to verify the number and validate the account.

 */
export const phoneRequestCode = (
  phoneRequestCodeBody: PhoneRequestCodeBody,
) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/phone`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: phoneRequestCodeBody,
  });
};

export const getPhoneRequestCodeMutationFetcher = () => {
  return (
    _: string,
    { arg }: { arg: PhoneRequestCodeBody },
  ): Promise<AuthSuccessOKResponse> => {
    return phoneRequestCode(arg);
  };
};
export const getPhoneRequestCodeMutationKey = () => `/auth/phone` as const;

export type PhoneRequestCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof phoneRequestCode>>
>;
export type PhoneRequestCodeMutationError =
  | BadRequestResponse
  | InternalServerErrorResponse;

export const usePhoneRequestCode = <
  TError = BadRequestResponse | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof phoneRequestCode>>,
    TError,
    string,
    PhoneRequestCodeBody,
    Awaited<ReturnType<typeof phoneRequestCode>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getPhoneRequestCodeMutationKey();
  const swrFn = getPhoneRequestCodeMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Complete the phone number authentication flow by submitting the one-time
code that was sent to the user's phone.

 */
export const phoneSubmitCode = (
  accountHandle: string,
  phoneSubmitCodeBody: PhoneSubmitCodeBody,
) => {
  return fetcher<AuthSuccessOKResponse>({
    url: `/auth/phone/${accountHandle}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: phoneSubmitCodeBody,
  });
};

export const getPhoneSubmitCodeMutationFetcher = (accountHandle: string) => {
  return (
    _: string,
    { arg }: { arg: PhoneSubmitCodeBody },
  ): Promise<AuthSuccessOKResponse> => {
    return phoneSubmitCode(accountHandle, arg);
  };
};
export const getPhoneSubmitCodeMutationKey = (accountHandle: string) =>
  `/auth/phone/${accountHandle}` as const;

export type PhoneSubmitCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof phoneSubmitCode>>
>;
export type PhoneSubmitCodeMutationError =
  | BadRequestResponse
  | InternalServerErrorResponse;

export const usePhoneSubmitCode = <
  TError = BadRequestResponse | InternalServerErrorResponse,
>(
  accountHandle: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof phoneSubmitCode>>,
      TError,
      string,
      PhoneSubmitCodeBody,
      Awaited<ReturnType<typeof phoneSubmitCode>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getPhoneSubmitCodeMutationKey(accountHandle);
  const swrFn = getPhoneSubmitCodeMutationFetcher(accountHandle);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Remove cookies from requesting client.
 */
export const authProviderLogout = () => {
  return fetcher<void>({ url: `/auth/logout`, method: "GET" });
};

export const getAuthProviderLogoutKey = () => [`/auth/logout`] as const;

export type AuthProviderLogoutQueryResult = NonNullable<
  Awaited<ReturnType<typeof authProviderLogout>>
>;
export type AuthProviderLogoutQueryError =
  | BadRequestResponse
  | InternalServerErrorResponse;

export const useAuthProviderLogout = <
  TError = BadRequestResponse | InternalServerErrorResponse,
>(options?: {
  swr?: SWRConfiguration<
    Awaited<ReturnType<typeof authProviderLogout>>,
    TError
  > & { swrKey?: Key; enabled?: boolean };
}) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getAuthProviderLogoutKey() : null));
  const swrFn = () => authProviderLogout();

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
