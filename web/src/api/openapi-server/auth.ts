/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.26.3-canary
 */
import type {
  AccessKeyCreateBody,
  AccessKeyCreateOKResponse,
  AccessKeyListOKResponse,
  AuthEmailBody,
  AuthEmailPasswordBody,
  AuthEmailPasswordResetBody,
  AuthEmailPasswordSignupParams,
  AuthEmailSignupParams,
  AuthEmailVerifyBody,
  AuthPasswordBody,
  AuthPasswordCreateBody,
  AuthPasswordResetBody,
  AuthPasswordSignupParams,
  AuthPasswordUpdateBody,
  AuthProviderListOKResponse,
  AuthProviderLogoutParams,
  AuthSuccessOKResponse,
  NoContentResponse,
  OAuthProviderCallbackBody,
  PhoneRequestCodeBody,
  PhoneRequestCodeParams,
  PhoneSubmitCodeBody,
  WebAuthnGetAssertionOKResponse,
  WebAuthnMakeAssertionBody,
  WebAuthnMakeCredentialBody,
  WebAuthnMakeCredentialParams,
  WebAuthnRequestCredentialOKResponse,
} from "../openapi-schema";
import { fetcher } from "../server";

/**
 * Retrieve a list of authentication providers. Storyden supports a few
ways to authenticate, from simple passwords to OAuth and WebAuthn. This
endpoint tells a client which auth capabilities are enabled.

 */
export type authProviderListResponse = {
  data: AuthProviderListOKResponse;
  status: number;
};

export const getAuthProviderListUrl = () => {
  return `/auth`;
};

export const authProviderList = async (
  options?: RequestInit,
): Promise<authProviderListResponse> => {
  return fetcher<Promise<authProviderListResponse>>(getAuthProviderListUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * Register a new account with a username and password.
 */
export type authPasswordSignupResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getAuthPasswordSignupUrl = (params?: AuthPasswordSignupParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/auth/password/signup?${normalizedParams.toString()}`
    : `/auth/password/signup`;
};

export const authPasswordSignup = async (
  authPasswordBody: AuthPasswordBody,
  params?: AuthPasswordSignupParams,
  options?: RequestInit,
): Promise<authPasswordSignupResponse> => {
  return fetcher<Promise<authPasswordSignupResponse>>(
    getAuthPasswordSignupUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(authPasswordBody),
    },
  );
};

/**
 * Sign in to an existing account with a username and password.
 */
export type authPasswordSigninResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getAuthPasswordSigninUrl = () => {
  return `/auth/password/signin`;
};

export const authPasswordSignin = async (
  authPasswordBody: AuthPasswordBody,
  options?: RequestInit,
): Promise<authPasswordSigninResponse> => {
  return fetcher<Promise<authPasswordSigninResponse>>(
    getAuthPasswordSigninUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(authPasswordBody),
    },
  );
};

/**
 * Given the requesting account does not have a password authentication,
add a password authentication method to it with the given password.

 */
export type authPasswordCreateResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getAuthPasswordCreateUrl = () => {
  return `/auth/password`;
};

export const authPasswordCreate = async (
  authPasswordCreateBody: AuthPasswordCreateBody,
  options?: RequestInit,
): Promise<authPasswordCreateResponse> => {
  return fetcher<Promise<authPasswordCreateResponse>>(
    getAuthPasswordCreateUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(authPasswordCreateBody),
    },
  );
};

/**
 * Given the requesting account has a password authentication, update the
password on file.

 */
export type authPasswordUpdateResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getAuthPasswordUpdateUrl = () => {
  return `/auth/password`;
};

export const authPasswordUpdate = async (
  authPasswordUpdateBody: AuthPasswordUpdateBody,
  options?: RequestInit,
): Promise<authPasswordUpdateResponse> => {
  return fetcher<Promise<authPasswordUpdateResponse>>(
    getAuthPasswordUpdateUrl(),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(authPasswordUpdateBody),
    },
  );
};

/**
 * Complete a password-reset flow using a token that was provided to the
member via a reset request operation such as `AuthEmailPasswordReset`.

 */
export type authPasswordResetResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getAuthPasswordResetUrl = () => {
  return `/auth/password/reset`;
};

export const authPasswordReset = async (
  authPasswordResetBody: AuthPasswordResetBody,
  options?: RequestInit,
): Promise<authPasswordResetResponse> => {
  return fetcher<Promise<authPasswordResetResponse>>(
    getAuthPasswordResetUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(authPasswordResetBody),
    },
  );
};

/**
 * Register a new account with a email and password.
 */
export type authEmailPasswordSignupResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getAuthEmailPasswordSignupUrl = (
  params?: AuthEmailPasswordSignupParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/auth/email-password/signup?${normalizedParams.toString()}`
    : `/auth/email-password/signup`;
};

export const authEmailPasswordSignup = async (
  authEmailPasswordBody: AuthEmailPasswordBody,
  params?: AuthEmailPasswordSignupParams,
  options?: RequestInit,
): Promise<authEmailPasswordSignupResponse> => {
  return fetcher<Promise<authEmailPasswordSignupResponse>>(
    getAuthEmailPasswordSignupUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(authEmailPasswordBody),
    },
  );
};

/**
 * Sign in to an existing account with a email and password.
 */
export type authEmailPasswordSigninResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getAuthEmailPasswordSigninUrl = () => {
  return `/auth/email-password/signin`;
};

export const authEmailPasswordSignin = async (
  authEmailPasswordBody: AuthEmailPasswordBody,
  options?: RequestInit,
): Promise<authEmailPasswordSigninResponse> => {
  return fetcher<Promise<authEmailPasswordSigninResponse>>(
    getAuthEmailPasswordSigninUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(authEmailPasswordBody),
    },
  );
};

/**
 * Request password reset email to be sent to the specified email address.

 */
export type authPasswordResetRequestEmailResponse = {
  data: void;
  status: number;
};

export const getAuthPasswordResetRequestEmailUrl = () => {
  return `/auth/email-password/reset`;
};

export const authPasswordResetRequestEmail = async (
  authEmailPasswordResetBody: AuthEmailPasswordResetBody,
  options?: RequestInit,
): Promise<authPasswordResetRequestEmailResponse> => {
  return fetcher<Promise<authPasswordResetRequestEmailResponse>>(
    getAuthPasswordResetRequestEmailUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(authEmailPasswordResetBody),
    },
  );
};

/**
 * Register a new account with an email and optional password. The password
requirement is dependent on how the instance is configured for account
authentication with email addresses (password vs magic link.)

When the email address has not been registered, this endpoint will send
a verification email however it will also return a session cookie to
facilitate pre-verification usage of the platform. If the email address
already exists, no session cookie will be returned in order to prevent
arbitrary account control by a malicious actor. In this case, the email
will be sent again with the same OTP for the case where the user has
cleared their cookies or switched device but hasn't yet verified due to
missing the email or a delivery failure. In this sense, the endpoint can
act as a "resend verification email" operation as well as registration.

In the first case, a 200 response is provided with the session cookie,
in the second case, a 422 response is provided without a session cookie.

Given that this is an unauthenticated endpoint that triggers an email to
be sent to any public address, it MUST be heavily rate limited.

 */
export type authEmailSignupResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getAuthEmailSignupUrl = (params?: AuthEmailSignupParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/auth/email/signup?${normalizedParams.toString()}`
    : `/auth/email/signup`;
};

export const authEmailSignup = async (
  authEmailBody: AuthEmailBody,
  params?: AuthEmailSignupParams,
  options?: RequestInit,
): Promise<authEmailSignupResponse> => {
  return fetcher<Promise<authEmailSignupResponse>>(
    getAuthEmailSignupUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(authEmailBody),
    },
  );
};

/**
 * Sign in to an existing account with an email and optional password. The
behaviour of this endpoint depends on how the instance is configured. If
email+password is the preferred method, a cookie is returned on success
but if magic links are preferred, the endpoint will start the code flow.

 */
export type authEmailSigninResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getAuthEmailSigninUrl = () => {
  return `/auth/email/signin`;
};

export const authEmailSignin = async (
  authEmailBody: AuthEmailBody,
  options?: RequestInit,
): Promise<authEmailSigninResponse> => {
  return fetcher<Promise<authEmailSigninResponse>>(getAuthEmailSigninUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(authEmailBody),
  });
};

/**
 * Verify an email address using a token that was emailed to one of the
account's email addresses either set via sign up or added later.

 */
export type authEmailVerifyResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getAuthEmailVerifyUrl = () => {
  return `/auth/email/verify`;
};

export const authEmailVerify = async (
  authEmailVerifyBody: AuthEmailVerifyBody,
  options?: RequestInit,
): Promise<authEmailVerifyResponse> => {
  return fetcher<Promise<authEmailVerifyResponse>>(getAuthEmailVerifyUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(authEmailVerifyBody),
  });
};

/**
 * OAuth2 callback.
 */
export type oAuthProviderCallbackResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getOAuthProviderCallbackUrl = (oauthProvider: string) => {
  return `/auth/oauth/${oauthProvider}/callback`;
};

export const oAuthProviderCallback = async (
  oauthProvider: string,
  oAuthProviderCallbackBody: OAuthProviderCallbackBody,
  options?: RequestInit,
): Promise<oAuthProviderCallbackResponse> => {
  return fetcher<Promise<oAuthProviderCallbackResponse>>(
    getOAuthProviderCallbackUrl(oauthProvider),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(oAuthProviderCallbackBody),
    },
  );
};

/**
 * Start the WebAuthn registration process by requesting a credential.

 */
export type webAuthnRequestCredentialResponse = {
  data: WebAuthnRequestCredentialOKResponse;
  status: number;
};

export const getWebAuthnRequestCredentialUrl = (accountHandle: string) => {
  return `/auth/webauthn/make/${accountHandle}`;
};

export const webAuthnRequestCredential = async (
  accountHandle: string,
  options?: RequestInit,
): Promise<webAuthnRequestCredentialResponse> => {
  return fetcher<Promise<webAuthnRequestCredentialResponse>>(
    getWebAuthnRequestCredentialUrl(accountHandle),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Complete WebAuthn registration by creating a new credential.
 */
export type webAuthnMakeCredentialResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getWebAuthnMakeCredentialUrl = (
  params?: WebAuthnMakeCredentialParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/auth/webauthn/make?${normalizedParams.toString()}`
    : `/auth/webauthn/make`;
};

export const webAuthnMakeCredential = async (
  webAuthnMakeCredentialBody: WebAuthnMakeCredentialBody,
  params?: WebAuthnMakeCredentialParams,
  options?: RequestInit,
): Promise<webAuthnMakeCredentialResponse> => {
  return fetcher<Promise<webAuthnMakeCredentialResponse>>(
    getWebAuthnMakeCredentialUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(webAuthnMakeCredentialBody),
    },
  );
};

/**
 * Start the WebAuthn assertion for an existing account.
 */
export type webAuthnGetAssertionResponse = {
  data: WebAuthnGetAssertionOKResponse;
  status: number;
};

export const getWebAuthnGetAssertionUrl = (accountHandle: string) => {
  return `/auth/webauthn/assert/${accountHandle}`;
};

export const webAuthnGetAssertion = async (
  accountHandle: string,
  options?: RequestInit,
): Promise<webAuthnGetAssertionResponse> => {
  return fetcher<Promise<webAuthnGetAssertionResponse>>(
    getWebAuthnGetAssertionUrl(accountHandle),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Complete the credential assertion and sign in to an account.
 */
export type webAuthnMakeAssertionResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getWebAuthnMakeAssertionUrl = () => {
  return `/auth/webauthn/assert`;
};

export const webAuthnMakeAssertion = async (
  webAuthnMakeAssertionBody: WebAuthnMakeAssertionBody,
  options?: RequestInit,
): Promise<webAuthnMakeAssertionResponse> => {
  return fetcher<Promise<webAuthnMakeAssertionResponse>>(
    getWebAuthnMakeAssertionUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(webAuthnMakeAssertionBody),
    },
  );
};

/**
 * Start the authentication flow with a phone number. The handler will send
a one-time code to the provided phone number which must then be sent to
the other phone endpoint to verify the number and validate the account.

 */
export type phoneRequestCodeResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getPhoneRequestCodeUrl = (params?: PhoneRequestCodeParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/auth/phone?${normalizedParams.toString()}`
    : `/auth/phone`;
};

export const phoneRequestCode = async (
  phoneRequestCodeBody: PhoneRequestCodeBody,
  params?: PhoneRequestCodeParams,
  options?: RequestInit,
): Promise<phoneRequestCodeResponse> => {
  return fetcher<Promise<phoneRequestCodeResponse>>(
    getPhoneRequestCodeUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(phoneRequestCodeBody),
    },
  );
};

/**
 * Complete the phone number authentication flow by submitting the one-time
code that was sent to the user's phone.

 */
export type phoneSubmitCodeResponse = {
  data: AuthSuccessOKResponse;
  status: number;
};

export const getPhoneSubmitCodeUrl = (accountHandle: string) => {
  return `/auth/phone/${accountHandle}`;
};

export const phoneSubmitCode = async (
  accountHandle: string,
  phoneSubmitCodeBody: PhoneSubmitCodeBody,
  options?: RequestInit,
): Promise<phoneSubmitCodeResponse> => {
  return fetcher<Promise<phoneSubmitCodeResponse>>(
    getPhoneSubmitCodeUrl(accountHandle),
    {
      ...options,
      method: "PUT",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(phoneSubmitCodeBody),
    },
  );
};

/**
 * List all access keys for the authenticated account or all access keys
that have been issued for the entire instance if and only if the request
parameters specify all keys and the requesting account is an admin.

 */
export type accessKeyListResponse = {
  data: AccessKeyListOKResponse;
  status: number;
};

export const getAccessKeyListUrl = () => {
  return `/auth/access-keys`;
};

export const accessKeyList = async (
  options?: RequestInit,
): Promise<accessKeyListResponse> => {
  return fetcher<Promise<accessKeyListResponse>>(getAccessKeyListUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * Create a new access key for the authenticated account. Access keys are
used to authenticate API requests on behalf of the account in a more
granular and service-friendly way than a session cookie.

Access keys share the same roles and permissions as the owning account
and only provide a way to use an `Authorization` header as an way of
interacting with the Storyden API.

Access keys also allow an expiry date to be set to limit how long a key
can be used to authenticate against the API.

 */
export type accessKeyCreateResponse = {
  data: AccessKeyCreateOKResponse;
  status: number;
};

export const getAccessKeyCreateUrl = () => {
  return `/auth/access-keys`;
};

export const accessKeyCreate = async (
  accessKeyCreateBody: AccessKeyCreateBody,
  options?: RequestInit,
): Promise<accessKeyCreateResponse> => {
  return fetcher<Promise<accessKeyCreateResponse>>(getAccessKeyCreateUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(accessKeyCreateBody),
  });
};

/**
 * Revoke an access key. This will immediately invalidate the key and it
will no longer be usable for authentication.

 */
export type accessKeyDeleteResponse = {
  data: NoContentResponse;
  status: number;
};

export const getAccessKeyDeleteUrl = (accessKeyId: string) => {
  return `/auth/access-keys/${accessKeyId}`;
};

export const accessKeyDelete = async (
  accessKeyId: string,
  options?: RequestInit,
): Promise<accessKeyDeleteResponse> => {
  return fetcher<Promise<accessKeyDeleteResponse>>(
    getAccessKeyDeleteUrl(accessKeyId),
    {
      ...options,
      method: "DELETE",
    },
  );
};

/**
 * Performs a HTTP logout by clearing the session cookie and redirecting to
to the requested path at the frontend's `WEB_ADDRESS`. Typically this
may be a secondary logout route on the frontend implementation that can
handle any frontend-specific logout tasks. This is necessary in cases
where the frontend is running on a different origin to the API service
such as api.site.com vs site.com because Clear-Site-Data and other
headers are same-origin compliant and won't work cross-origin.

 */
export type authProviderLogoutResponse = {
  data: unknown;
  status: number;
};

export const getAuthProviderLogoutUrl = (params?: AuthProviderLogoutParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/auth/logout?${normalizedParams.toString()}`
    : `/auth/logout`;
};

export const authProviderLogout = async (
  params?: AuthProviderLogoutParams,
  options?: RequestInit,
): Promise<authProviderLogoutResponse> => {
  return fetcher<Promise<authProviderLogoutResponse>>(
    getAuthProviderLogoutUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};
