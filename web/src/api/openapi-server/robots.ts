/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.26.3-canary
 */
import type {
  RobotChatStartBody,
  RobotChatStreamResponse,
  RobotCreateBody,
  RobotCreateOKResponse,
  RobotGetOKResponse,
  RobotSessionGetOKResponse,
  RobotSessionGetParams,
  RobotSessionsListOKResponse,
  RobotSessionsListParams,
  RobotUpdateBody,
  RobotsListOKResponse,
  RobotsListParams,
} from "../openapi-schema";
import { fetcher } from "../server";

/**
 * Get a paginated list of all available robots.
 * @summary List robots
 */
export type robotsListResponse = {
  data: RobotsListOKResponse;
  status: number;
};

export const getRobotsListUrl = (params?: RobotsListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/robots?${normalizedParams.toString()}`
    : `/robots`;
};

export const robotsList = async (
  params?: RobotsListParams,
  options?: RequestInit,
): Promise<robotsListResponse> => {
  return fetcher<Promise<robotsListResponse>>(getRobotsListUrl(params), {
    ...options,
    method: "GET",
  });
};

/**
 * Create a new Robot with the specified configuration. A Robot in Storyden
consists of a name and description (for humans) as well as a playbook,
and a set of available tools to interact with Storyden or plugins. The
playbook is a detailed set of instructions that guides behaviour of the
Robot to help it assist members in achieving a specific automation goal.
Tools are available from either Storyden or plugins that allow it to
perform actions or query data. Robots never need all tools and it's best
to build goal-specific Robots with minimal sets of tools.

 * @summary Create a robot
 */
export type robotCreateResponse = {
  data: RobotCreateOKResponse;
  status: number;
};

export const getRobotCreateUrl = () => {
  return `/robots`;
};

export const robotCreate = async (
  robotCreateBody: RobotCreateBody,
  options?: RequestInit,
): Promise<robotCreateResponse> => {
  return fetcher<Promise<robotCreateResponse>>(getRobotCreateUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(robotCreateBody),
  });
};

/**
 * Send a message to a Robot and receive its response. This endpoint
manages sessions automatically, creating new sessions as needed or
continuing existing sessions based on the provided session ID.

Each message sent to the Robot is processed according to its playbook
and available tools, allowing it to perform actions or retrieve data
as part of the conversation. The response from the Robot includes its
reply message along with any actions taken during the interaction.

This endpoint is a Server Sent Events (SSE) stream, meaning that the
response is streamed back to the client in real-time as the Robot
generates its reply.

 */
export type robotChatSSEResponse = {
  data: RobotChatStreamResponse;
  status: number;
};

export const getRobotChatSSEUrl = () => {
  return `/robots/chat/sse`;
};

export const robotChatSSE = async (
  robotChatStartBody: RobotChatStartBody,
  options?: RequestInit,
): Promise<robotChatSSEResponse> => {
  return fetcher<Promise<robotChatSSEResponse>>(getRobotChatSSEUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(robotChatStartBody),
  });
};

/**
 * Retrieve a specific Robot by its ID. Does not include any messages or
sessions associated with the Robot, just provides metadata about it.

 * @summary Get a robot
 */
export type robotGetResponse = {
  data: RobotGetOKResponse;
  status: number;
};

export const getRobotGetUrl = (robotId: string) => {
  return `/robots/${robotId}`;
};

export const robotGet = async (
  robotId: string,
  options?: RequestInit,
): Promise<robotGetResponse> => {
  return fetcher<Promise<robotGetResponse>>(getRobotGetUrl(robotId), {
    ...options,
    method: "GET",
  });
};

/**
 * Update a Robot's name, description, playbook or available tools.

 * @summary Update a robot
 */
export type robotUpdateResponse = {
  data: RobotGetOKResponse;
  status: number;
};

export const getRobotUpdateUrl = (robotId: string) => {
  return `/robots/${robotId}`;
};

export const robotUpdate = async (
  robotId: string,
  robotUpdateBody: RobotUpdateBody,
  options?: RequestInit,
): Promise<robotUpdateResponse> => {
  return fetcher<Promise<robotUpdateResponse>>(getRobotUpdateUrl(robotId), {
    ...options,
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(robotUpdateBody),
  });
};

/**
 * Get a paginated list of Robot sessions. These are chat sessions with the
Robot system. One session may span multiple Robots as members can switch
which Robot they are talking to mid conversation, or the Robot itself
may choose to switch to another Robot to achieve a goal. A session is a
representation of an entire conversation thread with the Robot system.

You may include an account ID to filter sessions by account. Only those
with "USE_ROBOTS" permission can use Robots, however sessions, messages
and usage is not considered hidden to other accounts with the usage
permission. Robots are intended as administrative or moderation tools
to be shared among the team rather than private assistants.

 * @summary List robot sessions
 */
export type robotSessionsListResponse = {
  data: RobotSessionsListOKResponse;
  status: number;
};

export const getRobotSessionsListUrl = (params?: RobotSessionsListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/robots/sessions?${normalizedParams.toString()}`
    : `/robots/sessions`;
};

export const robotSessionsList = async (
  params?: RobotSessionsListParams,
  options?: RequestInit,
): Promise<robotSessionsListResponse> => {
  return fetcher<Promise<robotSessionsListResponse>>(
    getRobotSessionsListUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Retrieve a specific robot session with all of its messages. Sessions can
involve interactions with multiple Robots so the Robot is specified on
each message. Messages may not be representative of exactly what is sent
into a language model, as certain optimisations may be performed before
this such as compaction, summarisation or removal of irrelevant context.

Any member with "USE_ROBOTS" can see any other members' sessions and
messages with a Robot. Robots are not considered private assistants, but
rather shared tools for the team to use for managing their community.

 * @summary Get a robot session
 */
export type robotSessionGetResponse = {
  data: RobotSessionGetOKResponse;
  status: number;
};

export const getRobotSessionGetUrl = (
  sessionId: string,
  params?: RobotSessionGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/robots/sessions/${sessionId}?${normalizedParams.toString()}`
    : `/robots/sessions/${sessionId}`;
};

export const robotSessionGet = async (
  sessionId: string,
  params?: RobotSessionGetParams,
  options?: RequestInit,
): Promise<robotSessionGetResponse> => {
  return fetcher<Promise<robotSessionGetResponse>>(
    getRobotSessionGetUrl(sessionId, params),
    {
      ...options,
      method: "GET",
    },
  );
};
