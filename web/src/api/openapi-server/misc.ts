/**
 * Generated by orval v7.2.0 🍺
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.25.8-canary
 */
import type {
  AssetGetOKResponse,
  AssetUploadBody,
  BeaconBody,
  GetInfoOKResponse,
  GetSpec200,
} from "../openapi-schema";
import { fetcher } from "../server";

/**
 * The version number includes the date and time of the release build as
well as a short representation of the Git commit hash.

 * @summary Get the software version string.
 */
export type getVersionResponse = {
  data: string;
  status: number;
};

export const getGetVersionUrl = () => {
  return `/version`;
};

export const getVersion = async (
  options?: RequestInit,
): Promise<getVersionResponse> => {
  return fetcher<Promise<getVersionResponse>>(getGetVersionUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * This endpoint returns the OpenAPI specification for the Storyden API in
JSON format. This is useful for clients that want to dynamically load
the API specification for documentation or code generation.

 * @summary OpenAPI specification
 */
export type getSpecResponse = {
  data: GetSpec200;
  status: number;
};

export const getGetSpecUrl = () => {
  return `/openapi.json`;
};

export const getSpec = async (
  options?: RequestInit,
): Promise<getSpecResponse> => {
  return fetcher<Promise<getSpecResponse>>(getGetSpecUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * This endpoint returns the OpenAPI documentation for the Storyden API in
an interactive HTML format. This is useful for developers who want to
explore the API and test endpoints without writing code.

 * @summary API documentation
 */
export type getDocsResponse = {
  data: string;
  status: number;
};

export const getGetDocsUrl = () => {
  return `/docs`;
};

export const getDocs = async (
  options?: RequestInit,
): Promise<getDocsResponse> => {
  return fetcher<Promise<getDocsResponse>>(getGetDocsUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * Get the basic forum installation info such as title, description, etc.

This is a fully public endpoint as it drives the ability to render stuff
like OpenGraph metadata, favicon, titles, descriptions, for crawlers.

 */
export type getInfoResponse = {
  data: GetInfoOKResponse;
  status: number;
};

export const getGetInfoUrl = () => {
  return `/info`;
};

export const getInfo = async (
  options?: RequestInit,
): Promise<getInfoResponse> => {
  return fetcher<Promise<getInfoResponse>>(getGetInfoUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * Get the logo icon image.
 */
export type iconGetResponse = {
  data: AssetGetOKResponse;
  status: number;
};

export const getIconGetUrl = (
  iconSize: "512x512" | "32x32" | "180x180" | "120x120" | "167x167" | "152x152",
) => {
  return `/info/icon/${iconSize}`;
};

export const iconGet = async (
  iconSize: "512x512" | "32x32" | "180x180" | "120x120" | "167x167" | "152x152",
  options?: RequestInit,
): Promise<iconGetResponse> => {
  return fetcher<Promise<iconGetResponse>>(getIconGetUrl(iconSize), {
    ...options,
    method: "GET",
  });
};

/**
 * Upload and process the installation's logo image.
 */
export type iconUploadResponse = {
  data: void;
  status: number;
};

export const getIconUploadUrl = () => {
  return `/info/icon`;
};

export const iconUpload = async (
  assetUploadBody: AssetUploadBody,
  options?: RequestInit,
): Promise<iconUploadResponse> => {
  return fetcher<Promise<iconUploadResponse>>(getIconUploadUrl(), {
    ...options,
    method: "POST",
    headers: {
      "Content-Type": "application/octet-stream",
      ...options?.headers,
    },
    body: JSON.stringify(assetUploadBody),
  });
};

/**
 * Get the banner image.
 */
export type bannerGetResponse = {
  data: AssetGetOKResponse;
  status: number;
};

export const getBannerGetUrl = () => {
  return `/info/banner`;
};

export const bannerGet = async (
  options?: RequestInit,
): Promise<bannerGetResponse> => {
  return fetcher<Promise<bannerGetResponse>>(getBannerGetUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * Upload and process the installation's banner image.
 */
export type bannerUploadResponse = {
  data: void;
  status: number;
};

export const getBannerUploadUrl = () => {
  return `/info/banner`;
};

export const bannerUpload = async (
  assetUploadBody: AssetUploadBody,
  options?: RequestInit,
): Promise<bannerUploadResponse> => {
  return fetcher<Promise<bannerUploadResponse>>(getBannerUploadUrl(), {
    ...options,
    method: "POST",
    headers: {
      "Content-Type": "application/octet-stream",
      ...options?.headers,
    },
    body: JSON.stringify(assetUploadBody),
  });
};

/**
 * A catch-all endpoint for tracking read states and other things that are
not critical to the functioning of the platform. This endpoint is fire
and forget and does not return any meaningful data. It is designed to
be used with the `navigator.sendBeacon` API in browsers to mark things
such as how far down a thread a member has read, or whether or not a
Library Page has been visited recently. It may queue the work for later
processing and is not guaranteed to be processed immediately or at all.

 */
export type sendBeaconResponse = {
  data: void;
  status: number;
};

export const getSendBeaconUrl = () => {
  return `/beacon`;
};

export const sendBeacon = async (
  beaconBody: BeaconBody,
  options?: RequestInit,
): Promise<sendBeaconResponse> => {
  return fetcher<Promise<sendBeaconResponse>>(getSendBeaconUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "text/plain", ...options?.headers },
    body: JSON.stringify(beaconBody),
  });
};
