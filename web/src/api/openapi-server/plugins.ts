/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.26.3-canary
 */
import type {
  NoContentResponse,
  PluginAddBody,
  PluginCycleTokenOKResponse,
  PluginGetConfigurationOKResponse,
  PluginGetConfigurationSchemaOKResponse,
  PluginGetLogsOKResponse,
  PluginGetOKResponse,
  PluginListOKResponse,
  PluginSetActiveStateBody,
  PluginUpdateConfigurationBody,
  PluginUpdateManifestBody,
} from "../openapi-schema";
import { fetcher } from "../server";

/**
 * List all plugins that are installed on the instance.
 */
export type pluginListResponse = {
  data: PluginListOKResponse;
  status: number;
};

export const getPluginListUrl = () => {
  return `/plugins`;
};

export const pluginList = async (
  options?: RequestInit,
): Promise<pluginListResponse> => {
  return fetcher<Promise<pluginListResponse>>(getPluginListUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * Add a plugin to the instance. This will not install or activate the
plugin immediately. It will validate and prepare the plugin for install.

Plugins can be uploaded directly as files or via a URL to a repository.

 */
export type pluginAddResponse = {
  data: PluginGetOKResponse;
  status: number;
};

export const getPluginAddUrl = () => {
  return `/plugins`;
};

export const pluginAdd = async (
  pluginAddBody: PluginAddBody,
  options?: RequestInit,
): Promise<pluginAddResponse> => {
  return fetcher<Promise<pluginAddResponse>>(getPluginAddUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/zip", ...options?.headers },
    body: JSON.stringify(pluginAddBody),
  });
};

/**
 * Get information about a specific plugin.
 */
export type pluginGetResponse = {
  data: PluginGetOKResponse;
  status: number;
};

export const getPluginGetUrl = (pluginInstanceId: string) => {
  return `/plugins/${pluginInstanceId}`;
};

export const pluginGet = async (
  pluginInstanceId: string,
  options?: RequestInit,
): Promise<pluginGetResponse> => {
  return fetcher<Promise<pluginGetResponse>>(
    getPluginGetUrl(pluginInstanceId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Completely delete a plugin from the instance. This will uninstall the
plugin first then remove its binary file from the storage backend.

Some plugins may write additional data to the instance, this will not
be removed by this operation unless the plugin cleans up after itself.

 */
export type pluginDeleteResponse = {
  data: NoContentResponse;
  status: number;
};

export const getPluginDeleteUrl = (pluginInstanceId: string) => {
  return `/plugins/${pluginInstanceId}`;
};

export const pluginDelete = async (
  pluginInstanceId: string,
  options?: RequestInit,
): Promise<pluginDeleteResponse> => {
  return fetcher<Promise<pluginDeleteResponse>>(
    getPluginDeleteUrl(pluginInstanceId),
    {
      ...options,
      method: "DELETE",
    },
  );
};

/**
 * Change the active state of a plugin. When activated, the plugin will
install itself and become available for use. When deactivated, This will
uninstall the plugin but keep its data and config for reactivation.

 */
export type pluginSetActiveStateResponse = {
  data: PluginGetOKResponse;
  status: number;
};

export const getPluginSetActiveStateUrl = (pluginInstanceId: string) => {
  return `/plugins/${pluginInstanceId}/active`;
};

export const pluginSetActiveState = async (
  pluginInstanceId: string,
  pluginSetActiveStateBody: PluginSetActiveStateBody,
  options?: RequestInit,
): Promise<pluginSetActiveStateResponse> => {
  return fetcher<Promise<pluginSetActiveStateResponse>>(
    getPluginSetActiveStateUrl(pluginInstanceId),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(pluginSetActiveStateBody),
    },
  );
};

/**
 * Stream the logs for the specified plugin. If the plugin is running, this
endpoint will stream live logs after the existing logs have been sent.

 */
export type pluginGetLogsResponse = {
  data: PluginGetLogsOKResponse;
  status: number;
};

export const getPluginGetLogsUrl = (pluginInstanceId: string) => {
  return `/plugins/${pluginInstanceId}/logs`;
};

export const pluginGetLogs = async (
  pluginInstanceId: string,
  options?: RequestInit,
): Promise<pluginGetLogsResponse> => {
  return fetcher<Promise<pluginGetLogsResponse>>(
    getPluginGetLogsUrl(pluginInstanceId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Cycles the static bearer token for an external plugin and returns the
newly generated token. This operation is only valid for external
plugins. Supervised plugins cycle their connection token automatically.

 */
export type pluginCycleTokenResponse = {
  data: PluginCycleTokenOKResponse;
  status: number;
};

export const getPluginCycleTokenUrl = (pluginInstanceId: string) => {
  return `/plugins/${pluginInstanceId}/token`;
};

export const pluginCycleToken = async (
  pluginInstanceId: string,
  options?: RequestInit,
): Promise<pluginCycleTokenResponse> => {
  return fetcher<Promise<pluginCycleTokenResponse>>(
    getPluginCycleTokenUrl(pluginInstanceId),
    {
      ...options,
      method: "POST",
    },
  );
};

/**
 * Update the manifest for a plugin. This is used for development of plugins
where the manifest may change frequently and it's useful to be able to
update it without re-uploading the entire plugin bundle.

This only works for External plugins that were created by uploading a 
manifest directly. It does not work for Supervised plugins.

 */
export type pluginUpdateManifestResponse = {
  data: PluginGetOKResponse;
  status: number;
};

export const getPluginUpdateManifestUrl = (pluginInstanceId: string) => {
  return `/plugins/${pluginInstanceId}/manifest`;
};

export const pluginUpdateManifest = async (
  pluginInstanceId: string,
  pluginUpdateManifestBody: PluginUpdateManifestBody,
  options?: RequestInit,
): Promise<pluginUpdateManifestResponse> => {
  return fetcher<Promise<pluginUpdateManifestResponse>>(
    getPluginUpdateManifestUrl(pluginInstanceId),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(pluginUpdateManifestBody),
    },
  );
};

/**
 * Returns the configuration schema for a plugin as defined in its manifest
file. The schema should be used to render a configuration form for the
plugin in the client so that administrators can configure the plugin.

 */
export type pluginGetConfigurationSchemaResponse = {
  data: PluginGetConfigurationSchemaOKResponse;
  status: number;
};

export const getPluginGetConfigurationSchemaUrl = (
  pluginInstanceId: string,
) => {
  return `/plugins/${pluginInstanceId}/configuration-schema`;
};

export const pluginGetConfigurationSchema = async (
  pluginInstanceId: string,
  options?: RequestInit,
): Promise<pluginGetConfigurationSchemaResponse> => {
  return fetcher<Promise<pluginGetConfigurationSchemaResponse>>(
    getPluginGetConfigurationSchemaUrl(pluginInstanceId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Get the current configuration values for a plugin. The shape of the
object is defined by the plugin's manifest and should be used to render
the current configuration state in the client, using the layout driven
by the result of `PluginGetConfigurationSchema` to build a form-like UI.

 */
export type pluginGetConfigurationResponse = {
  data: PluginGetConfigurationOKResponse;
  status: number;
};

export const getPluginGetConfigurationUrl = (pluginInstanceId: string) => {
  return `/plugins/${pluginInstanceId}/configuration`;
};

export const pluginGetConfiguration = async (
  pluginInstanceId: string,
  options?: RequestInit,
): Promise<pluginGetConfigurationResponse> => {
  return fetcher<Promise<pluginGetConfigurationResponse>>(
    getPluginGetConfigurationUrl(pluginInstanceId),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Update the configuration for a plugin. Each plugin defines its own set
of configuration parameters in its manifest and this endpoint accepts
any object validated against that schema. When a valid configuration is
received, it is sent to the plugin via RPC and the plugin is expected to
apply the new configuration to itself internally.

 */
export type pluginUpdateConfigurationResponse = {
  data: PluginGetConfigurationOKResponse;
  status: number;
};

export const getPluginUpdateConfigurationUrl = (pluginInstanceId: string) => {
  return `/plugins/${pluginInstanceId}/configuration`;
};

export const pluginUpdateConfiguration = async (
  pluginInstanceId: string,
  pluginUpdateConfigurationBody: PluginUpdateConfigurationBody,
  options?: RequestInit,
): Promise<pluginUpdateConfigurationResponse> => {
  return fetcher<Promise<pluginUpdateConfigurationResponse>>(
    getPluginUpdateConfigurationUrl(pluginInstanceId),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(pluginUpdateConfigurationBody),
    },
  );
};
