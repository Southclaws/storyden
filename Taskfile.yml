version: 3

dotenv:
  - .env

vars:
  NEXT_VERSION:
    sh: go run ./version.go

  CURRENT_VERSION:
    # NOTE: In CI this doesn't work so we leave a default value so `task` works.
    sh: git describe --tags --abbrev=0 || echo "NO_VERSION_SET_DO_NOT_PROCEED"

tasks:
  version:
    desc: >
      Yields the next version number for a new release. Will update all relevant
      files with the new version number. These files include:
        - openapi.yaml specification
        - package.json for the frontend
        - version.go for the backend
      Due to the fact generated files also contain the version, this will also
      trigger the codegen task to regenerate all of the related files.

      Example: v1.25.1

    prompt:
      - "Current version: {{.CURRENT_VERSION}} Next version: {{.NEXT_VERSION}} | Write new version to relevant files?"

    preconditions:
      # Must be on main branch
      - sh: '[ "$(git symbolic-ref --short HEAD)" = "main" ]'
        msg: "Release must be done from the 'main' branch"

      # Working directory must be clean (no staged or unstaged changes)
      - sh: '[ -z "$(git status --porcelain)" ]'
        msg: "Working directory must be clean (no uncommitted changes)"

      # Must have a current version set
      - sh: '[ "{{.CURRENT_VERSION}}" != "NO_VERSION_SET_DO_NOT_PROCEED" ]'
        msg: "CURRENT_VERSION is invalid (no git tags found). Refusing to run release."

    cmds:
      - go run ./version.go -w
      - task generate

  release:post:
    desc: >
      After a tagged release, we write a version number again to the relevant
      files to indicate they are canary builds. This happens after the actual
      commit and tag have been created with the "next" version number and is 
      there to ensure commits that land on `main` *after* a tagged release are
      still identifiable as canary builds.

      Example: 1.25.1-canary

      Canary version numbers are NOT used as git tags. They are only used in
      files to indicate the current commit or running version is not stable.
    cmds:
      - go run ./version.go -w -c
      - task generate
      - git add .
      - git commit -m "Post-release {{.CURRENT_VERSION}}"

  release:
    desc: >
      Creates a new release by committing the changes made by the `version` task
      and tagging the commit with the new version number. This does not however
      push the changes or create the GitHub release resource itself. You must
      do that separately as well as write a user-oriented change log for it.
    deps: [version]
    cmds:
      - git add .
      - git commit -m "Release {{.NEXT_VERSION}}"
      - git tag {{.NEXT_VERSION}}
      - task release:post

  release:undo:
    desc: >
      Undoes the last release by deleting the last tag and resetting the working
      directory to the state before the release commit.
    cmds:
      - git reset --hard HEAD~1
      - git tag -d {{.CURRENT_VERSION}}

  release-push:
    desc: >
      Pushes the latest commit and tags to the remote repository. This does not
      create a GitHub release resource, you must do that separately.

      You need to be signed in to the GitHub CLI (gh) and have permissions in
      the Storyden repository to manage releases for this to work.
    prompt:
      - "Unreleased version: {{.CURRENT_VERSION}} | Create GitHub release draft?"
    cmds:
      - git push
      - git push --tags
      - gh release create {{.CURRENT_VERSION}}
        --draft
        --title {{.CURRENT_VERSION}}
        --notes "Write the release notes..."

  # -
  # Code generation
  # -

  generate:
    deps: [generate:db, generate:openapi]

  generate:db:
    cmds: [go generate ./internal/ent]

  generate:openapi:
    deps:
      - generate:openapi:backend
      - generate:openapi:frontend
      - generate:openapi:docs

  generate:openapi:backend:
    cmds: [go generate .]
  generate:openapi:frontend:
    dir: web
    cmds: [yarn openapi]
  generate:openapi:docs:
    dir: home
    cmds: [yarn openapi]

  # -
  # Database
  # -

  seed:
    cmds:
      - go run ./cmd/seed

  # -
  # End to end tests
  # -

  test:e2e:ui:
    cmds:
      - go run ./cmd/e2etest --ui

  test:e2e:
    cmds:
      - go run ./cmd/e2etest

  test:e2e:rebuild:
    cmds:
      - mkdir -p ./tests/e2e-data || true
      - go build -o ./tests/e2e-data/backend.exe ./cmd/backend
      - cd web ; yarn build ; cd ..

  test:e2e:fresh:
    deps: [test:e2e:rebuild]
    cmds:
      - go run ./cmd/e2etest --ui

  test:e2e:ci:
    deps: [test:e2e:rebuild]
    cmds:
      - go run ./cmd/e2etest

  # -
  # Container images
  # -

  image:docker:
    deps: [image:docker:build:all, image:docker:build:api]

  image:podman:
    deps: [image:podman:build:all, image:podman:build:api]

  image:docker:build:all:
    desc: >
      Builds the Docker image for the backend service. The image will be tagged
      with the current version number.
    cmds:
      - docker buildx build
        --platform linux/amd64,linux/arm64
        -t storyden
        -f docker/all/Dockerfile .

  image:docker:build:api:
    desc: >
      Builds the Docker image for the backend service. The image will be tagged
      with the current version number.
    cmds:
      - docker buildx build
        --platform linux/amd64,linux/arm64
        -t storyden:api
        -f docker/all/Dockerfile .

  image:podman:build:all:
    desc: >
      Builds the Docker image for the backend service. The image will be tagged
      with the current version number.
    cmds:
      - podman buildx build
        -t storyden
        -f docker/all/Dockerfile .

  image:podman:build:api:
    desc: >
      Builds the Docker image for the backend service. The image will be tagged
      with the current version number.
    cmds:
      - podman buildx build
        --platform linux/amd64,linux/arm64
        -t storyden:api
        -f docker/all/Dockerfile .
