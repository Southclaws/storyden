package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/goccy/go-yaml"
	"github.com/google/jsonschema-go/jsonschema"
)

const handlerTemplate = `// Code generated by eventgen. DO NOT EDIT.

package storyden

import (
	"context"

	"github.com/Southclaws/storyden/lib/plugin/rpc"
)

{{ range .Events }}
func (p *Plugin) On{{ .HandlerName }}(handler func(context.Context, *rpc.{{ .TypeName }}) error) {
	p.On("{{ .TypeName }}", func(ctx context.Context, event rpc.EventPayload) error {
		if e, ok := event.EventPayloadUnion.(*rpc.{{ .TypeName }}); ok {
			return handler(ctx, e)
		}
		return nil
	})
}
{{ end }}
`

const webEventNamesTemplate = `// Code generated by eventgen. DO NOT EDIT.

export const pluginEventNames = [
{{- range .Events }}
  "{{ .TypeName }}",
{{- end }}
] as const;

export type PluginEventName = (typeof pluginEventNames)[number];
`

const pythonEventNamesTemplate = `# Code generated by eventgen. DO NOT EDIT.

from typing import Literal, TypeAlias

plugin_event_names = [
{{- range .Events }}
    "{{ .TypeName }}",
{{- end }}
]

EventName: TypeAlias = Literal[
{{- range .Events }}
    "{{ .TypeName }}",
{{- end }}
]

__all__ = ["EventName", "plugin_event_names"]
`

type Event struct {
	TypeName    string
	HandlerName string
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	schemaPath := filepath.Join("common", "events.yaml")
	goOutputPath := filepath.Join("..", "sdk", "go", "storyden", "handlers.go")
	webOutputPath := filepath.Join("..", "web", "src", "api", "events.ts")
	pythonOutputPath := filepath.Join("..", "sdk", "python", "storyden", "rpc", "events.py")

	events, err := extractEventsFromSchema(schemaPath)
	if err != nil {
		return fmt.Errorf("failed to extract events: %w", err)
	}

	goCode, err := generateHandlers(events)
	if err != nil {
		return fmt.Errorf("failed to generate handlers: %w", err)
	}

	webCode, err := generateWebEventNames(events)
	if err != nil {
		return fmt.Errorf("failed to generate web event names: %w", err)
	}

	pythonCode, err := generatePythonEventNames(events)
	if err != nil {
		return fmt.Errorf("failed to generate python event names: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(goOutputPath), 0o755); err != nil {
		return fmt.Errorf("failed to create Go output directory: %w", err)
	}

	if err := os.WriteFile(goOutputPath, goCode, 0o644); err != nil {
		return fmt.Errorf("failed to write Go output file: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(webOutputPath), 0o755); err != nil {
		return fmt.Errorf("failed to create web output directory: %w", err)
	}

	if err := os.WriteFile(webOutputPath, webCode, 0o644); err != nil {
		return fmt.Errorf("failed to write web output file: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(pythonOutputPath), 0o755); err != nil {
		return fmt.Errorf("failed to create python output directory: %w", err)
	}

	if err := os.WriteFile(pythonOutputPath, pythonCode, 0o644); err != nil {
		return fmt.Errorf("failed to write Python output file: %w", err)
	}

	fmt.Printf("Generated %d event handlers in %s\n", len(events), goOutputPath)
	fmt.Printf("Generated %d plugin event names in %s\n", len(events), webOutputPath)
	fmt.Printf("Generated %d plugin event names in %s\n", len(events), pythonOutputPath)
	return nil
}

func extractEventsFromSchema(schemaPath string) ([]Event, error) {
	yamlData, err := os.ReadFile(schemaPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read schema file: %w", err)
	}

	var jsonData interface{}
	if err := yaml.Unmarshal(yamlData, &jsonData); err != nil {
		return nil, fmt.Errorf("failed to unmarshal YAML: %w", err)
	}

	jsonBytes, err := json.Marshal(jsonData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal to JSON: %w", err)
	}

	var schema jsonschema.Schema
	if err := json.Unmarshal(jsonBytes, &schema); err != nil {
		return nil, fmt.Errorf("failed to unmarshal JSON schema: %w", err)
	}

	eventPayloadDef, ok := schema.Defs["EventPayload"]
	if !ok {
		eventPayloadDef, ok = schema.Definitions["EventPayload"]
		if !ok {
			return nil, fmt.Errorf("EventPayload definition not found in schema (checked both $defs and definitions)")
		}
	}

	eventEnumDef, ok := schema.Defs["Event"]
	if !ok {
		eventEnumDef, ok = schema.Definitions["Event"]
		if !ok {
			return nil, fmt.Errorf("Event definition not found in schema (checked both $defs and definitions)")
		}
	}

	enumSet := make(map[string]bool, len(eventEnumDef.Enum))
	for _, v := range eventEnumDef.Enum {
		s, ok := v.(string)
		if !ok {
			continue
		}
		enumSet[s] = true
	}

	var events []Event
	var missing []string

	for _, oneOfSchema := range eventPayloadDef.OneOf {
		if oneOfSchema.Ref == "" {
			continue
		}

		parts := strings.Split(oneOfSchema.Ref, "/")
		if len(parts) == 0 {
			continue
		}

		eventName := parts[len(parts)-1]
		if !strings.HasPrefix(eventName, "Event") {
			continue
		}

		if !enumSet[eventName] {
			missing = append(missing, eventName)
		}

		handlerName := strings.TrimPrefix(eventName, "Event")

		events = append(events, Event{
			TypeName:    eventName,
			HandlerName: handlerName,
		})
	}

	if len(missing) > 0 {
		return nil, fmt.Errorf("events defined in EventPayload but missing from Event enum: %s", strings.Join(missing, ", "))
	}

	payloadSet := make(map[string]bool, len(events))
	for _, e := range events {
		payloadSet[e.TypeName] = true
	}

	var extra []string
	for name := range enumSet {
		if !payloadSet[name] {
			extra = append(extra, name)
		}
	}

	if len(extra) > 0 {
		return nil, fmt.Errorf("events defined in Event enum but missing from EventPayload: %s", strings.Join(extra, ", "))
	}

	return events, nil
}

func generateHandlers(events []Event) ([]byte, error) {
	tmpl, err := template.New("handlers").Parse(handlerTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, map[string]interface{}{
		"Events": events,
	}); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("failed to format code: %w", err)
	}

	return formatted, nil
}

func generateWebEventNames(events []Event) ([]byte, error) {
	tmpl, err := template.New("web-events").Parse(webEventNamesTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, map[string]interface{}{
		"Events": events,
	}); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.Bytes(), nil
}

func generatePythonEventNames(events []Event) ([]byte, error) {
	tmpl, err := template.New("python-events").Parse(pythonEventNamesTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, map[string]interface{}{
		"Events": events,
	}); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.Bytes(), nil
}
