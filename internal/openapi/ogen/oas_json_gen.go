// Code generated by ogen, DO NOT EDIT.

package ogen

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s APIError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s APIError) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("error")
		e.Str(s.Error)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Suggested.Set {
			e.FieldStart("suggested")
			s.Suggested.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIError = [4]string{
	0: "error",
	1: "message",
	2: "suggested",
	3: "metadata",
}

// Decode decodes APIError from json.
func (s *APIError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "suggested":
			if err := func() error {
				s.Suggested.Reset()
				if err := s.Suggested.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suggested\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIError) {
					name = jsonFieldsNameOfAPIError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s APIErrorMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s APIErrorMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes APIErrorMetadata from json.
func (s *APIErrorMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIErrorMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIErrorMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIErrorMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIErrorMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountHandle as json.
func (s AccountHandle) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes AccountHandle from json.
func (s *AccountHandle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountHandle to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AccountHandle(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountHandle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountHandle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountName as json.
func (s AccountName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes AccountName from json.
func (s *AccountName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AccountName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AccountsUpdateBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s AccountsUpdateBody) encodeFields(e *jx.Encoder) {
	{
		if s.Handle.Set {
			e.FieldStart("handle")
			s.Handle.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Interests != nil {
			e.FieldStart("interests")
			s.Interests.Encode(e)
		}
	}
}

var jsonFieldsNameOfAccountsUpdateBody = [4]string{
	0: "handle",
	1: "name",
	2: "bio",
	3: "interests",
}

// Decode decodes AccountsUpdateBody from json.
func (s *AccountsUpdateBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountsUpdateBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "handle":
			if err := func() error {
				s.Handle.Reset()
				if err := s.Handle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handle\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "interests":
			if err := func() error {
				s.Interests = nil
				var elem TagList
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Interests = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountsUpdateBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountsUpdateBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountsUpdateBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AuthOAuthProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s AuthOAuthProvider) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("provider")
		e.Str(s.Provider)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("logo_url")
		e.Str(s.LogoURL)
	}
	{

		e.FieldStart("link")
		e.Str(s.Link)
	}
}

var jsonFieldsNameOfAuthOAuthProvider = [4]string{
	0: "provider",
	1: "name",
	2: "logo_url",
	3: "link",
}

// Decode decodes AuthOAuthProvider from json.
func (s *AuthOAuthProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthOAuthProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "provider":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Provider = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "logo_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LogoURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logo_url\"")
			}
		case "link":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Link = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthOAuthProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthOAuthProvider) {
					name = jsonFieldsNameOfAuthOAuthProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthOAuthProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthOAuthProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AuthOAuthProviderCallbackBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s AuthOAuthProviderCallbackBody) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("state")
		e.Str(s.State)
	}
	{

		e.FieldStart("code")
		e.Str(s.Code)
	}
}

var jsonFieldsNameOfAuthOAuthProviderCallbackBody = [2]string{
	0: "state",
	1: "code",
}

// Decode decodes AuthOAuthProviderCallbackBody from json.
func (s *AuthOAuthProviderCallbackBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthOAuthProviderCallbackBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthOAuthProviderCallbackBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthOAuthProviderCallbackBody) {
					name = jsonFieldsNameOfAuthOAuthProviderCallbackBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthOAuthProviderCallbackBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthOAuthProviderCallbackBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthOAuthProviderListBody as json.
func (s AuthOAuthProviderListBody) Encode(e *jx.Encoder) {
	unwrapped := []AuthOAuthProvider(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AuthOAuthProviderListBody from json.
func (s *AuthOAuthProviderListBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthOAuthProviderListBody to nil")
	}
	var unwrapped []AuthOAuthProvider
	if err := func() error {
		unwrapped = make([]AuthOAuthProvider, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AuthOAuthProvider
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthOAuthProviderListBody(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthOAuthProviderListBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthOAuthProviderListBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AuthPasswordBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s AuthPasswordBody) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("identifier")
		e.Str(s.Identifier)
	}
	{

		e.FieldStart("token")
		e.Str(s.Token)
	}
}

var jsonFieldsNameOfAuthPasswordBody = [2]string{
	0: "identifier",
	1: "token",
}

// Decode decodes AuthPasswordBody from json.
func (s *AuthPasswordBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthPasswordBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "identifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Identifier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthPasswordBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthPasswordBody) {
					name = jsonFieldsNameOfAuthPasswordBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthPasswordBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthPasswordBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthPasswordSigninApplicationJSON as json.
func (s AuthPasswordSigninApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := AuthPasswordBody(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthPasswordSigninApplicationJSON from json.
func (s *AuthPasswordSigninApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthPasswordSigninApplicationJSON to nil")
	}
	var unwrapped AuthPasswordBody
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthPasswordSigninApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthPasswordSigninApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthPasswordSigninApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthPasswordSigninApplicationXWwwFormUrlencoded as json.
func (s AuthPasswordSigninApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := AuthPasswordBody(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthPasswordSigninApplicationXWwwFormUrlencoded from json.
func (s *AuthPasswordSigninApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthPasswordSigninApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped AuthPasswordBody
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthPasswordSigninApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthPasswordSigninApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthPasswordSigninApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthPasswordSignupApplicationJSON as json.
func (s AuthPasswordSignupApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := AuthPasswordBody(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthPasswordSignupApplicationJSON from json.
func (s *AuthPasswordSignupApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthPasswordSignupApplicationJSON to nil")
	}
	var unwrapped AuthPasswordBody
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthPasswordSignupApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthPasswordSignupApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthPasswordSignupApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthPasswordSignupApplicationXWwwFormUrlencoded as json.
func (s AuthPasswordSignupApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := AuthPasswordBody(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthPasswordSignupApplicationXWwwFormUrlencoded from json.
func (s *AuthPasswordSignupApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthPasswordSignupApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped AuthPasswordBody
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthPasswordSignupApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthPasswordSignupApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthPasswordSignupApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AuthSuccess) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s AuthSuccess) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfAuthSuccess = [1]string{
	0: "id",
}

// Decode decodes AuthSuccess from json.
func (s *AuthSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthSuccess to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthSuccess")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthSuccess) {
					name = jsonFieldsNameOfAuthSuccess[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Category) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Category) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Colour.Set {
			e.FieldStart("colour")
			s.Colour.Encode(e)
		}
	}
	{
		if s.Sort.Set {
			e.FieldStart("sort")
			s.Sort.Encode(e)
		}
	}
	{
		if s.Admin.Set {
			e.FieldStart("admin")
			s.Admin.Encode(e)
		}
	}
	{
		if s.PostCount.Set {
			e.FieldStart("postCount")
			s.PostCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategory = [7]string{
	0: "id",
	1: "name",
	2: "description",
	3: "colour",
	4: "sort",
	5: "admin",
	6: "postCount",
}

// Decode decodes Category from json.
func (s *Category) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Category to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "colour":
			if err := func() error {
				s.Colour.Reset()
				if err := s.Colour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"colour\"")
			}
		case "sort":
			if err := func() error {
				s.Sort.Reset()
				if err := s.Sort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sort\"")
			}
		case "admin":
			if err := func() error {
				s.Admin.Reset()
				if err := s.Admin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "postCount":
			if err := func() error {
				s.PostCount.Reset()
				if err := s.PostCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"postCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Category")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Category) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Category) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CommonProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s CommonProperties) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{

		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{

		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.DeletedAt.Set {
			e.FieldStart("deletedAt")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Misc != nil {
			e.FieldStart("misc")
			s.Misc.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommonProperties = [5]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "deletedAt",
	4: "misc",
}

// Decode decodes CommonProperties from json.
func (s *CommonProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonProperties to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "deletedAt":
			if err := func() error {
				s.DeletedAt.Reset()
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedAt\"")
			}
		case "misc":
			if err := func() error {
				s.Misc = nil
				var elem CommonPropertiesMisc
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Misc = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"misc\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommonProperties")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommonProperties) {
					name = jsonFieldsNameOfCommonProperties[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CommonProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CommonPropertiesMisc) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s CommonPropertiesMisc) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCommonPropertiesMisc = [0]string{}

// Decode decodes CommonPropertiesMisc from json.
func (s *CommonPropertiesMisc) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonPropertiesMisc to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommonPropertiesMisc")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CommonPropertiesMisc) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonPropertiesMisc) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Identifier as json.
func (s Identifier) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Identifier from json.
func (s *Identifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Identifier to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Identifier(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Identifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Identifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Metadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s Metadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes Metadata from json.
func (s *Metadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Metadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Metadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Metadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Metadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIErrorMetadata as json.
func (o OptAPIErrorMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIErrorMetadata from json.
func (o *OptAPIErrorMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIErrorMetadata to nil")
	}
	o.Set = true
	o.Value = make(APIErrorMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIErrorMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIErrorMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountHandle as json.
func (o OptAccountHandle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AccountHandle from json.
func (o *OptAccountHandle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccountHandle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccountHandle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccountHandle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountName as json.
func (o OptAccountName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AccountName from json.
func (o *OptAccountName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccountName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccountName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccountName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountsUpdateBody as json.
func (o OptAccountsUpdateBody) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AccountsUpdateBody from json.
func (o *OptAccountsUpdateBody) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccountsUpdateBody to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccountsUpdateBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccountsUpdateBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthOAuthProviderCallbackBody as json.
func (o OptAuthOAuthProviderCallbackBody) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AuthOAuthProviderCallbackBody from json.
func (o *OptAuthOAuthProviderCallbackBody) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuthOAuthProviderCallbackBody to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAuthOAuthProviderCallbackBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAuthOAuthProviderCallbackBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes Identifier as json.
func (o OptIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Identifier from json.
func (o *OptIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIdentifier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Metadata as json.
func (o OptMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Metadata from json.
func (o *OptMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMetadata to nil")
	}
	o.Set = true
	o.Value = make(Metadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Post as json.
func (o OptPost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Post from json.
func (o *OptPost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Post) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Post) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{

		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{

		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.DeletedAt.Set {
			e.FieldStart("deletedAt")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Misc != nil {
			e.FieldStart("misc")
			s.Misc.Encode(e)
		}
	}
	{

		e.FieldStart("body")
		s.Body.Encode(e)
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.ReplyTo.Set {
			e.FieldStart("reply_to")
			s.ReplyTo.Encode(e)
		}
	}
}

var jsonFieldsNameOfPost = [8]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "deletedAt",
	4: "misc",
	5: "body",
	6: "meta",
	7: "reply_to",
}

// Decode decodes Post from json.
func (s *Post) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Post to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "deletedAt":
			if err := func() error {
				s.DeletedAt.Reset()
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedAt\"")
			}
		case "misc":
			if err := func() error {
				s.Misc = nil
				var elem PostMisc
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Misc = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"misc\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "reply_to":
			if err := func() error {
				s.ReplyTo.Reset()
				if err := s.ReplyTo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reply_to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Post")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPost) {
					name = jsonFieldsNameOfPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Post) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Post) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostBodyMarkdown as json.
func (s PostBodyMarkdown) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes PostBodyMarkdown from json.
func (s *PostBodyMarkdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostBodyMarkdown to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostBodyMarkdown(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PostBodyMarkdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostBodyMarkdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PostMisc) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s PostMisc) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPostMisc = [0]string{}

// Decode decodes PostMisc from json.
func (s *PostMisc) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostMisc to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PostMisc")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PostMisc) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostMisc) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ProfileReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s ProfileReference) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfProfileReference = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes ProfileReference from json.
func (s *ProfileReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProfileReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProfileReference")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProfileReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProfileReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s React) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s React) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Emoji.Set {
			e.FieldStart("emoji")
			s.Emoji.Encode(e)
		}
	}
}

var jsonFieldsNameOfReact = [2]string{
	0: "id",
	1: "emoji",
}

// Decode decodes React from json.
func (s *React) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode React to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "emoji":
			if err := func() error {
				s.Emoji.Reset()
				if err := s.Emoji.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode React")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s React) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *React) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Tag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Tag) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{

		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.Colour.Set {
			e.FieldStart("colour")
			s.Colour.Encode(e)
		}
	}
}

var jsonFieldsNameOfTag = [3]string{
	0: "id",
	1: "name",
	2: "colour",
}

// Decode decodes Tag from json.
func (s *Tag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "colour":
			if err := func() error {
				s.Colour.Reset()
				if err := s.Colour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"colour\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Tag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTag) {
					name = jsonFieldsNameOfTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Tag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TagList as json.
func (s TagList) Encode(e *jx.Encoder) {
	unwrapped := []Tag(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes TagList from json.
func (s *TagList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagList to nil")
	}
	var unwrapped []Tag
	if err := func() error {
		unwrapped = make([]Tag, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Tag
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TagList(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TagList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TagName as json.
func (s TagName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TagName from json.
func (s *TagName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TagName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TagName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ThreadReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s ThreadReference) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{

		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{

		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.DeletedAt.Set {
			e.FieldStart("deletedAt")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Misc != nil {
			e.FieldStart("misc")
			s.Misc.Encode(e)
		}
	}
	{

		e.FieldStart("title")
		e.Str(s.Title)
	}
	{

		e.FieldStart("slug")
		e.Str(s.Slug)
	}
	{

		e.FieldStart("short")
		e.Str(s.Short)
	}
	{

		e.FieldStart("pinned")
		e.Bool(s.Pinned)
	}
	{

		e.FieldStart("author")
		s.Author.Encode(e)
	}
	{

		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.PostCount.Set {
			e.FieldStart("post_count")
			s.PostCount.Encode(e)
		}
	}
	{

		e.FieldStart("category")
		s.Category.Encode(e)
	}
	{

		e.FieldStart("reacts")
		e.ArrStart()
		for _, elem := range s.Reacts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{

		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfThreadReference = [15]string{
	0:  "id",
	1:  "createdAt",
	2:  "updatedAt",
	3:  "deletedAt",
	4:  "misc",
	5:  "title",
	6:  "slug",
	7:  "short",
	8:  "pinned",
	9:  "author",
	10: "tags",
	11: "post_count",
	12: "category",
	13: "reacts",
	14: "meta",
}

// Decode decodes ThreadReference from json.
func (s *ThreadReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadReference to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "deletedAt":
			if err := func() error {
				s.DeletedAt.Reset()
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedAt\"")
			}
		case "misc":
			if err := func() error {
				s.Misc = nil
				var elem ThreadReferenceMisc
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Misc = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"misc\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "slug":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "short":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Short = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"short\"")
			}
		case "pinned":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Pinned = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinned\"")
			}
		case "author":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "tags":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "post_count":
			if err := func() error {
				s.PostCount.Reset()
				if err := s.PostCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"post_count\"")
			}
		case "category":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "reacts":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				s.Reacts = make([]React, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem React
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Reacts = append(s.Reacts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reacts\"")
			}
		case "meta":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThreadReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11100111,
		0b01110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThreadReference) {
					name = jsonFieldsNameOfThreadReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ThreadReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ThreadReferenceMisc) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s ThreadReferenceMisc) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfThreadReferenceMisc = [0]string{}

// Decode decodes ThreadReferenceMisc from json.
func (s *ThreadReferenceMisc) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadReferenceMisc to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThreadReferenceMisc")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ThreadReferenceMisc) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadReferenceMisc) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThreadsListOKApplicationJSON as json.
func (s ThreadsListOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ThreadReference(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ThreadsListOKApplicationJSON from json.
func (s *ThreadsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadsListOKApplicationJSON to nil")
	}
	var unwrapped []ThreadReference
	if err := func() error {
		unwrapped = make([]ThreadReference, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ThreadReference
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ThreadsListOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ThreadsListOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadsListOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebAuthnGetAssertionApplicationJSON as json.
func (s WebAuthnGetAssertionApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := AuthPasswordBody(s)

	unwrapped.Encode(e)
}

// Decode decodes WebAuthnGetAssertionApplicationJSON from json.
func (s *WebAuthnGetAssertionApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebAuthnGetAssertionApplicationJSON to nil")
	}
	var unwrapped AuthPasswordBody
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebAuthnGetAssertionApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebAuthnGetAssertionApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebAuthnGetAssertionApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebAuthnGetAssertionApplicationXWwwFormUrlencoded as json.
func (s WebAuthnGetAssertionApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := AuthPasswordBody(s)

	unwrapped.Encode(e)
}

// Decode decodes WebAuthnGetAssertionApplicationXWwwFormUrlencoded from json.
func (s *WebAuthnGetAssertionApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebAuthnGetAssertionApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped AuthPasswordBody
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebAuthnGetAssertionApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebAuthnGetAssertionApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebAuthnGetAssertionApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebAuthnMakeAssertionApplicationJSON as json.
func (s WebAuthnMakeAssertionApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := AuthPasswordBody(s)

	unwrapped.Encode(e)
}

// Decode decodes WebAuthnMakeAssertionApplicationJSON from json.
func (s *WebAuthnMakeAssertionApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebAuthnMakeAssertionApplicationJSON to nil")
	}
	var unwrapped AuthPasswordBody
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebAuthnMakeAssertionApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebAuthnMakeAssertionApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebAuthnMakeAssertionApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebAuthnMakeAssertionApplicationXWwwFormUrlencoded as json.
func (s WebAuthnMakeAssertionApplicationXWwwFormUrlencoded) Encode(e *jx.Encoder) {
	unwrapped := AuthPasswordBody(s)

	unwrapped.Encode(e)
}

// Decode decodes WebAuthnMakeAssertionApplicationXWwwFormUrlencoded from json.
func (s *WebAuthnMakeAssertionApplicationXWwwFormUrlencoded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebAuthnMakeAssertionApplicationXWwwFormUrlencoded to nil")
	}
	var unwrapped AuthPasswordBody
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebAuthnMakeAssertionApplicationXWwwFormUrlencoded(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebAuthnMakeAssertionApplicationXWwwFormUrlencoded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebAuthnMakeAssertionApplicationXWwwFormUrlencoded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s WebAuthnMakeCredentialReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s WebAuthnMakeCredentialReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfWebAuthnMakeCredentialReq = [0]string{}

// Decode decodes WebAuthnMakeCredentialReq from json.
func (s *WebAuthnMakeCredentialReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebAuthnMakeCredentialReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebAuthnMakeCredentialReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebAuthnMakeCredentialReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebAuthnMakeCredentialReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s WebAuthnPublicKeyCreationOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s WebAuthnPublicKeyCreationOptions) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfWebAuthnPublicKeyCreationOptions = [0]string{}

// Decode decodes WebAuthnPublicKeyCreationOptions from json.
func (s *WebAuthnPublicKeyCreationOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebAuthnPublicKeyCreationOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebAuthnPublicKeyCreationOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebAuthnPublicKeyCreationOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebAuthnPublicKeyCreationOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
