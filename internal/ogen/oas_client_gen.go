// Code generated by ogen, DO NOT EDIT.

package ogen

import (
	"context"
	"net/url"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AccountGet invokes AccountGet operation.
//
// Get the information for the currently authenticated account.
//
// GET /v1/accounts
func (c *Client) AccountGet(ctx context.Context) (AccountGetRes, error) {
	res, err := c.sendAccountGet(ctx)
	_ = res
	return res, err
}

func (c *Client) sendAccountGet(ctx context.Context) (res AccountGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AccountGet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccountGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/accounts"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Browser"
			switch err := c.securityBrowser(ctx, "AccountGet", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Browser\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountGetAvatar invokes AccountGetAvatar operation.
//
// Get an avatar for the specified account.
//
// GET /v1/accounts/{account_handle}/avatar
func (c *Client) AccountGetAvatar(ctx context.Context, params AccountGetAvatarParams) (AccountGetAvatarRes, error) {
	res, err := c.sendAccountGetAvatar(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendAccountGetAvatar(ctx context.Context, params AccountGetAvatarParams) (res AccountGetAvatarRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AccountGetAvatar"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccountGetAvatar",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/accounts/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.AccountHandle); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/avatar"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountGetAvatarResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountSetAvatar invokes AccountSetAvatar operation.
//
// Upload an avatar for the authenticated account.
//
// POST /v1/accounts/self/avatar
func (c *Client) AccountSetAvatar(ctx context.Context, request AccountSetAvatarReq) (AccountSetAvatarRes, error) {
	res, err := c.sendAccountSetAvatar(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendAccountSetAvatar(ctx context.Context, request AccountSetAvatarReq) (res AccountSetAvatarRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AccountSetAvatar"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccountSetAvatar",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/accounts/self/avatar"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccountSetAvatarRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Browser"
			switch err := c.securityBrowser(ctx, "AccountSetAvatar", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Browser\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountSetAvatarResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountUpdate invokes AccountUpdate operation.
//
// Update the information for the currently authenticated account.
//
// PATCH /v1/accounts
func (c *Client) AccountUpdate(ctx context.Context, request OptAccountMutableProps) (AccountUpdateRes, error) {
	res, err := c.sendAccountUpdate(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendAccountUpdate(ctx context.Context, request OptAccountMutableProps) (res AccountUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AccountUpdate"),
	}
	// Validate request before sending.
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccountUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/accounts"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccountUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Browser"
			switch err := c.securityBrowser(ctx, "AccountUpdate", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Browser\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthPasswordSignin invokes AuthPasswordSignin operation.
//
// Sign in to an existing account with a username and password.
//
// POST /v1/auth/password/signin
func (c *Client) AuthPasswordSignin(ctx context.Context, request OptAuthPair) (AuthPasswordSigninRes, error) {
	res, err := c.sendAuthPasswordSignin(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendAuthPasswordSignin(ctx context.Context, request OptAuthPair) (res AuthPasswordSigninRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AuthPasswordSignin"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AuthPasswordSignin",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/auth/password/signin"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthPasswordSigninRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAuthPasswordSigninResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthPasswordSignup invokes AuthPasswordSignup operation.
//
// Register a new account with a username and password.
//
// POST /v1/auth/password/signup
func (c *Client) AuthPasswordSignup(ctx context.Context, request OptAuthPair) (AuthPasswordSignupRes, error) {
	res, err := c.sendAuthPasswordSignup(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendAuthPasswordSignup(ctx context.Context, request OptAuthPair) (res AuthPasswordSignupRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AuthPasswordSignup"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AuthPasswordSignup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/auth/password/signup"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthPasswordSignupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAuthPasswordSignupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthProviderList invokes AuthProviderList operation.
//
// Retrieve a list of authentication providers. Storyden supports a few
// ways to authenticate, from simple passwords to OAuth and WebAuthn. This
// endpoint tells a client which auth capabilities are enabled.
//
// GET /v1/auth
func (c *Client) AuthProviderList(ctx context.Context) (AuthProviderListRes, error) {
	res, err := c.sendAuthProviderList(ctx)
	_ = res
	return res, err
}

func (c *Client) sendAuthProviderList(ctx context.Context) (res AuthProviderListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AuthProviderList"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AuthProviderList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/auth"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAuthProviderListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthProviderLogout invokes AuthProviderLogout operation.
//
// Remove cookies from requesting client.
//
// GET /v1/auth/logout
func (c *Client) AuthProviderLogout(ctx context.Context) (AuthProviderLogoutRes, error) {
	res, err := c.sendAuthProviderLogout(ctx)
	_ = res
	return res, err
}

func (c *Client) sendAuthProviderLogout(ctx context.Context) (res AuthProviderLogoutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AuthProviderLogout"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AuthProviderLogout",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/auth/logout"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Browser"
			switch err := c.securityBrowser(ctx, "AuthProviderLogout", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Browser\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAuthProviderLogoutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CategoriesList invokes CategoriesList operation.
//
// Get a list of all categories on the site.
//
// GET /v1/categories
func (c *Client) CategoriesList(ctx context.Context) (CategoriesListRes, error) {
	res, err := c.sendCategoriesList(ctx)
	_ = res
	return res, err
}

func (c *Client) sendCategoriesList(ctx context.Context) (res CategoriesListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("CategoriesList"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CategoriesList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/categories"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCategoriesListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpec invokes GetSpec operation.
//
// Note: the generator creates a `map[string]interface{}` if this is set to
// `application/json`... so I'm just using plain text for now.
//
// GET /openapi.json
func (c *Client) GetSpec(ctx context.Context) (GetSpecOK, error) {
	res, err := c.sendGetSpec(ctx)
	_ = res
	return res, err
}

func (c *Client) sendGetSpec(ctx context.Context) (res GetSpecOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetSpec"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSpec",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/openapi.json"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVersion invokes GetVersion operation.
//
// The version number includes the date and time of the release build as
// well as a short representation of the Git commit hash.
//
// GET /version
func (c *Client) GetVersion(ctx context.Context) (GetVersionOK, error) {
	res, err := c.sendGetVersion(ctx)
	_ = res
	return res, err
}

func (c *Client) sendGetVersion(ctx context.Context) (res GetVersionOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetVersion"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetVersion",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/version"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuthProviderCallback invokes OAuthProviderCallback operation.
//
// Sign in to an existing account with a username and password.
//
// POST /v1/auth/oauth/{oauth_provider}/callback
func (c *Client) OAuthProviderCallback(ctx context.Context, request OptOAuthCallback, params OAuthProviderCallbackParams) (OAuthProviderCallbackRes, error) {
	res, err := c.sendOAuthProviderCallback(ctx, request, params)
	_ = res
	return res, err
}

func (c *Client) sendOAuthProviderCallback(ctx context.Context, request OptOAuthCallback, params OAuthProviderCallbackParams) (res OAuthProviderCallbackRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OAuthProviderCallback"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OAuthProviderCallback",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/auth/oauth/"
	{
		// Encode "oauth_provider" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "oauth_provider",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OAuthProvider))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/callback"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOAuthProviderCallbackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOAuthProviderCallbackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostsCreate invokes PostsCreate operation.
//
// Create a new post within a thread.
//
// POST /v1/threads/{thread_mark}/posts
func (c *Client) PostsCreate(ctx context.Context, request OptPostInitialProps, params PostsCreateParams) (PostsCreateRes, error) {
	res, err := c.sendPostsCreate(ctx, request, params)
	_ = res
	return res, err
}

func (c *Client) sendPostsCreate(ctx context.Context, request OptPostInitialProps, params PostsCreateParams) (res PostsCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PostsCreate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostsCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/threads/"
	{
		// Encode "thread_mark" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_mark",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ThreadMark); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/posts"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostsCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Browser"
			switch err := c.securityBrowser(ctx, "PostsCreate", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Browser\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostsCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProfileGet invokes ProfileGet operation.
//
// Get a public profile by ID.
//
// GET /v1/profiles/{account_handle}
func (c *Client) ProfileGet(ctx context.Context, params ProfileGetParams) (ProfileGetRes, error) {
	res, err := c.sendProfileGet(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendProfileGet(ctx context.Context, params ProfileGetParams) (res ProfileGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ProfileGet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProfileGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/profiles/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.AccountHandle); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProfileGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ThreadsCreate invokes ThreadsCreate operation.
//
// Create a new thread within the specified category.
//
// POST /v1/threads
func (c *Client) ThreadsCreate(ctx context.Context, request OptThreadMutableProps) (ThreadsCreateRes, error) {
	res, err := c.sendThreadsCreate(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendThreadsCreate(ctx context.Context, request OptThreadMutableProps) (res ThreadsCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ThreadsCreate"),
	}
	// Validate request before sending.
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ThreadsCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/threads"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeThreadsCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Browser"
			switch err := c.securityBrowser(ctx, "ThreadsCreate", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Browser\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeThreadsCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ThreadsGet invokes ThreadsGet operation.
//
// Get information about a thread such as its title, author, when it was
// created as well as a list of the posts within the thread.
//
// GET /v1/threads/{thread_mark}
func (c *Client) ThreadsGet(ctx context.Context, params ThreadsGetParams) (ThreadsGetRes, error) {
	res, err := c.sendThreadsGet(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendThreadsGet(ctx context.Context, params ThreadsGetParams) (res ThreadsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ThreadsGet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ThreadsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/threads/"
	{
		// Encode "thread_mark" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "thread_mark",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ThreadMark); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeThreadsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ThreadsList invokes ThreadsList operation.
//
// Get a list of all threads.
//
// GET /v1/threads
func (c *Client) ThreadsList(ctx context.Context, params ThreadsListParams) (ThreadsListRes, error) {
	res, err := c.sendThreadsList(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendThreadsList(ctx context.Context, params ThreadsListParams) (res ThreadsListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ThreadsList"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ThreadsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/threads"

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "author" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "author",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Author.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Tags; v != nil {
				if unwrapped := []Identifier((*v)); true {
					return e.EncodeArray(func(e uri.Encoder) error {
						for i, item := range unwrapped {
							if err := func() error {
								if unwrapped := string(item); true {
									return e.EncodeValue(conv.StringToString(unwrapped))
								}
								return nil
							}(); err != nil {
								return errors.Wrapf(err, "[%d]", i)
							}
						}
						return nil
					})
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeThreadsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WebAuthnGetAssertion invokes WebAuthnGetAssertion operation.
//
// Start the WebAuthn assertion for an existing account.
//
// GET /v1/auth/webauthn/assert/{account_handle}
func (c *Client) WebAuthnGetAssertion(ctx context.Context, params WebAuthnGetAssertionParams) (WebAuthnGetAssertionRes, error) {
	res, err := c.sendWebAuthnGetAssertion(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendWebAuthnGetAssertion(ctx context.Context, params WebAuthnGetAssertionParams) (res WebAuthnGetAssertionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("WebAuthnGetAssertion"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "WebAuthnGetAssertion",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/auth/webauthn/assert/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.AccountHandle); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWebAuthnGetAssertionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WebAuthnMakeAssertion invokes WebAuthnMakeAssertion operation.
//
// Complete the credential assertion and sign in to an account.
//
// POST /v1/auth/webauthn/assert
func (c *Client) WebAuthnMakeAssertion(ctx context.Context, request OptPublicKeyCredential) (WebAuthnMakeAssertionRes, error) {
	res, err := c.sendWebAuthnMakeAssertion(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendWebAuthnMakeAssertion(ctx context.Context, request OptPublicKeyCredential) (res WebAuthnMakeAssertionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("WebAuthnMakeAssertion"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "WebAuthnMakeAssertion",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/auth/webauthn/assert"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeWebAuthnMakeAssertionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Webauthn"
			switch err := c.securityWebauthn(ctx, "WebAuthnMakeAssertion", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Webauthn\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWebAuthnMakeAssertionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WebAuthnMakeCredential invokes WebAuthnMakeCredential operation.
//
// Complete WebAuthn registration by creating a new credential.
//
// POST /v1/auth/webauthn/make
func (c *Client) WebAuthnMakeCredential(ctx context.Context, request OptPublicKeyCredential) (WebAuthnMakeCredentialRes, error) {
	res, err := c.sendWebAuthnMakeCredential(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendWebAuthnMakeCredential(ctx context.Context, request OptPublicKeyCredential) (res WebAuthnMakeCredentialRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("WebAuthnMakeCredential"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "WebAuthnMakeCredential",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/auth/webauthn/make"

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeWebAuthnMakeCredentialRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Webauthn"
			switch err := c.securityWebauthn(ctx, "WebAuthnMakeCredential", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Webauthn\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWebAuthnMakeCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WebAuthnRequestCredential invokes WebAuthnRequestCredential operation.
//
// Start the WebAuthn registration process by requesting a credential.
//
// GET /v1/auth/webauthn/make/{account_handle}
func (c *Client) WebAuthnRequestCredential(ctx context.Context, params WebAuthnRequestCredentialParams) (WebAuthnRequestCredentialRes, error) {
	res, err := c.sendWebAuthnRequestCredential(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendWebAuthnRequestCredential(ctx context.Context, params WebAuthnRequestCredentialParams) (res WebAuthnRequestCredentialRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("WebAuthnRequestCredential"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "WebAuthnRequestCredential",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	u.Path += "/v1/auth/webauthn/make/"
	{
		// Encode "account_handle" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_handle",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.AccountHandle); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWebAuthnRequestCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
