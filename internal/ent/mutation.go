// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Southclaws/lexorank"
	"github.com/Southclaws/storyden/internal/ent/account"
	"github.com/Southclaws/storyden/internal/ent/accountfollow"
	"github.com/Southclaws/storyden/internal/ent/accountroles"
	"github.com/Southclaws/storyden/internal/ent/asset"
	"github.com/Southclaws/storyden/internal/ent/auditlog"
	"github.com/Southclaws/storyden/internal/ent/authentication"
	"github.com/Southclaws/storyden/internal/ent/category"
	"github.com/Southclaws/storyden/internal/ent/collection"
	"github.com/Southclaws/storyden/internal/ent/collectionnode"
	"github.com/Southclaws/storyden/internal/ent/collectionpost"
	"github.com/Southclaws/storyden/internal/ent/email"
	"github.com/Southclaws/storyden/internal/ent/event"
	"github.com/Southclaws/storyden/internal/ent/eventparticipant"
	"github.com/Southclaws/storyden/internal/ent/invitation"
	"github.com/Southclaws/storyden/internal/ent/likepost"
	"github.com/Southclaws/storyden/internal/ent/link"
	"github.com/Southclaws/storyden/internal/ent/mentionprofile"
	"github.com/Southclaws/storyden/internal/ent/node"
	"github.com/Southclaws/storyden/internal/ent/notification"
	"github.com/Southclaws/storyden/internal/ent/post"
	"github.com/Southclaws/storyden/internal/ent/postread"
	"github.com/Southclaws/storyden/internal/ent/predicate"
	"github.com/Southclaws/storyden/internal/ent/property"
	"github.com/Southclaws/storyden/internal/ent/propertyschema"
	"github.com/Southclaws/storyden/internal/ent/propertyschemafield"
	"github.com/Southclaws/storyden/internal/ent/question"
	"github.com/Southclaws/storyden/internal/ent/react"
	"github.com/Southclaws/storyden/internal/ent/report"
	"github.com/Southclaws/storyden/internal/ent/robot"
	"github.com/Southclaws/storyden/internal/ent/robotsession"
	"github.com/Southclaws/storyden/internal/ent/robotsessionmessage"
	"github.com/Southclaws/storyden/internal/ent/role"
	"github.com/Southclaws/storyden/internal/ent/schema"
	"github.com/Southclaws/storyden/internal/ent/session"
	"github.com/Southclaws/storyden/internal/ent/setting"
	"github.com/Southclaws/storyden/internal/ent/tag"
	"github.com/rs/xid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount             = "Account"
	TypeAccountFollow       = "AccountFollow"
	TypeAccountRoles        = "AccountRoles"
	TypeAsset               = "Asset"
	TypeAuditLog            = "AuditLog"
	TypeAuthentication      = "Authentication"
	TypeCategory            = "Category"
	TypeCollection          = "Collection"
	TypeCollectionNode      = "CollectionNode"
	TypeCollectionPost      = "CollectionPost"
	TypeEmail               = "Email"
	TypeEvent               = "Event"
	TypeEventParticipant    = "EventParticipant"
	TypeInvitation          = "Invitation"
	TypeLikePost            = "LikePost"
	TypeLink                = "Link"
	TypeMentionProfile      = "MentionProfile"
	TypeNode                = "Node"
	TypeNotification        = "Notification"
	TypePost                = "Post"
	TypePostRead            = "PostRead"
	TypeProperty            = "Property"
	TypePropertySchema      = "PropertySchema"
	TypePropertySchemaField = "PropertySchemaField"
	TypeQuestion            = "Question"
	TypeReact               = "React"
	TypeReport              = "Report"
	TypeRobot               = "Robot"
	TypeRobotSession        = "RobotSession"
	TypeRobotSessionMessage = "RobotSessionMessage"
	TypeRole                = "Role"
	TypeSession             = "Session"
	TypeSetting             = "Setting"
	TypeTag                 = "Tag"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                             Op
	typ                            string
	id                             *xid.ID
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	indexed_at                     *time.Time
	handle                         *string
	name                           *string
	bio                            *string
	kind                           *account.Kind
	admin                          *bool
	links                          *[]schema.ExternalLink
	appendlinks                    []schema.ExternalLink
	metadata                       *map[string]interface{}
	clearedFields                  map[string]struct{}
	sessions                       map[xid.ID]struct{}
	removedsessions                map[xid.ID]struct{}
	clearedsessions                bool
	emails                         map[xid.ID]struct{}
	removedemails                  map[xid.ID]struct{}
	clearedemails                  bool
	notifications                  map[xid.ID]struct{}
	removednotifications           map[xid.ID]struct{}
	clearednotifications           bool
	triggered_notifications        map[xid.ID]struct{}
	removedtriggered_notifications map[xid.ID]struct{}
	clearedtriggered_notifications bool
	following                      map[xid.ID]struct{}
	removedfollowing               map[xid.ID]struct{}
	clearedfollowing               bool
	followed_by                    map[xid.ID]struct{}
	removedfollowed_by             map[xid.ID]struct{}
	clearedfollowed_by             bool
	invitations                    map[xid.ID]struct{}
	removedinvitations             map[xid.ID]struct{}
	clearedinvitations             bool
	invited_by                     *xid.ID
	clearedinvited_by              bool
	posts                          map[xid.ID]struct{}
	removedposts                   map[xid.ID]struct{}
	clearedposts                   bool
	questions                      map[xid.ID]struct{}
	removedquestions               map[xid.ID]struct{}
	clearedquestions               bool
	reacts                         map[xid.ID]struct{}
	removedreacts                  map[xid.ID]struct{}
	clearedreacts                  bool
	likes                          map[xid.ID]struct{}
	removedlikes                   map[xid.ID]struct{}
	clearedlikes                   bool
	mentions                       map[xid.ID]struct{}
	removedmentions                map[xid.ID]struct{}
	clearedmentions                bool
	roles                          map[xid.ID]struct{}
	removedroles                   map[xid.ID]struct{}
	clearedroles                   bool
	authentication                 map[xid.ID]struct{}
	removedauthentication          map[xid.ID]struct{}
	clearedauthentication          bool
	tags                           map[xid.ID]struct{}
	removedtags                    map[xid.ID]struct{}
	clearedtags                    bool
	collections                    map[xid.ID]struct{}
	removedcollections             map[xid.ID]struct{}
	clearedcollections             bool
	nodes                          map[xid.ID]struct{}
	removednodes                   map[xid.ID]struct{}
	clearednodes                   bool
	assets                         map[xid.ID]struct{}
	removedassets                  map[xid.ID]struct{}
	clearedassets                  bool
	events                         map[xid.ID]struct{}
	removedevents                  map[xid.ID]struct{}
	clearedevents                  bool
	post_reads                     map[xid.ID]struct{}
	removedpost_reads              map[xid.ID]struct{}
	clearedpost_reads              bool
	reports                        map[xid.ID]struct{}
	removedreports                 map[xid.ID]struct{}
	clearedreports                 bool
	handled_reports                map[xid.ID]struct{}
	removedhandled_reports         map[xid.ID]struct{}
	clearedhandled_reports         bool
	audit_logs                     map[xid.ID]struct{}
	removedaudit_logs              map[xid.ID]struct{}
	clearedaudit_logs              bool
	robots                         map[xid.ID]struct{}
	removedrobots                  map[xid.ID]struct{}
	clearedrobots                  bool
	robot_sessions                 map[xid.ID]struct{}
	removedrobot_sessions          map[xid.ID]struct{}
	clearedrobot_sessions          bool
	robot_messages                 map[xid.ID]struct{}
	removedrobot_messages          map[xid.ID]struct{}
	clearedrobot_messages          bool
	account_roles                  map[xid.ID]struct{}
	removedaccount_roles           map[xid.ID]struct{}
	clearedaccount_roles           bool
	done                           bool
	oldValue                       func(context.Context) (*Account, error)
	predicates                     []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id xid.ID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[account.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, account.FieldDeletedAt)
}

// SetIndexedAt sets the "indexed_at" field.
func (m *AccountMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *AccountMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *AccountMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[account.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *AccountMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *AccountMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, account.FieldIndexedAt)
}

// SetHandle sets the "handle" field.
func (m *AccountMutation) SetHandle(s string) {
	m.handle = &s
}

// Handle returns the value of the "handle" field in the mutation.
func (m *AccountMutation) Handle() (r string, exists bool) {
	v := m.handle
	if v == nil {
		return
	}
	return *v, true
}

// OldHandle returns the old "handle" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldHandle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandle: %w", err)
	}
	return oldValue.Handle, nil
}

// ResetHandle resets all changes to the "handle" field.
func (m *AccountMutation) ResetHandle() {
	m.handle = nil
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetBio sets the "bio" field.
func (m *AccountMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *AccountMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *AccountMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[account.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *AccountMutation) BioCleared() bool {
	_, ok := m.clearedFields[account.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *AccountMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, account.FieldBio)
}

// SetKind sets the "kind" field.
func (m *AccountMutation) SetKind(a account.Kind) {
	m.kind = &a
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AccountMutation) Kind() (r account.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldKind(ctx context.Context) (v account.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *AccountMutation) ResetKind() {
	m.kind = nil
}

// SetAdmin sets the "admin" field.
func (m *AccountMutation) SetAdmin(b bool) {
	m.admin = &b
}

// Admin returns the value of the "admin" field in the mutation.
func (m *AccountMutation) Admin() (r bool, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "admin" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "admin" field.
func (m *AccountMutation) ResetAdmin() {
	m.admin = nil
}

// SetLinks sets the "links" field.
func (m *AccountMutation) SetLinks(sl []schema.ExternalLink) {
	m.links = &sl
	m.appendlinks = nil
}

// Links returns the value of the "links" field in the mutation.
func (m *AccountMutation) Links() (r []schema.ExternalLink, exists bool) {
	v := m.links
	if v == nil {
		return
	}
	return *v, true
}

// OldLinks returns the old "links" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldLinks(ctx context.Context) (v []schema.ExternalLink, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinks: %w", err)
	}
	return oldValue.Links, nil
}

// AppendLinks adds sl to the "links" field.
func (m *AccountMutation) AppendLinks(sl []schema.ExternalLink) {
	m.appendlinks = append(m.appendlinks, sl...)
}

// AppendedLinks returns the list of values that were appended to the "links" field in this mutation.
func (m *AccountMutation) AppendedLinks() ([]schema.ExternalLink, bool) {
	if len(m.appendlinks) == 0 {
		return nil, false
	}
	return m.appendlinks, true
}

// ClearLinks clears the value of the "links" field.
func (m *AccountMutation) ClearLinks() {
	m.links = nil
	m.appendlinks = nil
	m.clearedFields[account.FieldLinks] = struct{}{}
}

// LinksCleared returns if the "links" field was cleared in this mutation.
func (m *AccountMutation) LinksCleared() bool {
	_, ok := m.clearedFields[account.FieldLinks]
	return ok
}

// ResetLinks resets all changes to the "links" field.
func (m *AccountMutation) ResetLinks() {
	m.links = nil
	m.appendlinks = nil
	delete(m.clearedFields, account.FieldLinks)
}

// SetMetadata sets the "metadata" field.
func (m *AccountMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AccountMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AccountMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[account.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AccountMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[account.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AccountMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, account.FieldMetadata)
}

// SetInvitedByID sets the "invited_by_id" field.
func (m *AccountMutation) SetInvitedByID(x xid.ID) {
	m.invited_by = &x
}

// InvitedByID returns the value of the "invited_by_id" field in the mutation.
func (m *AccountMutation) InvitedByID() (r xid.ID, exists bool) {
	v := m.invited_by
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitedByID returns the old "invited_by_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldInvitedByID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitedByID: %w", err)
	}
	return oldValue.InvitedByID, nil
}

// ClearInvitedByID clears the value of the "invited_by_id" field.
func (m *AccountMutation) ClearInvitedByID() {
	m.invited_by = nil
	m.clearedFields[account.FieldInvitedByID] = struct{}{}
}

// InvitedByIDCleared returns if the "invited_by_id" field was cleared in this mutation.
func (m *AccountMutation) InvitedByIDCleared() bool {
	_, ok := m.clearedFields[account.FieldInvitedByID]
	return ok
}

// ResetInvitedByID resets all changes to the "invited_by_id" field.
func (m *AccountMutation) ResetInvitedByID() {
	m.invited_by = nil
	delete(m.clearedFields, account.FieldInvitedByID)
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *AccountMutation) AddSessionIDs(ids ...xid.ID) {
	if m.sessions == nil {
		m.sessions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *AccountMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *AccountMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *AccountMutation) RemoveSessionIDs(ids ...xid.ID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *AccountMutation) RemovedSessionsIDs() (ids []xid.ID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *AccountMutation) SessionsIDs() (ids []xid.ID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *AccountMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddEmailIDs adds the "emails" edge to the Email entity by ids.
func (m *AccountMutation) AddEmailIDs(ids ...xid.ID) {
	if m.emails == nil {
		m.emails = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.emails[ids[i]] = struct{}{}
	}
}

// ClearEmails clears the "emails" edge to the Email entity.
func (m *AccountMutation) ClearEmails() {
	m.clearedemails = true
}

// EmailsCleared reports if the "emails" edge to the Email entity was cleared.
func (m *AccountMutation) EmailsCleared() bool {
	return m.clearedemails
}

// RemoveEmailIDs removes the "emails" edge to the Email entity by IDs.
func (m *AccountMutation) RemoveEmailIDs(ids ...xid.ID) {
	if m.removedemails == nil {
		m.removedemails = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.emails, ids[i])
		m.removedemails[ids[i]] = struct{}{}
	}
}

// RemovedEmails returns the removed IDs of the "emails" edge to the Email entity.
func (m *AccountMutation) RemovedEmailsIDs() (ids []xid.ID) {
	for id := range m.removedemails {
		ids = append(ids, id)
	}
	return
}

// EmailsIDs returns the "emails" edge IDs in the mutation.
func (m *AccountMutation) EmailsIDs() (ids []xid.ID) {
	for id := range m.emails {
		ids = append(ids, id)
	}
	return
}

// ResetEmails resets all changes to the "emails" edge.
func (m *AccountMutation) ResetEmails() {
	m.emails = nil
	m.clearedemails = false
	m.removedemails = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *AccountMutation) AddNotificationIDs(ids ...xid.ID) {
	if m.notifications == nil {
		m.notifications = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *AccountMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *AccountMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *AccountMutation) RemoveNotificationIDs(ids ...xid.ID) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *AccountMutation) RemovedNotificationsIDs() (ids []xid.ID) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *AccountMutation) NotificationsIDs() (ids []xid.ID) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *AccountMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddTriggeredNotificationIDs adds the "triggered_notifications" edge to the Notification entity by ids.
func (m *AccountMutation) AddTriggeredNotificationIDs(ids ...xid.ID) {
	if m.triggered_notifications == nil {
		m.triggered_notifications = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.triggered_notifications[ids[i]] = struct{}{}
	}
}

// ClearTriggeredNotifications clears the "triggered_notifications" edge to the Notification entity.
func (m *AccountMutation) ClearTriggeredNotifications() {
	m.clearedtriggered_notifications = true
}

// TriggeredNotificationsCleared reports if the "triggered_notifications" edge to the Notification entity was cleared.
func (m *AccountMutation) TriggeredNotificationsCleared() bool {
	return m.clearedtriggered_notifications
}

// RemoveTriggeredNotificationIDs removes the "triggered_notifications" edge to the Notification entity by IDs.
func (m *AccountMutation) RemoveTriggeredNotificationIDs(ids ...xid.ID) {
	if m.removedtriggered_notifications == nil {
		m.removedtriggered_notifications = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.triggered_notifications, ids[i])
		m.removedtriggered_notifications[ids[i]] = struct{}{}
	}
}

// RemovedTriggeredNotifications returns the removed IDs of the "triggered_notifications" edge to the Notification entity.
func (m *AccountMutation) RemovedTriggeredNotificationsIDs() (ids []xid.ID) {
	for id := range m.removedtriggered_notifications {
		ids = append(ids, id)
	}
	return
}

// TriggeredNotificationsIDs returns the "triggered_notifications" edge IDs in the mutation.
func (m *AccountMutation) TriggeredNotificationsIDs() (ids []xid.ID) {
	for id := range m.triggered_notifications {
		ids = append(ids, id)
	}
	return
}

// ResetTriggeredNotifications resets all changes to the "triggered_notifications" edge.
func (m *AccountMutation) ResetTriggeredNotifications() {
	m.triggered_notifications = nil
	m.clearedtriggered_notifications = false
	m.removedtriggered_notifications = nil
}

// AddFollowingIDs adds the "following" edge to the AccountFollow entity by ids.
func (m *AccountMutation) AddFollowingIDs(ids ...xid.ID) {
	if m.following == nil {
		m.following = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.following[ids[i]] = struct{}{}
	}
}

// ClearFollowing clears the "following" edge to the AccountFollow entity.
func (m *AccountMutation) ClearFollowing() {
	m.clearedfollowing = true
}

// FollowingCleared reports if the "following" edge to the AccountFollow entity was cleared.
func (m *AccountMutation) FollowingCleared() bool {
	return m.clearedfollowing
}

// RemoveFollowingIDs removes the "following" edge to the AccountFollow entity by IDs.
func (m *AccountMutation) RemoveFollowingIDs(ids ...xid.ID) {
	if m.removedfollowing == nil {
		m.removedfollowing = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.following, ids[i])
		m.removedfollowing[ids[i]] = struct{}{}
	}
}

// RemovedFollowing returns the removed IDs of the "following" edge to the AccountFollow entity.
func (m *AccountMutation) RemovedFollowingIDs() (ids []xid.ID) {
	for id := range m.removedfollowing {
		ids = append(ids, id)
	}
	return
}

// FollowingIDs returns the "following" edge IDs in the mutation.
func (m *AccountMutation) FollowingIDs() (ids []xid.ID) {
	for id := range m.following {
		ids = append(ids, id)
	}
	return
}

// ResetFollowing resets all changes to the "following" edge.
func (m *AccountMutation) ResetFollowing() {
	m.following = nil
	m.clearedfollowing = false
	m.removedfollowing = nil
}

// AddFollowedByIDs adds the "followed_by" edge to the AccountFollow entity by ids.
func (m *AccountMutation) AddFollowedByIDs(ids ...xid.ID) {
	if m.followed_by == nil {
		m.followed_by = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.followed_by[ids[i]] = struct{}{}
	}
}

// ClearFollowedBy clears the "followed_by" edge to the AccountFollow entity.
func (m *AccountMutation) ClearFollowedBy() {
	m.clearedfollowed_by = true
}

// FollowedByCleared reports if the "followed_by" edge to the AccountFollow entity was cleared.
func (m *AccountMutation) FollowedByCleared() bool {
	return m.clearedfollowed_by
}

// RemoveFollowedByIDs removes the "followed_by" edge to the AccountFollow entity by IDs.
func (m *AccountMutation) RemoveFollowedByIDs(ids ...xid.ID) {
	if m.removedfollowed_by == nil {
		m.removedfollowed_by = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.followed_by, ids[i])
		m.removedfollowed_by[ids[i]] = struct{}{}
	}
}

// RemovedFollowedBy returns the removed IDs of the "followed_by" edge to the AccountFollow entity.
func (m *AccountMutation) RemovedFollowedByIDs() (ids []xid.ID) {
	for id := range m.removedfollowed_by {
		ids = append(ids, id)
	}
	return
}

// FollowedByIDs returns the "followed_by" edge IDs in the mutation.
func (m *AccountMutation) FollowedByIDs() (ids []xid.ID) {
	for id := range m.followed_by {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedBy resets all changes to the "followed_by" edge.
func (m *AccountMutation) ResetFollowedBy() {
	m.followed_by = nil
	m.clearedfollowed_by = false
	m.removedfollowed_by = nil
}

// AddInvitationIDs adds the "invitations" edge to the Invitation entity by ids.
func (m *AccountMutation) AddInvitationIDs(ids ...xid.ID) {
	if m.invitations == nil {
		m.invitations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.invitations[ids[i]] = struct{}{}
	}
}

// ClearInvitations clears the "invitations" edge to the Invitation entity.
func (m *AccountMutation) ClearInvitations() {
	m.clearedinvitations = true
}

// InvitationsCleared reports if the "invitations" edge to the Invitation entity was cleared.
func (m *AccountMutation) InvitationsCleared() bool {
	return m.clearedinvitations
}

// RemoveInvitationIDs removes the "invitations" edge to the Invitation entity by IDs.
func (m *AccountMutation) RemoveInvitationIDs(ids ...xid.ID) {
	if m.removedinvitations == nil {
		m.removedinvitations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.invitations, ids[i])
		m.removedinvitations[ids[i]] = struct{}{}
	}
}

// RemovedInvitations returns the removed IDs of the "invitations" edge to the Invitation entity.
func (m *AccountMutation) RemovedInvitationsIDs() (ids []xid.ID) {
	for id := range m.removedinvitations {
		ids = append(ids, id)
	}
	return
}

// InvitationsIDs returns the "invitations" edge IDs in the mutation.
func (m *AccountMutation) InvitationsIDs() (ids []xid.ID) {
	for id := range m.invitations {
		ids = append(ids, id)
	}
	return
}

// ResetInvitations resets all changes to the "invitations" edge.
func (m *AccountMutation) ResetInvitations() {
	m.invitations = nil
	m.clearedinvitations = false
	m.removedinvitations = nil
}

// ClearInvitedBy clears the "invited_by" edge to the Invitation entity.
func (m *AccountMutation) ClearInvitedBy() {
	m.clearedinvited_by = true
	m.clearedFields[account.FieldInvitedByID] = struct{}{}
}

// InvitedByCleared reports if the "invited_by" edge to the Invitation entity was cleared.
func (m *AccountMutation) InvitedByCleared() bool {
	return m.InvitedByIDCleared() || m.clearedinvited_by
}

// InvitedByIDs returns the "invited_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvitedByID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) InvitedByIDs() (ids []xid.ID) {
	if id := m.invited_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitedBy resets all changes to the "invited_by" edge.
func (m *AccountMutation) ResetInvitedBy() {
	m.invited_by = nil
	m.clearedinvited_by = false
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *AccountMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *AccountMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *AccountMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *AccountMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *AccountMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *AccountMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *AccountMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddQuestionIDs adds the "questions" edge to the Question entity by ids.
func (m *AccountMutation) AddQuestionIDs(ids ...xid.ID) {
	if m.questions == nil {
		m.questions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// ClearQuestions clears the "questions" edge to the Question entity.
func (m *AccountMutation) ClearQuestions() {
	m.clearedquestions = true
}

// QuestionsCleared reports if the "questions" edge to the Question entity was cleared.
func (m *AccountMutation) QuestionsCleared() bool {
	return m.clearedquestions
}

// RemoveQuestionIDs removes the "questions" edge to the Question entity by IDs.
func (m *AccountMutation) RemoveQuestionIDs(ids ...xid.ID) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.questions, ids[i])
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed IDs of the "questions" edge to the Question entity.
func (m *AccountMutation) RemovedQuestionsIDs() (ids []xid.ID) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the "questions" edge IDs in the mutation.
func (m *AccountMutation) QuestionsIDs() (ids []xid.ID) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions resets all changes to the "questions" edge.
func (m *AccountMutation) ResetQuestions() {
	m.questions = nil
	m.clearedquestions = false
	m.removedquestions = nil
}

// AddReactIDs adds the "reacts" edge to the React entity by ids.
func (m *AccountMutation) AddReactIDs(ids ...xid.ID) {
	if m.reacts == nil {
		m.reacts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.reacts[ids[i]] = struct{}{}
	}
}

// ClearReacts clears the "reacts" edge to the React entity.
func (m *AccountMutation) ClearReacts() {
	m.clearedreacts = true
}

// ReactsCleared reports if the "reacts" edge to the React entity was cleared.
func (m *AccountMutation) ReactsCleared() bool {
	return m.clearedreacts
}

// RemoveReactIDs removes the "reacts" edge to the React entity by IDs.
func (m *AccountMutation) RemoveReactIDs(ids ...xid.ID) {
	if m.removedreacts == nil {
		m.removedreacts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.reacts, ids[i])
		m.removedreacts[ids[i]] = struct{}{}
	}
}

// RemovedReacts returns the removed IDs of the "reacts" edge to the React entity.
func (m *AccountMutation) RemovedReactsIDs() (ids []xid.ID) {
	for id := range m.removedreacts {
		ids = append(ids, id)
	}
	return
}

// ReactsIDs returns the "reacts" edge IDs in the mutation.
func (m *AccountMutation) ReactsIDs() (ids []xid.ID) {
	for id := range m.reacts {
		ids = append(ids, id)
	}
	return
}

// ResetReacts resets all changes to the "reacts" edge.
func (m *AccountMutation) ResetReacts() {
	m.reacts = nil
	m.clearedreacts = false
	m.removedreacts = nil
}

// AddLikeIDs adds the "likes" edge to the LikePost entity by ids.
func (m *AccountMutation) AddLikeIDs(ids ...xid.ID) {
	if m.likes == nil {
		m.likes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the LikePost entity.
func (m *AccountMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the LikePost entity was cleared.
func (m *AccountMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the LikePost entity by IDs.
func (m *AccountMutation) RemoveLikeIDs(ids ...xid.ID) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the LikePost entity.
func (m *AccountMutation) RemovedLikesIDs() (ids []xid.ID) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *AccountMutation) LikesIDs() (ids []xid.ID) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *AccountMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// AddMentionIDs adds the "mentions" edge to the MentionProfile entity by ids.
func (m *AccountMutation) AddMentionIDs(ids ...xid.ID) {
	if m.mentions == nil {
		m.mentions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.mentions[ids[i]] = struct{}{}
	}
}

// ClearMentions clears the "mentions" edge to the MentionProfile entity.
func (m *AccountMutation) ClearMentions() {
	m.clearedmentions = true
}

// MentionsCleared reports if the "mentions" edge to the MentionProfile entity was cleared.
func (m *AccountMutation) MentionsCleared() bool {
	return m.clearedmentions
}

// RemoveMentionIDs removes the "mentions" edge to the MentionProfile entity by IDs.
func (m *AccountMutation) RemoveMentionIDs(ids ...xid.ID) {
	if m.removedmentions == nil {
		m.removedmentions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.mentions, ids[i])
		m.removedmentions[ids[i]] = struct{}{}
	}
}

// RemovedMentions returns the removed IDs of the "mentions" edge to the MentionProfile entity.
func (m *AccountMutation) RemovedMentionsIDs() (ids []xid.ID) {
	for id := range m.removedmentions {
		ids = append(ids, id)
	}
	return
}

// MentionsIDs returns the "mentions" edge IDs in the mutation.
func (m *AccountMutation) MentionsIDs() (ids []xid.ID) {
	for id := range m.mentions {
		ids = append(ids, id)
	}
	return
}

// ResetMentions resets all changes to the "mentions" edge.
func (m *AccountMutation) ResetMentions() {
	m.mentions = nil
	m.clearedmentions = false
	m.removedmentions = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *AccountMutation) AddRoleIDs(ids ...xid.ID) {
	if m.roles == nil {
		m.roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *AccountMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *AccountMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *AccountMutation) RemoveRoleIDs(ids ...xid.ID) {
	if m.removedroles == nil {
		m.removedroles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *AccountMutation) RemovedRolesIDs() (ids []xid.ID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AccountMutation) RolesIDs() (ids []xid.ID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AccountMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddAuthenticationIDs adds the "authentication" edge to the Authentication entity by ids.
func (m *AccountMutation) AddAuthenticationIDs(ids ...xid.ID) {
	if m.authentication == nil {
		m.authentication = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.authentication[ids[i]] = struct{}{}
	}
}

// ClearAuthentication clears the "authentication" edge to the Authentication entity.
func (m *AccountMutation) ClearAuthentication() {
	m.clearedauthentication = true
}

// AuthenticationCleared reports if the "authentication" edge to the Authentication entity was cleared.
func (m *AccountMutation) AuthenticationCleared() bool {
	return m.clearedauthentication
}

// RemoveAuthenticationIDs removes the "authentication" edge to the Authentication entity by IDs.
func (m *AccountMutation) RemoveAuthenticationIDs(ids ...xid.ID) {
	if m.removedauthentication == nil {
		m.removedauthentication = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.authentication, ids[i])
		m.removedauthentication[ids[i]] = struct{}{}
	}
}

// RemovedAuthentication returns the removed IDs of the "authentication" edge to the Authentication entity.
func (m *AccountMutation) RemovedAuthenticationIDs() (ids []xid.ID) {
	for id := range m.removedauthentication {
		ids = append(ids, id)
	}
	return
}

// AuthenticationIDs returns the "authentication" edge IDs in the mutation.
func (m *AccountMutation) AuthenticationIDs() (ids []xid.ID) {
	for id := range m.authentication {
		ids = append(ids, id)
	}
	return
}

// ResetAuthentication resets all changes to the "authentication" edge.
func (m *AccountMutation) ResetAuthentication() {
	m.authentication = nil
	m.clearedauthentication = false
	m.removedauthentication = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *AccountMutation) AddTagIDs(ids ...xid.ID) {
	if m.tags == nil {
		m.tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *AccountMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *AccountMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *AccountMutation) RemoveTagIDs(ids ...xid.ID) {
	if m.removedtags == nil {
		m.removedtags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *AccountMutation) RemovedTagsIDs() (ids []xid.ID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *AccountMutation) TagsIDs() (ids []xid.ID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *AccountMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddCollectionIDs adds the "collections" edge to the Collection entity by ids.
func (m *AccountMutation) AddCollectionIDs(ids ...xid.ID) {
	if m.collections == nil {
		m.collections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.collections[ids[i]] = struct{}{}
	}
}

// ClearCollections clears the "collections" edge to the Collection entity.
func (m *AccountMutation) ClearCollections() {
	m.clearedcollections = true
}

// CollectionsCleared reports if the "collections" edge to the Collection entity was cleared.
func (m *AccountMutation) CollectionsCleared() bool {
	return m.clearedcollections
}

// RemoveCollectionIDs removes the "collections" edge to the Collection entity by IDs.
func (m *AccountMutation) RemoveCollectionIDs(ids ...xid.ID) {
	if m.removedcollections == nil {
		m.removedcollections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.collections, ids[i])
		m.removedcollections[ids[i]] = struct{}{}
	}
}

// RemovedCollections returns the removed IDs of the "collections" edge to the Collection entity.
func (m *AccountMutation) RemovedCollectionsIDs() (ids []xid.ID) {
	for id := range m.removedcollections {
		ids = append(ids, id)
	}
	return
}

// CollectionsIDs returns the "collections" edge IDs in the mutation.
func (m *AccountMutation) CollectionsIDs() (ids []xid.ID) {
	for id := range m.collections {
		ids = append(ids, id)
	}
	return
}

// ResetCollections resets all changes to the "collections" edge.
func (m *AccountMutation) ResetCollections() {
	m.collections = nil
	m.clearedcollections = false
	m.removedcollections = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *AccountMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *AccountMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *AccountMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *AccountMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *AccountMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *AccountMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *AccountMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *AccountMutation) AddAssetIDs(ids ...xid.ID) {
	if m.assets == nil {
		m.assets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *AccountMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *AccountMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *AccountMutation) RemoveAssetIDs(ids ...xid.ID) {
	if m.removedassets == nil {
		m.removedassets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *AccountMutation) RemovedAssetsIDs() (ids []xid.ID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *AccountMutation) AssetsIDs() (ids []xid.ID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *AccountMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// AddEventIDs adds the "events" edge to the EventParticipant entity by ids.
func (m *AccountMutation) AddEventIDs(ids ...xid.ID) {
	if m.events == nil {
		m.events = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the EventParticipant entity.
func (m *AccountMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the EventParticipant entity was cleared.
func (m *AccountMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the EventParticipant entity by IDs.
func (m *AccountMutation) RemoveEventIDs(ids ...xid.ID) {
	if m.removedevents == nil {
		m.removedevents = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the EventParticipant entity.
func (m *AccountMutation) RemovedEventsIDs() (ids []xid.ID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *AccountMutation) EventsIDs() (ids []xid.ID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *AccountMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddPostReadIDs adds the "post_reads" edge to the PostRead entity by ids.
func (m *AccountMutation) AddPostReadIDs(ids ...xid.ID) {
	if m.post_reads == nil {
		m.post_reads = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.post_reads[ids[i]] = struct{}{}
	}
}

// ClearPostReads clears the "post_reads" edge to the PostRead entity.
func (m *AccountMutation) ClearPostReads() {
	m.clearedpost_reads = true
}

// PostReadsCleared reports if the "post_reads" edge to the PostRead entity was cleared.
func (m *AccountMutation) PostReadsCleared() bool {
	return m.clearedpost_reads
}

// RemovePostReadIDs removes the "post_reads" edge to the PostRead entity by IDs.
func (m *AccountMutation) RemovePostReadIDs(ids ...xid.ID) {
	if m.removedpost_reads == nil {
		m.removedpost_reads = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.post_reads, ids[i])
		m.removedpost_reads[ids[i]] = struct{}{}
	}
}

// RemovedPostReads returns the removed IDs of the "post_reads" edge to the PostRead entity.
func (m *AccountMutation) RemovedPostReadsIDs() (ids []xid.ID) {
	for id := range m.removedpost_reads {
		ids = append(ids, id)
	}
	return
}

// PostReadsIDs returns the "post_reads" edge IDs in the mutation.
func (m *AccountMutation) PostReadsIDs() (ids []xid.ID) {
	for id := range m.post_reads {
		ids = append(ids, id)
	}
	return
}

// ResetPostReads resets all changes to the "post_reads" edge.
func (m *AccountMutation) ResetPostReads() {
	m.post_reads = nil
	m.clearedpost_reads = false
	m.removedpost_reads = nil
}

// AddReportIDs adds the "reports" edge to the Report entity by ids.
func (m *AccountMutation) AddReportIDs(ids ...xid.ID) {
	if m.reports == nil {
		m.reports = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.reports[ids[i]] = struct{}{}
	}
}

// ClearReports clears the "reports" edge to the Report entity.
func (m *AccountMutation) ClearReports() {
	m.clearedreports = true
}

// ReportsCleared reports if the "reports" edge to the Report entity was cleared.
func (m *AccountMutation) ReportsCleared() bool {
	return m.clearedreports
}

// RemoveReportIDs removes the "reports" edge to the Report entity by IDs.
func (m *AccountMutation) RemoveReportIDs(ids ...xid.ID) {
	if m.removedreports == nil {
		m.removedreports = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.reports, ids[i])
		m.removedreports[ids[i]] = struct{}{}
	}
}

// RemovedReports returns the removed IDs of the "reports" edge to the Report entity.
func (m *AccountMutation) RemovedReportsIDs() (ids []xid.ID) {
	for id := range m.removedreports {
		ids = append(ids, id)
	}
	return
}

// ReportsIDs returns the "reports" edge IDs in the mutation.
func (m *AccountMutation) ReportsIDs() (ids []xid.ID) {
	for id := range m.reports {
		ids = append(ids, id)
	}
	return
}

// ResetReports resets all changes to the "reports" edge.
func (m *AccountMutation) ResetReports() {
	m.reports = nil
	m.clearedreports = false
	m.removedreports = nil
}

// AddHandledReportIDs adds the "handled_reports" edge to the Report entity by ids.
func (m *AccountMutation) AddHandledReportIDs(ids ...xid.ID) {
	if m.handled_reports == nil {
		m.handled_reports = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.handled_reports[ids[i]] = struct{}{}
	}
}

// ClearHandledReports clears the "handled_reports" edge to the Report entity.
func (m *AccountMutation) ClearHandledReports() {
	m.clearedhandled_reports = true
}

// HandledReportsCleared reports if the "handled_reports" edge to the Report entity was cleared.
func (m *AccountMutation) HandledReportsCleared() bool {
	return m.clearedhandled_reports
}

// RemoveHandledReportIDs removes the "handled_reports" edge to the Report entity by IDs.
func (m *AccountMutation) RemoveHandledReportIDs(ids ...xid.ID) {
	if m.removedhandled_reports == nil {
		m.removedhandled_reports = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.handled_reports, ids[i])
		m.removedhandled_reports[ids[i]] = struct{}{}
	}
}

// RemovedHandledReports returns the removed IDs of the "handled_reports" edge to the Report entity.
func (m *AccountMutation) RemovedHandledReportsIDs() (ids []xid.ID) {
	for id := range m.removedhandled_reports {
		ids = append(ids, id)
	}
	return
}

// HandledReportsIDs returns the "handled_reports" edge IDs in the mutation.
func (m *AccountMutation) HandledReportsIDs() (ids []xid.ID) {
	for id := range m.handled_reports {
		ids = append(ids, id)
	}
	return
}

// ResetHandledReports resets all changes to the "handled_reports" edge.
func (m *AccountMutation) ResetHandledReports() {
	m.handled_reports = nil
	m.clearedhandled_reports = false
	m.removedhandled_reports = nil
}

// AddAuditLogIDs adds the "audit_logs" edge to the AuditLog entity by ids.
func (m *AccountMutation) AddAuditLogIDs(ids ...xid.ID) {
	if m.audit_logs == nil {
		m.audit_logs = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.audit_logs[ids[i]] = struct{}{}
	}
}

// ClearAuditLogs clears the "audit_logs" edge to the AuditLog entity.
func (m *AccountMutation) ClearAuditLogs() {
	m.clearedaudit_logs = true
}

// AuditLogsCleared reports if the "audit_logs" edge to the AuditLog entity was cleared.
func (m *AccountMutation) AuditLogsCleared() bool {
	return m.clearedaudit_logs
}

// RemoveAuditLogIDs removes the "audit_logs" edge to the AuditLog entity by IDs.
func (m *AccountMutation) RemoveAuditLogIDs(ids ...xid.ID) {
	if m.removedaudit_logs == nil {
		m.removedaudit_logs = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.audit_logs, ids[i])
		m.removedaudit_logs[ids[i]] = struct{}{}
	}
}

// RemovedAuditLogs returns the removed IDs of the "audit_logs" edge to the AuditLog entity.
func (m *AccountMutation) RemovedAuditLogsIDs() (ids []xid.ID) {
	for id := range m.removedaudit_logs {
		ids = append(ids, id)
	}
	return
}

// AuditLogsIDs returns the "audit_logs" edge IDs in the mutation.
func (m *AccountMutation) AuditLogsIDs() (ids []xid.ID) {
	for id := range m.audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAuditLogs resets all changes to the "audit_logs" edge.
func (m *AccountMutation) ResetAuditLogs() {
	m.audit_logs = nil
	m.clearedaudit_logs = false
	m.removedaudit_logs = nil
}

// AddRobotIDs adds the "robots" edge to the Robot entity by ids.
func (m *AccountMutation) AddRobotIDs(ids ...xid.ID) {
	if m.robots == nil {
		m.robots = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.robots[ids[i]] = struct{}{}
	}
}

// ClearRobots clears the "robots" edge to the Robot entity.
func (m *AccountMutation) ClearRobots() {
	m.clearedrobots = true
}

// RobotsCleared reports if the "robots" edge to the Robot entity was cleared.
func (m *AccountMutation) RobotsCleared() bool {
	return m.clearedrobots
}

// RemoveRobotIDs removes the "robots" edge to the Robot entity by IDs.
func (m *AccountMutation) RemoveRobotIDs(ids ...xid.ID) {
	if m.removedrobots == nil {
		m.removedrobots = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.robots, ids[i])
		m.removedrobots[ids[i]] = struct{}{}
	}
}

// RemovedRobots returns the removed IDs of the "robots" edge to the Robot entity.
func (m *AccountMutation) RemovedRobotsIDs() (ids []xid.ID) {
	for id := range m.removedrobots {
		ids = append(ids, id)
	}
	return
}

// RobotsIDs returns the "robots" edge IDs in the mutation.
func (m *AccountMutation) RobotsIDs() (ids []xid.ID) {
	for id := range m.robots {
		ids = append(ids, id)
	}
	return
}

// ResetRobots resets all changes to the "robots" edge.
func (m *AccountMutation) ResetRobots() {
	m.robots = nil
	m.clearedrobots = false
	m.removedrobots = nil
}

// AddRobotSessionIDs adds the "robot_sessions" edge to the RobotSession entity by ids.
func (m *AccountMutation) AddRobotSessionIDs(ids ...xid.ID) {
	if m.robot_sessions == nil {
		m.robot_sessions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.robot_sessions[ids[i]] = struct{}{}
	}
}

// ClearRobotSessions clears the "robot_sessions" edge to the RobotSession entity.
func (m *AccountMutation) ClearRobotSessions() {
	m.clearedrobot_sessions = true
}

// RobotSessionsCleared reports if the "robot_sessions" edge to the RobotSession entity was cleared.
func (m *AccountMutation) RobotSessionsCleared() bool {
	return m.clearedrobot_sessions
}

// RemoveRobotSessionIDs removes the "robot_sessions" edge to the RobotSession entity by IDs.
func (m *AccountMutation) RemoveRobotSessionIDs(ids ...xid.ID) {
	if m.removedrobot_sessions == nil {
		m.removedrobot_sessions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.robot_sessions, ids[i])
		m.removedrobot_sessions[ids[i]] = struct{}{}
	}
}

// RemovedRobotSessions returns the removed IDs of the "robot_sessions" edge to the RobotSession entity.
func (m *AccountMutation) RemovedRobotSessionsIDs() (ids []xid.ID) {
	for id := range m.removedrobot_sessions {
		ids = append(ids, id)
	}
	return
}

// RobotSessionsIDs returns the "robot_sessions" edge IDs in the mutation.
func (m *AccountMutation) RobotSessionsIDs() (ids []xid.ID) {
	for id := range m.robot_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetRobotSessions resets all changes to the "robot_sessions" edge.
func (m *AccountMutation) ResetRobotSessions() {
	m.robot_sessions = nil
	m.clearedrobot_sessions = false
	m.removedrobot_sessions = nil
}

// AddRobotMessageIDs adds the "robot_messages" edge to the RobotSessionMessage entity by ids.
func (m *AccountMutation) AddRobotMessageIDs(ids ...xid.ID) {
	if m.robot_messages == nil {
		m.robot_messages = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.robot_messages[ids[i]] = struct{}{}
	}
}

// ClearRobotMessages clears the "robot_messages" edge to the RobotSessionMessage entity.
func (m *AccountMutation) ClearRobotMessages() {
	m.clearedrobot_messages = true
}

// RobotMessagesCleared reports if the "robot_messages" edge to the RobotSessionMessage entity was cleared.
func (m *AccountMutation) RobotMessagesCleared() bool {
	return m.clearedrobot_messages
}

// RemoveRobotMessageIDs removes the "robot_messages" edge to the RobotSessionMessage entity by IDs.
func (m *AccountMutation) RemoveRobotMessageIDs(ids ...xid.ID) {
	if m.removedrobot_messages == nil {
		m.removedrobot_messages = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.robot_messages, ids[i])
		m.removedrobot_messages[ids[i]] = struct{}{}
	}
}

// RemovedRobotMessages returns the removed IDs of the "robot_messages" edge to the RobotSessionMessage entity.
func (m *AccountMutation) RemovedRobotMessagesIDs() (ids []xid.ID) {
	for id := range m.removedrobot_messages {
		ids = append(ids, id)
	}
	return
}

// RobotMessagesIDs returns the "robot_messages" edge IDs in the mutation.
func (m *AccountMutation) RobotMessagesIDs() (ids []xid.ID) {
	for id := range m.robot_messages {
		ids = append(ids, id)
	}
	return
}

// ResetRobotMessages resets all changes to the "robot_messages" edge.
func (m *AccountMutation) ResetRobotMessages() {
	m.robot_messages = nil
	m.clearedrobot_messages = false
	m.removedrobot_messages = nil
}

// AddAccountRoleIDs adds the "account_roles" edge to the AccountRoles entity by ids.
func (m *AccountMutation) AddAccountRoleIDs(ids ...xid.ID) {
	if m.account_roles == nil {
		m.account_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.account_roles[ids[i]] = struct{}{}
	}
}

// ClearAccountRoles clears the "account_roles" edge to the AccountRoles entity.
func (m *AccountMutation) ClearAccountRoles() {
	m.clearedaccount_roles = true
}

// AccountRolesCleared reports if the "account_roles" edge to the AccountRoles entity was cleared.
func (m *AccountMutation) AccountRolesCleared() bool {
	return m.clearedaccount_roles
}

// RemoveAccountRoleIDs removes the "account_roles" edge to the AccountRoles entity by IDs.
func (m *AccountMutation) RemoveAccountRoleIDs(ids ...xid.ID) {
	if m.removedaccount_roles == nil {
		m.removedaccount_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.account_roles, ids[i])
		m.removedaccount_roles[ids[i]] = struct{}{}
	}
}

// RemovedAccountRoles returns the removed IDs of the "account_roles" edge to the AccountRoles entity.
func (m *AccountMutation) RemovedAccountRolesIDs() (ids []xid.ID) {
	for id := range m.removedaccount_roles {
		ids = append(ids, id)
	}
	return
}

// AccountRolesIDs returns the "account_roles" edge IDs in the mutation.
func (m *AccountMutation) AccountRolesIDs() (ids []xid.ID) {
	for id := range m.account_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAccountRoles resets all changes to the "account_roles" edge.
func (m *AccountMutation) ResetAccountRoles() {
	m.account_roles = nil
	m.clearedaccount_roles = false
	m.removedaccount_roles = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, account.FieldIndexedAt)
	}
	if m.handle != nil {
		fields = append(fields, account.FieldHandle)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.bio != nil {
		fields = append(fields, account.FieldBio)
	}
	if m.kind != nil {
		fields = append(fields, account.FieldKind)
	}
	if m.admin != nil {
		fields = append(fields, account.FieldAdmin)
	}
	if m.links != nil {
		fields = append(fields, account.FieldLinks)
	}
	if m.metadata != nil {
		fields = append(fields, account.FieldMetadata)
	}
	if m.invited_by != nil {
		fields = append(fields, account.FieldInvitedByID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldDeletedAt:
		return m.DeletedAt()
	case account.FieldIndexedAt:
		return m.IndexedAt()
	case account.FieldHandle:
		return m.Handle()
	case account.FieldName:
		return m.Name()
	case account.FieldBio:
		return m.Bio()
	case account.FieldKind:
		return m.Kind()
	case account.FieldAdmin:
		return m.Admin()
	case account.FieldLinks:
		return m.Links()
	case account.FieldMetadata:
		return m.Metadata()
	case account.FieldInvitedByID:
		return m.InvitedByID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case account.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case account.FieldHandle:
		return m.OldHandle(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldBio:
		return m.OldBio(ctx)
	case account.FieldKind:
		return m.OldKind(ctx)
	case account.FieldAdmin:
		return m.OldAdmin(ctx)
	case account.FieldLinks:
		return m.OldLinks(ctx)
	case account.FieldMetadata:
		return m.OldMetadata(ctx)
	case account.FieldInvitedByID:
		return m.OldInvitedByID(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case account.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case account.FieldHandle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandle(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case account.FieldKind:
		v, ok := value.(account.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case account.FieldAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	case account.FieldLinks:
		v, ok := value.([]schema.ExternalLink)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinks(v)
		return nil
	case account.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case account.FieldInvitedByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitedByID(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldDeletedAt) {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.FieldCleared(account.FieldIndexedAt) {
		fields = append(fields, account.FieldIndexedAt)
	}
	if m.FieldCleared(account.FieldBio) {
		fields = append(fields, account.FieldBio)
	}
	if m.FieldCleared(account.FieldLinks) {
		fields = append(fields, account.FieldLinks)
	}
	if m.FieldCleared(account.FieldMetadata) {
		fields = append(fields, account.FieldMetadata)
	}
	if m.FieldCleared(account.FieldInvitedByID) {
		fields = append(fields, account.FieldInvitedByID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case account.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case account.FieldBio:
		m.ClearBio()
		return nil
	case account.FieldLinks:
		m.ClearLinks()
		return nil
	case account.FieldMetadata:
		m.ClearMetadata()
		return nil
	case account.FieldInvitedByID:
		m.ClearInvitedByID()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case account.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case account.FieldHandle:
		m.ResetHandle()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldBio:
		m.ResetBio()
		return nil
	case account.FieldKind:
		m.ResetKind()
		return nil
	case account.FieldAdmin:
		m.ResetAdmin()
		return nil
	case account.FieldLinks:
		m.ResetLinks()
		return nil
	case account.FieldMetadata:
		m.ResetMetadata()
		return nil
	case account.FieldInvitedByID:
		m.ResetInvitedByID()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 28)
	if m.sessions != nil {
		edges = append(edges, account.EdgeSessions)
	}
	if m.emails != nil {
		edges = append(edges, account.EdgeEmails)
	}
	if m.notifications != nil {
		edges = append(edges, account.EdgeNotifications)
	}
	if m.triggered_notifications != nil {
		edges = append(edges, account.EdgeTriggeredNotifications)
	}
	if m.following != nil {
		edges = append(edges, account.EdgeFollowing)
	}
	if m.followed_by != nil {
		edges = append(edges, account.EdgeFollowedBy)
	}
	if m.invitations != nil {
		edges = append(edges, account.EdgeInvitations)
	}
	if m.invited_by != nil {
		edges = append(edges, account.EdgeInvitedBy)
	}
	if m.posts != nil {
		edges = append(edges, account.EdgePosts)
	}
	if m.questions != nil {
		edges = append(edges, account.EdgeQuestions)
	}
	if m.reacts != nil {
		edges = append(edges, account.EdgeReacts)
	}
	if m.likes != nil {
		edges = append(edges, account.EdgeLikes)
	}
	if m.mentions != nil {
		edges = append(edges, account.EdgeMentions)
	}
	if m.roles != nil {
		edges = append(edges, account.EdgeRoles)
	}
	if m.authentication != nil {
		edges = append(edges, account.EdgeAuthentication)
	}
	if m.tags != nil {
		edges = append(edges, account.EdgeTags)
	}
	if m.collections != nil {
		edges = append(edges, account.EdgeCollections)
	}
	if m.nodes != nil {
		edges = append(edges, account.EdgeNodes)
	}
	if m.assets != nil {
		edges = append(edges, account.EdgeAssets)
	}
	if m.events != nil {
		edges = append(edges, account.EdgeEvents)
	}
	if m.post_reads != nil {
		edges = append(edges, account.EdgePostReads)
	}
	if m.reports != nil {
		edges = append(edges, account.EdgeReports)
	}
	if m.handled_reports != nil {
		edges = append(edges, account.EdgeHandledReports)
	}
	if m.audit_logs != nil {
		edges = append(edges, account.EdgeAuditLogs)
	}
	if m.robots != nil {
		edges = append(edges, account.EdgeRobots)
	}
	if m.robot_sessions != nil {
		edges = append(edges, account.EdgeRobotSessions)
	}
	if m.robot_messages != nil {
		edges = append(edges, account.EdgeRobotMessages)
	}
	if m.account_roles != nil {
		edges = append(edges, account.EdgeAccountRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeEmails:
		ids := make([]ent.Value, 0, len(m.emails))
		for id := range m.emails {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTriggeredNotifications:
		ids := make([]ent.Value, 0, len(m.triggered_notifications))
		for id := range m.triggered_notifications {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.following))
		for id := range m.following {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeFollowedBy:
		ids := make([]ent.Value, 0, len(m.followed_by))
		for id := range m.followed_by {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.invitations))
		for id := range m.invitations {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInvitedBy:
		if id := m.invited_by; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.reacts))
		for id := range m.reacts {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeMentions:
		ids := make([]ent.Value, 0, len(m.mentions))
		for id := range m.mentions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAuthentication:
		ids := make([]ent.Value, 0, len(m.authentication))
		for id := range m.authentication {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.collections))
		for id := range m.collections {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case account.EdgePostReads:
		ids := make([]ent.Value, 0, len(m.post_reads))
		for id := range m.post_reads {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeReports:
		ids := make([]ent.Value, 0, len(m.reports))
		for id := range m.reports {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeHandledReports:
		ids := make([]ent.Value, 0, len(m.handled_reports))
		for id := range m.handled_reports {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.audit_logs))
		for id := range m.audit_logs {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRobots:
		ids := make([]ent.Value, 0, len(m.robots))
		for id := range m.robots {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRobotSessions:
		ids := make([]ent.Value, 0, len(m.robot_sessions))
		for id := range m.robot_sessions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRobotMessages:
		ids := make([]ent.Value, 0, len(m.robot_messages))
		for id := range m.robot_messages {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAccountRoles:
		ids := make([]ent.Value, 0, len(m.account_roles))
		for id := range m.account_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 28)
	if m.removedsessions != nil {
		edges = append(edges, account.EdgeSessions)
	}
	if m.removedemails != nil {
		edges = append(edges, account.EdgeEmails)
	}
	if m.removednotifications != nil {
		edges = append(edges, account.EdgeNotifications)
	}
	if m.removedtriggered_notifications != nil {
		edges = append(edges, account.EdgeTriggeredNotifications)
	}
	if m.removedfollowing != nil {
		edges = append(edges, account.EdgeFollowing)
	}
	if m.removedfollowed_by != nil {
		edges = append(edges, account.EdgeFollowedBy)
	}
	if m.removedinvitations != nil {
		edges = append(edges, account.EdgeInvitations)
	}
	if m.removedposts != nil {
		edges = append(edges, account.EdgePosts)
	}
	if m.removedquestions != nil {
		edges = append(edges, account.EdgeQuestions)
	}
	if m.removedreacts != nil {
		edges = append(edges, account.EdgeReacts)
	}
	if m.removedlikes != nil {
		edges = append(edges, account.EdgeLikes)
	}
	if m.removedmentions != nil {
		edges = append(edges, account.EdgeMentions)
	}
	if m.removedroles != nil {
		edges = append(edges, account.EdgeRoles)
	}
	if m.removedauthentication != nil {
		edges = append(edges, account.EdgeAuthentication)
	}
	if m.removedtags != nil {
		edges = append(edges, account.EdgeTags)
	}
	if m.removedcollections != nil {
		edges = append(edges, account.EdgeCollections)
	}
	if m.removednodes != nil {
		edges = append(edges, account.EdgeNodes)
	}
	if m.removedassets != nil {
		edges = append(edges, account.EdgeAssets)
	}
	if m.removedevents != nil {
		edges = append(edges, account.EdgeEvents)
	}
	if m.removedpost_reads != nil {
		edges = append(edges, account.EdgePostReads)
	}
	if m.removedreports != nil {
		edges = append(edges, account.EdgeReports)
	}
	if m.removedhandled_reports != nil {
		edges = append(edges, account.EdgeHandledReports)
	}
	if m.removedaudit_logs != nil {
		edges = append(edges, account.EdgeAuditLogs)
	}
	if m.removedrobots != nil {
		edges = append(edges, account.EdgeRobots)
	}
	if m.removedrobot_sessions != nil {
		edges = append(edges, account.EdgeRobotSessions)
	}
	if m.removedrobot_messages != nil {
		edges = append(edges, account.EdgeRobotMessages)
	}
	if m.removedaccount_roles != nil {
		edges = append(edges, account.EdgeAccountRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeEmails:
		ids := make([]ent.Value, 0, len(m.removedemails))
		for id := range m.removedemails {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTriggeredNotifications:
		ids := make([]ent.Value, 0, len(m.removedtriggered_notifications))
		for id := range m.removedtriggered_notifications {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.removedfollowing))
		for id := range m.removedfollowing {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeFollowedBy:
		ids := make([]ent.Value, 0, len(m.removedfollowed_by))
		for id := range m.removedfollowed_by {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.removedinvitations))
		for id := range m.removedinvitations {
			ids = append(ids, id)
		}
		return ids
	case account.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.removedreacts))
		for id := range m.removedreacts {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeMentions:
		ids := make([]ent.Value, 0, len(m.removedmentions))
		for id := range m.removedmentions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAuthentication:
		ids := make([]ent.Value, 0, len(m.removedauthentication))
		for id := range m.removedauthentication {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.removedcollections))
		for id := range m.removedcollections {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case account.EdgePostReads:
		ids := make([]ent.Value, 0, len(m.removedpost_reads))
		for id := range m.removedpost_reads {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeReports:
		ids := make([]ent.Value, 0, len(m.removedreports))
		for id := range m.removedreports {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeHandledReports:
		ids := make([]ent.Value, 0, len(m.removedhandled_reports))
		for id := range m.removedhandled_reports {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedaudit_logs))
		for id := range m.removedaudit_logs {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRobots:
		ids := make([]ent.Value, 0, len(m.removedrobots))
		for id := range m.removedrobots {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRobotSessions:
		ids := make([]ent.Value, 0, len(m.removedrobot_sessions))
		for id := range m.removedrobot_sessions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRobotMessages:
		ids := make([]ent.Value, 0, len(m.removedrobot_messages))
		for id := range m.removedrobot_messages {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAccountRoles:
		ids := make([]ent.Value, 0, len(m.removedaccount_roles))
		for id := range m.removedaccount_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 28)
	if m.clearedsessions {
		edges = append(edges, account.EdgeSessions)
	}
	if m.clearedemails {
		edges = append(edges, account.EdgeEmails)
	}
	if m.clearednotifications {
		edges = append(edges, account.EdgeNotifications)
	}
	if m.clearedtriggered_notifications {
		edges = append(edges, account.EdgeTriggeredNotifications)
	}
	if m.clearedfollowing {
		edges = append(edges, account.EdgeFollowing)
	}
	if m.clearedfollowed_by {
		edges = append(edges, account.EdgeFollowedBy)
	}
	if m.clearedinvitations {
		edges = append(edges, account.EdgeInvitations)
	}
	if m.clearedinvited_by {
		edges = append(edges, account.EdgeInvitedBy)
	}
	if m.clearedposts {
		edges = append(edges, account.EdgePosts)
	}
	if m.clearedquestions {
		edges = append(edges, account.EdgeQuestions)
	}
	if m.clearedreacts {
		edges = append(edges, account.EdgeReacts)
	}
	if m.clearedlikes {
		edges = append(edges, account.EdgeLikes)
	}
	if m.clearedmentions {
		edges = append(edges, account.EdgeMentions)
	}
	if m.clearedroles {
		edges = append(edges, account.EdgeRoles)
	}
	if m.clearedauthentication {
		edges = append(edges, account.EdgeAuthentication)
	}
	if m.clearedtags {
		edges = append(edges, account.EdgeTags)
	}
	if m.clearedcollections {
		edges = append(edges, account.EdgeCollections)
	}
	if m.clearednodes {
		edges = append(edges, account.EdgeNodes)
	}
	if m.clearedassets {
		edges = append(edges, account.EdgeAssets)
	}
	if m.clearedevents {
		edges = append(edges, account.EdgeEvents)
	}
	if m.clearedpost_reads {
		edges = append(edges, account.EdgePostReads)
	}
	if m.clearedreports {
		edges = append(edges, account.EdgeReports)
	}
	if m.clearedhandled_reports {
		edges = append(edges, account.EdgeHandledReports)
	}
	if m.clearedaudit_logs {
		edges = append(edges, account.EdgeAuditLogs)
	}
	if m.clearedrobots {
		edges = append(edges, account.EdgeRobots)
	}
	if m.clearedrobot_sessions {
		edges = append(edges, account.EdgeRobotSessions)
	}
	if m.clearedrobot_messages {
		edges = append(edges, account.EdgeRobotMessages)
	}
	if m.clearedaccount_roles {
		edges = append(edges, account.EdgeAccountRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeSessions:
		return m.clearedsessions
	case account.EdgeEmails:
		return m.clearedemails
	case account.EdgeNotifications:
		return m.clearednotifications
	case account.EdgeTriggeredNotifications:
		return m.clearedtriggered_notifications
	case account.EdgeFollowing:
		return m.clearedfollowing
	case account.EdgeFollowedBy:
		return m.clearedfollowed_by
	case account.EdgeInvitations:
		return m.clearedinvitations
	case account.EdgeInvitedBy:
		return m.clearedinvited_by
	case account.EdgePosts:
		return m.clearedposts
	case account.EdgeQuestions:
		return m.clearedquestions
	case account.EdgeReacts:
		return m.clearedreacts
	case account.EdgeLikes:
		return m.clearedlikes
	case account.EdgeMentions:
		return m.clearedmentions
	case account.EdgeRoles:
		return m.clearedroles
	case account.EdgeAuthentication:
		return m.clearedauthentication
	case account.EdgeTags:
		return m.clearedtags
	case account.EdgeCollections:
		return m.clearedcollections
	case account.EdgeNodes:
		return m.clearednodes
	case account.EdgeAssets:
		return m.clearedassets
	case account.EdgeEvents:
		return m.clearedevents
	case account.EdgePostReads:
		return m.clearedpost_reads
	case account.EdgeReports:
		return m.clearedreports
	case account.EdgeHandledReports:
		return m.clearedhandled_reports
	case account.EdgeAuditLogs:
		return m.clearedaudit_logs
	case account.EdgeRobots:
		return m.clearedrobots
	case account.EdgeRobotSessions:
		return m.clearedrobot_sessions
	case account.EdgeRobotMessages:
		return m.clearedrobot_messages
	case account.EdgeAccountRoles:
		return m.clearedaccount_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeInvitedBy:
		m.ClearInvitedBy()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeSessions:
		m.ResetSessions()
		return nil
	case account.EdgeEmails:
		m.ResetEmails()
		return nil
	case account.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case account.EdgeTriggeredNotifications:
		m.ResetTriggeredNotifications()
		return nil
	case account.EdgeFollowing:
		m.ResetFollowing()
		return nil
	case account.EdgeFollowedBy:
		m.ResetFollowedBy()
		return nil
	case account.EdgeInvitations:
		m.ResetInvitations()
		return nil
	case account.EdgeInvitedBy:
		m.ResetInvitedBy()
		return nil
	case account.EdgePosts:
		m.ResetPosts()
		return nil
	case account.EdgeQuestions:
		m.ResetQuestions()
		return nil
	case account.EdgeReacts:
		m.ResetReacts()
		return nil
	case account.EdgeLikes:
		m.ResetLikes()
		return nil
	case account.EdgeMentions:
		m.ResetMentions()
		return nil
	case account.EdgeRoles:
		m.ResetRoles()
		return nil
	case account.EdgeAuthentication:
		m.ResetAuthentication()
		return nil
	case account.EdgeTags:
		m.ResetTags()
		return nil
	case account.EdgeCollections:
		m.ResetCollections()
		return nil
	case account.EdgeNodes:
		m.ResetNodes()
		return nil
	case account.EdgeAssets:
		m.ResetAssets()
		return nil
	case account.EdgeEvents:
		m.ResetEvents()
		return nil
	case account.EdgePostReads:
		m.ResetPostReads()
		return nil
	case account.EdgeReports:
		m.ResetReports()
		return nil
	case account.EdgeHandledReports:
		m.ResetHandledReports()
		return nil
	case account.EdgeAuditLogs:
		m.ResetAuditLogs()
		return nil
	case account.EdgeRobots:
		m.ResetRobots()
		return nil
	case account.EdgeRobotSessions:
		m.ResetRobotSessions()
		return nil
	case account.EdgeRobotMessages:
		m.ResetRobotMessages()
		return nil
	case account.EdgeAccountRoles:
		m.ResetAccountRoles()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AccountFollowMutation represents an operation that mutates the AccountFollow nodes in the graph.
type AccountFollowMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	clearedFields    map[string]struct{}
	follower         *xid.ID
	clearedfollower  bool
	following        *xid.ID
	clearedfollowing bool
	done             bool
	oldValue         func(context.Context) (*AccountFollow, error)
	predicates       []predicate.AccountFollow
}

var _ ent.Mutation = (*AccountFollowMutation)(nil)

// accountfollowOption allows management of the mutation configuration using functional options.
type accountfollowOption func(*AccountFollowMutation)

// newAccountFollowMutation creates new mutation for the AccountFollow entity.
func newAccountFollowMutation(c config, op Op, opts ...accountfollowOption) *AccountFollowMutation {
	m := &AccountFollowMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountFollow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountFollowID sets the ID field of the mutation.
func withAccountFollowID(id xid.ID) accountfollowOption {
	return func(m *AccountFollowMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountFollow
		)
		m.oldValue = func(ctx context.Context) (*AccountFollow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountFollow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountFollow sets the old AccountFollow of the mutation.
func withAccountFollow(node *AccountFollow) accountfollowOption {
	return func(m *AccountFollowMutation) {
		m.oldValue = func(context.Context) (*AccountFollow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountFollowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountFollowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountFollow entities.
func (m *AccountFollowMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountFollowMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountFollowMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountFollow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountFollowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountFollowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountFollow entity.
// If the AccountFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFollowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountFollowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFollowerAccountID sets the "follower_account_id" field.
func (m *AccountFollowMutation) SetFollowerAccountID(x xid.ID) {
	m.follower = &x
}

// FollowerAccountID returns the value of the "follower_account_id" field in the mutation.
func (m *AccountFollowMutation) FollowerAccountID() (r xid.ID, exists bool) {
	v := m.follower
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowerAccountID returns the old "follower_account_id" field's value of the AccountFollow entity.
// If the AccountFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFollowMutation) OldFollowerAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowerAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowerAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowerAccountID: %w", err)
	}
	return oldValue.FollowerAccountID, nil
}

// ResetFollowerAccountID resets all changes to the "follower_account_id" field.
func (m *AccountFollowMutation) ResetFollowerAccountID() {
	m.follower = nil
}

// SetFollowingAccountID sets the "following_account_id" field.
func (m *AccountFollowMutation) SetFollowingAccountID(x xid.ID) {
	m.following = &x
}

// FollowingAccountID returns the value of the "following_account_id" field in the mutation.
func (m *AccountFollowMutation) FollowingAccountID() (r xid.ID, exists bool) {
	v := m.following
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowingAccountID returns the old "following_account_id" field's value of the AccountFollow entity.
// If the AccountFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFollowMutation) OldFollowingAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowingAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowingAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowingAccountID: %w", err)
	}
	return oldValue.FollowingAccountID, nil
}

// ResetFollowingAccountID resets all changes to the "following_account_id" field.
func (m *AccountFollowMutation) ResetFollowingAccountID() {
	m.following = nil
}

// SetFollowerID sets the "follower" edge to the Account entity by id.
func (m *AccountFollowMutation) SetFollowerID(id xid.ID) {
	m.follower = &id
}

// ClearFollower clears the "follower" edge to the Account entity.
func (m *AccountFollowMutation) ClearFollower() {
	m.clearedfollower = true
	m.clearedFields[accountfollow.FieldFollowerAccountID] = struct{}{}
}

// FollowerCleared reports if the "follower" edge to the Account entity was cleared.
func (m *AccountFollowMutation) FollowerCleared() bool {
	return m.clearedfollower
}

// FollowerID returns the "follower" edge ID in the mutation.
func (m *AccountFollowMutation) FollowerID() (id xid.ID, exists bool) {
	if m.follower != nil {
		return *m.follower, true
	}
	return
}

// FollowerIDs returns the "follower" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowerID instead. It exists only for internal usage by the builders.
func (m *AccountFollowMutation) FollowerIDs() (ids []xid.ID) {
	if id := m.follower; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollower resets all changes to the "follower" edge.
func (m *AccountFollowMutation) ResetFollower() {
	m.follower = nil
	m.clearedfollower = false
}

// SetFollowingID sets the "following" edge to the Account entity by id.
func (m *AccountFollowMutation) SetFollowingID(id xid.ID) {
	m.following = &id
}

// ClearFollowing clears the "following" edge to the Account entity.
func (m *AccountFollowMutation) ClearFollowing() {
	m.clearedfollowing = true
	m.clearedFields[accountfollow.FieldFollowingAccountID] = struct{}{}
}

// FollowingCleared reports if the "following" edge to the Account entity was cleared.
func (m *AccountFollowMutation) FollowingCleared() bool {
	return m.clearedfollowing
}

// FollowingID returns the "following" edge ID in the mutation.
func (m *AccountFollowMutation) FollowingID() (id xid.ID, exists bool) {
	if m.following != nil {
		return *m.following, true
	}
	return
}

// FollowingIDs returns the "following" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowingID instead. It exists only for internal usage by the builders.
func (m *AccountFollowMutation) FollowingIDs() (ids []xid.ID) {
	if id := m.following; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollowing resets all changes to the "following" edge.
func (m *AccountFollowMutation) ResetFollowing() {
	m.following = nil
	m.clearedfollowing = false
}

// Where appends a list predicates to the AccountFollowMutation builder.
func (m *AccountFollowMutation) Where(ps ...predicate.AccountFollow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountFollowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountFollowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountFollow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountFollowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountFollowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountFollow).
func (m *AccountFollowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountFollowMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, accountfollow.FieldCreatedAt)
	}
	if m.follower != nil {
		fields = append(fields, accountfollow.FieldFollowerAccountID)
	}
	if m.following != nil {
		fields = append(fields, accountfollow.FieldFollowingAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountFollowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountfollow.FieldCreatedAt:
		return m.CreatedAt()
	case accountfollow.FieldFollowerAccountID:
		return m.FollowerAccountID()
	case accountfollow.FieldFollowingAccountID:
		return m.FollowingAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountFollowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountfollow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountfollow.FieldFollowerAccountID:
		return m.OldFollowerAccountID(ctx)
	case accountfollow.FieldFollowingAccountID:
		return m.OldFollowingAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown AccountFollow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountFollowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountfollow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountfollow.FieldFollowerAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowerAccountID(v)
		return nil
	case accountfollow.FieldFollowingAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowingAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown AccountFollow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountFollowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountFollowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountFollowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccountFollow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountFollowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountFollowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountFollowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountFollow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountFollowMutation) ResetField(name string) error {
	switch name {
	case accountfollow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountfollow.FieldFollowerAccountID:
		m.ResetFollowerAccountID()
		return nil
	case accountfollow.FieldFollowingAccountID:
		m.ResetFollowingAccountID()
		return nil
	}
	return fmt.Errorf("unknown AccountFollow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountFollowMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.follower != nil {
		edges = append(edges, accountfollow.EdgeFollower)
	}
	if m.following != nil {
		edges = append(edges, accountfollow.EdgeFollowing)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountFollowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountfollow.EdgeFollower:
		if id := m.follower; id != nil {
			return []ent.Value{*id}
		}
	case accountfollow.EdgeFollowing:
		if id := m.following; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountFollowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountFollowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountFollowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfollower {
		edges = append(edges, accountfollow.EdgeFollower)
	}
	if m.clearedfollowing {
		edges = append(edges, accountfollow.EdgeFollowing)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountFollowMutation) EdgeCleared(name string) bool {
	switch name {
	case accountfollow.EdgeFollower:
		return m.clearedfollower
	case accountfollow.EdgeFollowing:
		return m.clearedfollowing
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountFollowMutation) ClearEdge(name string) error {
	switch name {
	case accountfollow.EdgeFollower:
		m.ClearFollower()
		return nil
	case accountfollow.EdgeFollowing:
		m.ClearFollowing()
		return nil
	}
	return fmt.Errorf("unknown AccountFollow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountFollowMutation) ResetEdge(name string) error {
	switch name {
	case accountfollow.EdgeFollower:
		m.ResetFollower()
		return nil
	case accountfollow.EdgeFollowing:
		m.ResetFollowing()
		return nil
	}
	return fmt.Errorf("unknown AccountFollow edge %s", name)
}

// AccountRolesMutation represents an operation that mutates the AccountRoles nodes in the graph.
type AccountRolesMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	badge          *bool
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	role           *xid.ID
	clearedrole    bool
	done           bool
	oldValue       func(context.Context) (*AccountRoles, error)
	predicates     []predicate.AccountRoles
}

var _ ent.Mutation = (*AccountRolesMutation)(nil)

// accountrolesOption allows management of the mutation configuration using functional options.
type accountrolesOption func(*AccountRolesMutation)

// newAccountRolesMutation creates new mutation for the AccountRoles entity.
func newAccountRolesMutation(c config, op Op, opts ...accountrolesOption) *AccountRolesMutation {
	m := &AccountRolesMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountRoles,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountRolesID sets the ID field of the mutation.
func withAccountRolesID(id xid.ID) accountrolesOption {
	return func(m *AccountRolesMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountRoles
		)
		m.oldValue = func(ctx context.Context) (*AccountRoles, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountRoles.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountRoles sets the old AccountRoles of the mutation.
func withAccountRoles(node *AccountRoles) accountrolesOption {
	return func(m *AccountRolesMutation) {
		m.oldValue = func(context.Context) (*AccountRoles, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountRolesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountRolesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountRoles entities.
func (m *AccountRolesMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountRolesMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountRolesMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountRoles.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountRolesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountRolesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountRoles entity.
// If the AccountRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountRolesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountRolesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountID sets the "account_id" field.
func (m *AccountRolesMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AccountRolesMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the AccountRoles entity.
// If the AccountRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountRolesMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AccountRolesMutation) ResetAccountID() {
	m.account = nil
}

// SetRoleID sets the "role_id" field.
func (m *AccountRolesMutation) SetRoleID(x xid.ID) {
	m.role = &x
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AccountRolesMutation) RoleID() (r xid.ID, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the AccountRoles entity.
// If the AccountRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountRolesMutation) OldRoleID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AccountRolesMutation) ResetRoleID() {
	m.role = nil
}

// SetBadge sets the "badge" field.
func (m *AccountRolesMutation) SetBadge(b bool) {
	m.badge = &b
}

// Badge returns the value of the "badge" field in the mutation.
func (m *AccountRolesMutation) Badge() (r bool, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the AccountRoles entity.
// If the AccountRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountRolesMutation) OldBadge(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *AccountRolesMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[accountroles.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *AccountRolesMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[accountroles.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *AccountRolesMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, accountroles.FieldBadge)
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *AccountRolesMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[accountroles.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *AccountRolesMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *AccountRolesMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *AccountRolesMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *AccountRolesMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[accountroles.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *AccountRolesMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *AccountRolesMutation) RoleIDs() (ids []xid.ID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *AccountRolesMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the AccountRolesMutation builder.
func (m *AccountRolesMutation) Where(ps ...predicate.AccountRoles) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountRolesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountRolesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountRoles, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountRolesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountRolesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountRoles).
func (m *AccountRolesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountRolesMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, accountroles.FieldCreatedAt)
	}
	if m.account != nil {
		fields = append(fields, accountroles.FieldAccountID)
	}
	if m.role != nil {
		fields = append(fields, accountroles.FieldRoleID)
	}
	if m.badge != nil {
		fields = append(fields, accountroles.FieldBadge)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountRolesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountroles.FieldCreatedAt:
		return m.CreatedAt()
	case accountroles.FieldAccountID:
		return m.AccountID()
	case accountroles.FieldRoleID:
		return m.RoleID()
	case accountroles.FieldBadge:
		return m.Badge()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountRolesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountroles.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountroles.FieldAccountID:
		return m.OldAccountID(ctx)
	case accountroles.FieldRoleID:
		return m.OldRoleID(ctx)
	case accountroles.FieldBadge:
		return m.OldBadge(ctx)
	}
	return nil, fmt.Errorf("unknown AccountRoles field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountRolesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountroles.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountroles.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case accountroles.FieldRoleID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case accountroles.FieldBadge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	}
	return fmt.Errorf("unknown AccountRoles field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountRolesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountRolesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountRolesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccountRoles numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountRolesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountroles.FieldBadge) {
		fields = append(fields, accountroles.FieldBadge)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountRolesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountRolesMutation) ClearField(name string) error {
	switch name {
	case accountroles.FieldBadge:
		m.ClearBadge()
		return nil
	}
	return fmt.Errorf("unknown AccountRoles nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountRolesMutation) ResetField(name string) error {
	switch name {
	case accountroles.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountroles.FieldAccountID:
		m.ResetAccountID()
		return nil
	case accountroles.FieldRoleID:
		m.ResetRoleID()
		return nil
	case accountroles.FieldBadge:
		m.ResetBadge()
		return nil
	}
	return fmt.Errorf("unknown AccountRoles field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountRolesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, accountroles.EdgeAccount)
	}
	if m.role != nil {
		edges = append(edges, accountroles.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountRolesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountroles.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case accountroles.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountRolesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountRolesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountRolesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, accountroles.EdgeAccount)
	}
	if m.clearedrole {
		edges = append(edges, accountroles.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountRolesMutation) EdgeCleared(name string) bool {
	switch name {
	case accountroles.EdgeAccount:
		return m.clearedaccount
	case accountroles.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountRolesMutation) ClearEdge(name string) error {
	switch name {
	case accountroles.EdgeAccount:
		m.ClearAccount()
		return nil
	case accountroles.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown AccountRoles unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountRolesMutation) ResetEdge(name string) error {
	switch name {
	case accountroles.EdgeAccount:
		m.ResetAccount()
		return nil
	case accountroles.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown AccountRoles edge %s", name)
}

// AssetMutation represents an operation that mutates the Asset nodes in the graph.
type AssetMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	filename      *string
	size          *int
	addsize       *int
	mime_type     *string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	posts         map[xid.ID]struct{}
	removedposts  map[xid.ID]struct{}
	clearedposts  bool
	nodes         map[xid.ID]struct{}
	removednodes  map[xid.ID]struct{}
	clearednodes  bool
	links         map[xid.ID]struct{}
	removedlinks  map[xid.ID]struct{}
	clearedlinks  bool
	owner         *xid.ID
	clearedowner  bool
	parent        *xid.ID
	clearedparent bool
	assets        map[xid.ID]struct{}
	removedassets map[xid.ID]struct{}
	clearedassets bool
	event         map[xid.ID]struct{}
	removedevent  map[xid.ID]struct{}
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*Asset, error)
	predicates    []predicate.Asset
}

var _ ent.Mutation = (*AssetMutation)(nil)

// assetOption allows management of the mutation configuration using functional options.
type assetOption func(*AssetMutation)

// newAssetMutation creates new mutation for the Asset entity.
func newAssetMutation(c config, op Op, opts ...assetOption) *AssetMutation {
	m := &AssetMutation{
		config:        c,
		op:            op,
		typ:           TypeAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetID sets the ID field of the mutation.
func withAssetID(id xid.ID) assetOption {
	return func(m *AssetMutation) {
		var (
			err   error
			once  sync.Once
			value *Asset
		)
		m.oldValue = func(ctx context.Context) (*Asset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Asset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsset sets the old Asset of the mutation.
func withAsset(node *Asset) assetOption {
	return func(m *AssetMutation) {
		m.oldValue = func(context.Context) (*Asset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Asset entities.
func (m *AssetMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Asset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFilename sets the "filename" field.
func (m *AssetMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *AssetMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *AssetMutation) ResetFilename() {
	m.filename = nil
}

// SetSize sets the "size" field.
func (m *AssetMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *AssetMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *AssetMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *AssetMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *AssetMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetMimeType sets the "mime_type" field.
func (m *AssetMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *AssetMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *AssetMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetMetadata sets the "metadata" field.
func (m *AssetMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AssetMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AssetMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[asset.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AssetMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[asset.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AssetMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, asset.FieldMetadata)
}

// SetAccountID sets the "account_id" field.
func (m *AssetMutation) SetAccountID(x xid.ID) {
	m.owner = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AssetMutation) AccountID() (r xid.ID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AssetMutation) ResetAccountID() {
	m.owner = nil
}

// SetParentAssetID sets the "parent_asset_id" field.
func (m *AssetMutation) SetParentAssetID(x xid.ID) {
	m.parent = &x
}

// ParentAssetID returns the value of the "parent_asset_id" field in the mutation.
func (m *AssetMutation) ParentAssetID() (r xid.ID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentAssetID returns the old "parent_asset_id" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldParentAssetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentAssetID: %w", err)
	}
	return oldValue.ParentAssetID, nil
}

// ClearParentAssetID clears the value of the "parent_asset_id" field.
func (m *AssetMutation) ClearParentAssetID() {
	m.parent = nil
	m.clearedFields[asset.FieldParentAssetID] = struct{}{}
}

// ParentAssetIDCleared returns if the "parent_asset_id" field was cleared in this mutation.
func (m *AssetMutation) ParentAssetIDCleared() bool {
	_, ok := m.clearedFields[asset.FieldParentAssetID]
	return ok
}

// ResetParentAssetID resets all changes to the "parent_asset_id" field.
func (m *AssetMutation) ResetParentAssetID() {
	m.parent = nil
	delete(m.clearedFields, asset.FieldParentAssetID)
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *AssetMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *AssetMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *AssetMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *AssetMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *AssetMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *AssetMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *AssetMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *AssetMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *AssetMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *AssetMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *AssetMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *AssetMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *AssetMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *AssetMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddLinkIDs adds the "links" edge to the Link entity by ids.
func (m *AssetMutation) AddLinkIDs(ids ...xid.ID) {
	if m.links == nil {
		m.links = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the "links" edge to the Link entity.
func (m *AssetMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared reports if the "links" edge to the Link entity was cleared.
func (m *AssetMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the "links" edge to the Link entity by IDs.
func (m *AssetMutation) RemoveLinkIDs(ids ...xid.ID) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.links, ids[i])
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed IDs of the "links" edge to the Link entity.
func (m *AssetMutation) RemovedLinksIDs() (ids []xid.ID) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the "links" edge IDs in the mutation.
func (m *AssetMutation) LinksIDs() (ids []xid.ID) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks resets all changes to the "links" edge.
func (m *AssetMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *AssetMutation) SetOwnerID(id xid.ID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *AssetMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[asset.FieldAccountID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *AssetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AssetMutation) OwnerID() (id xid.ID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) OwnerIDs() (ids []xid.ID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AssetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetParentID sets the "parent" edge to the Asset entity by id.
func (m *AssetMutation) SetParentID(id xid.ID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Asset entity.
func (m *AssetMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[asset.FieldParentAssetID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Asset entity was cleared.
func (m *AssetMutation) ParentCleared() bool {
	return m.ParentAssetIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *AssetMutation) ParentID() (id xid.ID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) ParentIDs() (ids []xid.ID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *AssetMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *AssetMutation) AddAssetIDs(ids ...xid.ID) {
	if m.assets == nil {
		m.assets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *AssetMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *AssetMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *AssetMutation) RemoveAssetIDs(ids ...xid.ID) {
	if m.removedassets == nil {
		m.removedassets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *AssetMutation) RemovedAssetsIDs() (ids []xid.ID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *AssetMutation) AssetsIDs() (ids []xid.ID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *AssetMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// AddEventIDs adds the "event" edge to the Event entity by ids.
func (m *AssetMutation) AddEventIDs(ids ...xid.ID) {
	if m.event == nil {
		m.event = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.event[ids[i]] = struct{}{}
	}
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *AssetMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *AssetMutation) EventCleared() bool {
	return m.clearedevent
}

// RemoveEventIDs removes the "event" edge to the Event entity by IDs.
func (m *AssetMutation) RemoveEventIDs(ids ...xid.ID) {
	if m.removedevent == nil {
		m.removedevent = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.event, ids[i])
		m.removedevent[ids[i]] = struct{}{}
	}
}

// RemovedEvent returns the removed IDs of the "event" edge to the Event entity.
func (m *AssetMutation) RemovedEventIDs() (ids []xid.ID) {
	for id := range m.removedevent {
		ids = append(ids, id)
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
func (m *AssetMutation) EventIDs() (ids []xid.ID) {
	for id := range m.event {
		ids = append(ids, id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *AssetMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
	m.removedevent = nil
}

// Where appends a list predicates to the AssetMutation builder.
func (m *AssetMutation) Where(ps ...predicate.Asset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Asset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Asset).
func (m *AssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, asset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, asset.FieldUpdatedAt)
	}
	if m.filename != nil {
		fields = append(fields, asset.FieldFilename)
	}
	if m.size != nil {
		fields = append(fields, asset.FieldSize)
	}
	if m.mime_type != nil {
		fields = append(fields, asset.FieldMimeType)
	}
	if m.metadata != nil {
		fields = append(fields, asset.FieldMetadata)
	}
	if m.owner != nil {
		fields = append(fields, asset.FieldAccountID)
	}
	if m.parent != nil {
		fields = append(fields, asset.FieldParentAssetID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldCreatedAt:
		return m.CreatedAt()
	case asset.FieldUpdatedAt:
		return m.UpdatedAt()
	case asset.FieldFilename:
		return m.Filename()
	case asset.FieldSize:
		return m.Size()
	case asset.FieldMimeType:
		return m.MimeType()
	case asset.FieldMetadata:
		return m.Metadata()
	case asset.FieldAccountID:
		return m.AccountID()
	case asset.FieldParentAssetID:
		return m.ParentAssetID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case asset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case asset.FieldFilename:
		return m.OldFilename(ctx)
	case asset.FieldSize:
		return m.OldSize(ctx)
	case asset.FieldMimeType:
		return m.OldMimeType(ctx)
	case asset.FieldMetadata:
		return m.OldMetadata(ctx)
	case asset.FieldAccountID:
		return m.OldAccountID(ctx)
	case asset.FieldParentAssetID:
		return m.OldParentAssetID(ctx)
	}
	return nil, fmt.Errorf("unknown Asset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case asset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case asset.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case asset.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case asset.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case asset.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case asset.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case asset.FieldParentAssetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentAssetID(v)
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, asset.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asset.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Asset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asset.FieldMetadata) {
		fields = append(fields, asset.FieldMetadata)
	}
	if m.FieldCleared(asset.FieldParentAssetID) {
		fields = append(fields, asset.FieldParentAssetID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetMutation) ClearField(name string) error {
	switch name {
	case asset.FieldMetadata:
		m.ClearMetadata()
		return nil
	case asset.FieldParentAssetID:
		m.ClearParentAssetID()
		return nil
	}
	return fmt.Errorf("unknown Asset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetMutation) ResetField(name string) error {
	switch name {
	case asset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case asset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case asset.FieldFilename:
		m.ResetFilename()
		return nil
	case asset.FieldSize:
		m.ResetSize()
		return nil
	case asset.FieldMimeType:
		m.ResetMimeType()
		return nil
	case asset.FieldMetadata:
		m.ResetMetadata()
		return nil
	case asset.FieldAccountID:
		m.ResetAccountID()
		return nil
	case asset.FieldParentAssetID:
		m.ResetParentAssetID()
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.posts != nil {
		edges = append(edges, asset.EdgePosts)
	}
	if m.nodes != nil {
		edges = append(edges, asset.EdgeNodes)
	}
	if m.links != nil {
		edges = append(edges, asset.EdgeLinks)
	}
	if m.owner != nil {
		edges = append(edges, asset.EdgeOwner)
	}
	if m.parent != nil {
		edges = append(edges, asset.EdgeParent)
	}
	if m.assets != nil {
		edges = append(edges, asset.EdgeAssets)
	}
	if m.event != nil {
		edges = append(edges, asset.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.event))
		for id := range m.event {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedposts != nil {
		edges = append(edges, asset.EdgePosts)
	}
	if m.removednodes != nil {
		edges = append(edges, asset.EdgeNodes)
	}
	if m.removedlinks != nil {
		edges = append(edges, asset.EdgeLinks)
	}
	if m.removedassets != nil {
		edges = append(edges, asset.EdgeAssets)
	}
	if m.removedevent != nil {
		edges = append(edges, asset.EdgeEvent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.removedevent))
		for id := range m.removedevent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedposts {
		edges = append(edges, asset.EdgePosts)
	}
	if m.clearednodes {
		edges = append(edges, asset.EdgeNodes)
	}
	if m.clearedlinks {
		edges = append(edges, asset.EdgeLinks)
	}
	if m.clearedowner {
		edges = append(edges, asset.EdgeOwner)
	}
	if m.clearedparent {
		edges = append(edges, asset.EdgeParent)
	}
	if m.clearedassets {
		edges = append(edges, asset.EdgeAssets)
	}
	if m.clearedevent {
		edges = append(edges, asset.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetMutation) EdgeCleared(name string) bool {
	switch name {
	case asset.EdgePosts:
		return m.clearedposts
	case asset.EdgeNodes:
		return m.clearednodes
	case asset.EdgeLinks:
		return m.clearedlinks
	case asset.EdgeOwner:
		return m.clearedowner
	case asset.EdgeParent:
		return m.clearedparent
	case asset.EdgeAssets:
		return m.clearedassets
	case asset.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetMutation) ClearEdge(name string) error {
	switch name {
	case asset.EdgeOwner:
		m.ClearOwner()
		return nil
	case asset.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Asset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetMutation) ResetEdge(name string) error {
	switch name {
	case asset.EdgePosts:
		m.ResetPosts()
		return nil
	case asset.EdgeNodes:
		m.ResetNodes()
		return nil
	case asset.EdgeLinks:
		m.ResetLinks()
		return nil
	case asset.EdgeOwner:
		m.ResetOwner()
		return nil
	case asset.EdgeParent:
		m.ResetParent()
		return nil
	case asset.EdgeAssets:
		m.ResetAssets()
		return nil
	case asset.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown Asset edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op                Op
	typ               string
	id                *xid.ID
	created_at        *time.Time
	target_id         *xid.ID
	target_kind       *string
	_type             *string
	error             *string
	metadata          *map[string]interface{}
	clearedFields     map[string]struct{}
	enacted_by        *xid.ID
	clearedenacted_by bool
	done              bool
	oldValue          func(context.Context) (*AuditLog, error)
	predicates        []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id xid.ID) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEnactedByID sets the "enacted_by_id" field.
func (m *AuditLogMutation) SetEnactedByID(x xid.ID) {
	m.enacted_by = &x
}

// EnactedByID returns the value of the "enacted_by_id" field in the mutation.
func (m *AuditLogMutation) EnactedByID() (r xid.ID, exists bool) {
	v := m.enacted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldEnactedByID returns the old "enacted_by_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldEnactedByID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnactedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnactedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnactedByID: %w", err)
	}
	return oldValue.EnactedByID, nil
}

// ClearEnactedByID clears the value of the "enacted_by_id" field.
func (m *AuditLogMutation) ClearEnactedByID() {
	m.enacted_by = nil
	m.clearedFields[auditlog.FieldEnactedByID] = struct{}{}
}

// EnactedByIDCleared returns if the "enacted_by_id" field was cleared in this mutation.
func (m *AuditLogMutation) EnactedByIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldEnactedByID]
	return ok
}

// ResetEnactedByID resets all changes to the "enacted_by_id" field.
func (m *AuditLogMutation) ResetEnactedByID() {
	m.enacted_by = nil
	delete(m.clearedFields, auditlog.FieldEnactedByID)
}

// SetTargetID sets the "target_id" field.
func (m *AuditLogMutation) SetTargetID(x xid.ID) {
	m.target_id = &x
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *AuditLogMutation) TargetID() (r xid.ID, exists bool) {
	v := m.target_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTargetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// ClearTargetID clears the value of the "target_id" field.
func (m *AuditLogMutation) ClearTargetID() {
	m.target_id = nil
	m.clearedFields[auditlog.FieldTargetID] = struct{}{}
}

// TargetIDCleared returns if the "target_id" field was cleared in this mutation.
func (m *AuditLogMutation) TargetIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTargetID]
	return ok
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *AuditLogMutation) ResetTargetID() {
	m.target_id = nil
	delete(m.clearedFields, auditlog.FieldTargetID)
}

// SetTargetKind sets the "target_kind" field.
func (m *AuditLogMutation) SetTargetKind(s string) {
	m.target_kind = &s
}

// TargetKind returns the value of the "target_kind" field in the mutation.
func (m *AuditLogMutation) TargetKind() (r string, exists bool) {
	v := m.target_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetKind returns the old "target_kind" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTargetKind(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetKind: %w", err)
	}
	return oldValue.TargetKind, nil
}

// ClearTargetKind clears the value of the "target_kind" field.
func (m *AuditLogMutation) ClearTargetKind() {
	m.target_kind = nil
	m.clearedFields[auditlog.FieldTargetKind] = struct{}{}
}

// TargetKindCleared returns if the "target_kind" field was cleared in this mutation.
func (m *AuditLogMutation) TargetKindCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTargetKind]
	return ok
}

// ResetTargetKind resets all changes to the "target_kind" field.
func (m *AuditLogMutation) ResetTargetKind() {
	m.target_kind = nil
	delete(m.clearedFields, auditlog.FieldTargetKind)
}

// SetType sets the "type" field.
func (m *AuditLogMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AuditLogMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AuditLogMutation) ResetType() {
	m._type = nil
}

// SetError sets the "error" field.
func (m *AuditLogMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *AuditLogMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldError(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *AuditLogMutation) ClearError() {
	m.error = nil
	m.clearedFields[auditlog.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *AuditLogMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, auditlog.FieldError)
}

// SetMetadata sets the "metadata" field.
func (m *AuditLogMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuditLogMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuditLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[auditlog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuditLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuditLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, auditlog.FieldMetadata)
}

// ClearEnactedBy clears the "enacted_by" edge to the Account entity.
func (m *AuditLogMutation) ClearEnactedBy() {
	m.clearedenacted_by = true
	m.clearedFields[auditlog.FieldEnactedByID] = struct{}{}
}

// EnactedByCleared reports if the "enacted_by" edge to the Account entity was cleared.
func (m *AuditLogMutation) EnactedByCleared() bool {
	return m.EnactedByIDCleared() || m.clearedenacted_by
}

// EnactedByIDs returns the "enacted_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnactedByID instead. It exists only for internal usage by the builders.
func (m *AuditLogMutation) EnactedByIDs() (ids []xid.ID) {
	if id := m.enacted_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnactedBy resets all changes to the "enacted_by" edge.
func (m *AuditLogMutation) ResetEnactedBy() {
	m.enacted_by = nil
	m.clearedenacted_by = false
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	if m.enacted_by != nil {
		fields = append(fields, auditlog.FieldEnactedByID)
	}
	if m.target_id != nil {
		fields = append(fields, auditlog.FieldTargetID)
	}
	if m.target_kind != nil {
		fields = append(fields, auditlog.FieldTargetKind)
	}
	if m._type != nil {
		fields = append(fields, auditlog.FieldType)
	}
	if m.error != nil {
		fields = append(fields, auditlog.FieldError)
	}
	if m.metadata != nil {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	case auditlog.FieldEnactedByID:
		return m.EnactedByID()
	case auditlog.FieldTargetID:
		return m.TargetID()
	case auditlog.FieldTargetKind:
		return m.TargetKind()
	case auditlog.FieldType:
		return m.GetType()
	case auditlog.FieldError:
		return m.Error()
	case auditlog.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auditlog.FieldEnactedByID:
		return m.OldEnactedByID(ctx)
	case auditlog.FieldTargetID:
		return m.OldTargetID(ctx)
	case auditlog.FieldTargetKind:
		return m.OldTargetKind(ctx)
	case auditlog.FieldType:
		return m.OldType(ctx)
	case auditlog.FieldError:
		return m.OldError(ctx)
	case auditlog.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auditlog.FieldEnactedByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnactedByID(v)
		return nil
	case auditlog.FieldTargetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case auditlog.FieldTargetKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetKind(v)
		return nil
	case auditlog.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case auditlog.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case auditlog.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldEnactedByID) {
		fields = append(fields, auditlog.FieldEnactedByID)
	}
	if m.FieldCleared(auditlog.FieldTargetID) {
		fields = append(fields, auditlog.FieldTargetID)
	}
	if m.FieldCleared(auditlog.FieldTargetKind) {
		fields = append(fields, auditlog.FieldTargetKind)
	}
	if m.FieldCleared(auditlog.FieldError) {
		fields = append(fields, auditlog.FieldError)
	}
	if m.FieldCleared(auditlog.FieldMetadata) {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldEnactedByID:
		m.ClearEnactedByID()
		return nil
	case auditlog.FieldTargetID:
		m.ClearTargetID()
		return nil
	case auditlog.FieldTargetKind:
		m.ClearTargetKind()
		return nil
	case auditlog.FieldError:
		m.ClearError()
		return nil
	case auditlog.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auditlog.FieldEnactedByID:
		m.ResetEnactedByID()
		return nil
	case auditlog.FieldTargetID:
		m.ResetTargetID()
		return nil
	case auditlog.FieldTargetKind:
		m.ResetTargetKind()
		return nil
	case auditlog.FieldType:
		m.ResetType()
		return nil
	case auditlog.FieldError:
		m.ResetError()
		return nil
	case auditlog.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.enacted_by != nil {
		edges = append(edges, auditlog.EdgeEnactedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auditlog.EdgeEnactedBy:
		if id := m.enacted_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedenacted_by {
		edges = append(edges, auditlog.EdgeEnactedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	switch name {
	case auditlog.EdgeEnactedBy:
		return m.clearedenacted_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	switch name {
	case auditlog.EdgeEnactedBy:
		m.ClearEnactedBy()
		return nil
	}
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	switch name {
	case auditlog.EdgeEnactedBy:
		m.ResetEnactedBy()
		return nil
	}
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// AuthenticationMutation represents an operation that mutates the Authentication nodes in the graph.
type AuthenticationMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	expires_at     *time.Time
	service        *string
	token_type     *string
	identifier     *string
	token          *string
	name           *string
	disabled       *bool
	metadata       *map[string]interface{}
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	done           bool
	oldValue       func(context.Context) (*Authentication, error)
	predicates     []predicate.Authentication
}

var _ ent.Mutation = (*AuthenticationMutation)(nil)

// authenticationOption allows management of the mutation configuration using functional options.
type authenticationOption func(*AuthenticationMutation)

// newAuthenticationMutation creates new mutation for the Authentication entity.
func newAuthenticationMutation(c config, op Op, opts ...authenticationOption) *AuthenticationMutation {
	m := &AuthenticationMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthentication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthenticationID sets the ID field of the mutation.
func withAuthenticationID(id xid.ID) authenticationOption {
	return func(m *AuthenticationMutation) {
		var (
			err   error
			once  sync.Once
			value *Authentication
		)
		m.oldValue = func(ctx context.Context) (*Authentication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Authentication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthentication sets the old Authentication of the mutation.
func withAuthentication(node *Authentication) authenticationOption {
	return func(m *AuthenticationMutation) {
		m.oldValue = func(context.Context) (*Authentication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthenticationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthenticationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Authentication entities.
func (m *AuthenticationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthenticationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthenticationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Authentication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthenticationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthenticationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthenticationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AuthenticationMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AuthenticationMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *AuthenticationMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[authentication.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *AuthenticationMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[authentication.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AuthenticationMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, authentication.FieldExpiresAt)
}

// SetService sets the "service" field.
func (m *AuthenticationMutation) SetService(s string) {
	m.service = &s
}

// Service returns the value of the "service" field in the mutation.
func (m *AuthenticationMutation) Service() (r string, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldService returns the old "service" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldService(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldService: %w", err)
	}
	return oldValue.Service, nil
}

// ResetService resets all changes to the "service" field.
func (m *AuthenticationMutation) ResetService() {
	m.service = nil
}

// SetTokenType sets the "token_type" field.
func (m *AuthenticationMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *AuthenticationMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *AuthenticationMutation) ResetTokenType() {
	m.token_type = nil
}

// SetIdentifier sets the "identifier" field.
func (m *AuthenticationMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *AuthenticationMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *AuthenticationMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetToken sets the "token" field.
func (m *AuthenticationMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AuthenticationMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AuthenticationMutation) ResetToken() {
	m.token = nil
}

// SetName sets the "name" field.
func (m *AuthenticationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AuthenticationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AuthenticationMutation) ClearName() {
	m.name = nil
	m.clearedFields[authentication.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AuthenticationMutation) NameCleared() bool {
	_, ok := m.clearedFields[authentication.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AuthenticationMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, authentication.FieldName)
}

// SetDisabled sets the "disabled" field.
func (m *AuthenticationMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *AuthenticationMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *AuthenticationMutation) ResetDisabled() {
	m.disabled = nil
}

// SetMetadata sets the "metadata" field.
func (m *AuthenticationMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuthenticationMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuthenticationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[authentication.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuthenticationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[authentication.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuthenticationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, authentication.FieldMetadata)
}

// SetAccountAuthentication sets the "account_authentication" field.
func (m *AuthenticationMutation) SetAccountAuthentication(x xid.ID) {
	m.account = &x
}

// AccountAuthentication returns the value of the "account_authentication" field in the mutation.
func (m *AuthenticationMutation) AccountAuthentication() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountAuthentication returns the old "account_authentication" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldAccountAuthentication(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountAuthentication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountAuthentication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountAuthentication: %w", err)
	}
	return oldValue.AccountAuthentication, nil
}

// ResetAccountAuthentication resets all changes to the "account_authentication" field.
func (m *AuthenticationMutation) ResetAccountAuthentication() {
	m.account = nil
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *AuthenticationMutation) SetAccountID(id xid.ID) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *AuthenticationMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[authentication.FieldAccountAuthentication] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *AuthenticationMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *AuthenticationMutation) AccountID() (id xid.ID, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *AuthenticationMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *AuthenticationMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the AuthenticationMutation builder.
func (m *AuthenticationMutation) Where(ps ...predicate.Authentication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthenticationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthenticationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Authentication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthenticationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthenticationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Authentication).
func (m *AuthenticationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthenticationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, authentication.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, authentication.FieldExpiresAt)
	}
	if m.service != nil {
		fields = append(fields, authentication.FieldService)
	}
	if m.token_type != nil {
		fields = append(fields, authentication.FieldTokenType)
	}
	if m.identifier != nil {
		fields = append(fields, authentication.FieldIdentifier)
	}
	if m.token != nil {
		fields = append(fields, authentication.FieldToken)
	}
	if m.name != nil {
		fields = append(fields, authentication.FieldName)
	}
	if m.disabled != nil {
		fields = append(fields, authentication.FieldDisabled)
	}
	if m.metadata != nil {
		fields = append(fields, authentication.FieldMetadata)
	}
	if m.account != nil {
		fields = append(fields, authentication.FieldAccountAuthentication)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthenticationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authentication.FieldCreatedAt:
		return m.CreatedAt()
	case authentication.FieldExpiresAt:
		return m.ExpiresAt()
	case authentication.FieldService:
		return m.Service()
	case authentication.FieldTokenType:
		return m.TokenType()
	case authentication.FieldIdentifier:
		return m.Identifier()
	case authentication.FieldToken:
		return m.Token()
	case authentication.FieldName:
		return m.Name()
	case authentication.FieldDisabled:
		return m.Disabled()
	case authentication.FieldMetadata:
		return m.Metadata()
	case authentication.FieldAccountAuthentication:
		return m.AccountAuthentication()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthenticationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authentication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authentication.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case authentication.FieldService:
		return m.OldService(ctx)
	case authentication.FieldTokenType:
		return m.OldTokenType(ctx)
	case authentication.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case authentication.FieldToken:
		return m.OldToken(ctx)
	case authentication.FieldName:
		return m.OldName(ctx)
	case authentication.FieldDisabled:
		return m.OldDisabled(ctx)
	case authentication.FieldMetadata:
		return m.OldMetadata(ctx)
	case authentication.FieldAccountAuthentication:
		return m.OldAccountAuthentication(ctx)
	}
	return nil, fmt.Errorf("unknown Authentication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthenticationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authentication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authentication.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case authentication.FieldService:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetService(v)
		return nil
	case authentication.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case authentication.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case authentication.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case authentication.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case authentication.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case authentication.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case authentication.FieldAccountAuthentication:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountAuthentication(v)
		return nil
	}
	return fmt.Errorf("unknown Authentication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthenticationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthenticationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthenticationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Authentication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthenticationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authentication.FieldExpiresAt) {
		fields = append(fields, authentication.FieldExpiresAt)
	}
	if m.FieldCleared(authentication.FieldName) {
		fields = append(fields, authentication.FieldName)
	}
	if m.FieldCleared(authentication.FieldMetadata) {
		fields = append(fields, authentication.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthenticationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthenticationMutation) ClearField(name string) error {
	switch name {
	case authentication.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case authentication.FieldName:
		m.ClearName()
		return nil
	case authentication.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Authentication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthenticationMutation) ResetField(name string) error {
	switch name {
	case authentication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authentication.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case authentication.FieldService:
		m.ResetService()
		return nil
	case authentication.FieldTokenType:
		m.ResetTokenType()
		return nil
	case authentication.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case authentication.FieldToken:
		m.ResetToken()
		return nil
	case authentication.FieldName:
		m.ResetName()
		return nil
	case authentication.FieldDisabled:
		m.ResetDisabled()
		return nil
	case authentication.FieldMetadata:
		m.ResetMetadata()
		return nil
	case authentication.FieldAccountAuthentication:
		m.ResetAccountAuthentication()
		return nil
	}
	return fmt.Errorf("unknown Authentication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthenticationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.account != nil {
		edges = append(edges, authentication.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthenticationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authentication.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthenticationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthenticationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthenticationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccount {
		edges = append(edges, authentication.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthenticationMutation) EdgeCleared(name string) bool {
	switch name {
	case authentication.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthenticationMutation) ClearEdge(name string) error {
	switch name {
	case authentication.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Authentication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthenticationMutation) ResetEdge(name string) error {
	switch name {
	case authentication.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown Authentication edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *xid.ID
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	slug               *string
	description        *string
	colour             *string
	sort               *int
	addsort            *int
	admin              *bool
	metadata           *map[string]interface{}
	clearedFields      map[string]struct{}
	posts              map[xid.ID]struct{}
	removedposts       map[xid.ID]struct{}
	clearedposts       bool
	parent             *xid.ID
	clearedparent      bool
	children           map[xid.ID]struct{}
	removedchildren    map[xid.ID]struct{}
	clearedchildren    bool
	cover_image        *xid.ID
	clearedcover_image bool
	done               bool
	oldValue           func(context.Context) (*Category, error)
	predicates         []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id xid.ID) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
}

// SetColour sets the "colour" field.
func (m *CategoryMutation) SetColour(s string) {
	m.colour = &s
}

// Colour returns the value of the "colour" field in the mutation.
func (m *CategoryMutation) Colour() (r string, exists bool) {
	v := m.colour
	if v == nil {
		return
	}
	return *v, true
}

// OldColour returns the old "colour" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldColour(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColour: %w", err)
	}
	return oldValue.Colour, nil
}

// ResetColour resets all changes to the "colour" field.
func (m *CategoryMutation) ResetColour() {
	m.colour = nil
}

// SetSort sets the "sort" field.
func (m *CategoryMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *CategoryMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *CategoryMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *CategoryMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *CategoryMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetAdmin sets the "admin" field.
func (m *CategoryMutation) SetAdmin(b bool) {
	m.admin = &b
}

// Admin returns the value of the "admin" field in the mutation.
func (m *CategoryMutation) Admin() (r bool, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "admin" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "admin" field.
func (m *CategoryMutation) ResetAdmin() {
	m.admin = nil
}

// SetParentCategoryID sets the "parent_category_id" field.
func (m *CategoryMutation) SetParentCategoryID(x xid.ID) {
	m.parent = &x
}

// ParentCategoryID returns the value of the "parent_category_id" field in the mutation.
func (m *CategoryMutation) ParentCategoryID() (r xid.ID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentCategoryID returns the old "parent_category_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentCategoryID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentCategoryID: %w", err)
	}
	return oldValue.ParentCategoryID, nil
}

// ClearParentCategoryID clears the value of the "parent_category_id" field.
func (m *CategoryMutation) ClearParentCategoryID() {
	m.parent = nil
	m.clearedFields[category.FieldParentCategoryID] = struct{}{}
}

// ParentCategoryIDCleared returns if the "parent_category_id" field was cleared in this mutation.
func (m *CategoryMutation) ParentCategoryIDCleared() bool {
	_, ok := m.clearedFields[category.FieldParentCategoryID]
	return ok
}

// ResetParentCategoryID resets all changes to the "parent_category_id" field.
func (m *CategoryMutation) ResetParentCategoryID() {
	m.parent = nil
	delete(m.clearedFields, category.FieldParentCategoryID)
}

// SetCoverImageAssetID sets the "cover_image_asset_id" field.
func (m *CategoryMutation) SetCoverImageAssetID(x xid.ID) {
	m.cover_image = &x
}

// CoverImageAssetID returns the value of the "cover_image_asset_id" field in the mutation.
func (m *CategoryMutation) CoverImageAssetID() (r xid.ID, exists bool) {
	v := m.cover_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImageAssetID returns the old "cover_image_asset_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCoverImageAssetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImageAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImageAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImageAssetID: %w", err)
	}
	return oldValue.CoverImageAssetID, nil
}

// ClearCoverImageAssetID clears the value of the "cover_image_asset_id" field.
func (m *CategoryMutation) ClearCoverImageAssetID() {
	m.cover_image = nil
	m.clearedFields[category.FieldCoverImageAssetID] = struct{}{}
}

// CoverImageAssetIDCleared returns if the "cover_image_asset_id" field was cleared in this mutation.
func (m *CategoryMutation) CoverImageAssetIDCleared() bool {
	_, ok := m.clearedFields[category.FieldCoverImageAssetID]
	return ok
}

// ResetCoverImageAssetID resets all changes to the "cover_image_asset_id" field.
func (m *CategoryMutation) ResetCoverImageAssetID() {
	m.cover_image = nil
	delete(m.clearedFields, category.FieldCoverImageAssetID)
}

// SetMetadata sets the "metadata" field.
func (m *CategoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CategoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CategoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[category.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CategoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[category.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CategoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, category.FieldMetadata)
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *CategoryMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *CategoryMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *CategoryMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *CategoryMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *CategoryMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *CategoryMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *CategoryMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// SetParentID sets the "parent" edge to the Category entity by id.
func (m *CategoryMutation) SetParentID(id xid.ID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Category entity.
func (m *CategoryMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[category.FieldParentCategoryID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Category entity was cleared.
func (m *CategoryMutation) ParentCleared() bool {
	return m.ParentCategoryIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *CategoryMutation) ParentID() (id xid.ID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentIDs() (ids []xid.ID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Category entity by ids.
func (m *CategoryMutation) AddChildIDs(ids ...xid.ID) {
	if m.children == nil {
		m.children = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Category entity.
func (m *CategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Category entity was cleared.
func (m *CategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Category entity by IDs.
func (m *CategoryMutation) RemoveChildIDs(ids ...xid.ID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Category entity.
func (m *CategoryMutation) RemovedChildrenIDs() (ids []xid.ID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CategoryMutation) ChildrenIDs() (ids []xid.ID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetCoverImageID sets the "cover_image" edge to the Asset entity by id.
func (m *CategoryMutation) SetCoverImageID(id xid.ID) {
	m.cover_image = &id
}

// ClearCoverImage clears the "cover_image" edge to the Asset entity.
func (m *CategoryMutation) ClearCoverImage() {
	m.clearedcover_image = true
	m.clearedFields[category.FieldCoverImageAssetID] = struct{}{}
}

// CoverImageCleared reports if the "cover_image" edge to the Asset entity was cleared.
func (m *CategoryMutation) CoverImageCleared() bool {
	return m.CoverImageAssetIDCleared() || m.clearedcover_image
}

// CoverImageID returns the "cover_image" edge ID in the mutation.
func (m *CategoryMutation) CoverImageID() (id xid.ID, exists bool) {
	if m.cover_image != nil {
		return *m.cover_image, true
	}
	return
}

// CoverImageIDs returns the "cover_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoverImageID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) CoverImageIDs() (ids []xid.ID) {
	if id := m.cover_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoverImage resets all changes to the "cover_image" edge.
func (m *CategoryMutation) ResetCoverImage() {
	m.cover_image = nil
	m.clearedcover_image = false
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.colour != nil {
		fields = append(fields, category.FieldColour)
	}
	if m.sort != nil {
		fields = append(fields, category.FieldSort)
	}
	if m.admin != nil {
		fields = append(fields, category.FieldAdmin)
	}
	if m.parent != nil {
		fields = append(fields, category.FieldParentCategoryID)
	}
	if m.cover_image != nil {
		fields = append(fields, category.FieldCoverImageAssetID)
	}
	if m.metadata != nil {
		fields = append(fields, category.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldName:
		return m.Name()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldDescription:
		return m.Description()
	case category.FieldColour:
		return m.Colour()
	case category.FieldSort:
		return m.Sort()
	case category.FieldAdmin:
		return m.Admin()
	case category.FieldParentCategoryID:
		return m.ParentCategoryID()
	case category.FieldCoverImageAssetID:
		return m.CoverImageAssetID()
	case category.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldColour:
		return m.OldColour(ctx)
	case category.FieldSort:
		return m.OldSort(ctx)
	case category.FieldAdmin:
		return m.OldAdmin(ctx)
	case category.FieldParentCategoryID:
		return m.OldParentCategoryID(ctx)
	case category.FieldCoverImageAssetID:
		return m.OldCoverImageAssetID(ctx)
	case category.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldColour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColour(v)
		return nil
	case category.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case category.FieldAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	case category.FieldParentCategoryID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentCategoryID(v)
		return nil
	case category.FieldCoverImageAssetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImageAssetID(v)
		return nil
	case category.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, category.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldParentCategoryID) {
		fields = append(fields, category.FieldParentCategoryID)
	}
	if m.FieldCleared(category.FieldCoverImageAssetID) {
		fields = append(fields, category.FieldCoverImageAssetID)
	}
	if m.FieldCleared(category.FieldMetadata) {
		fields = append(fields, category.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldParentCategoryID:
		m.ClearParentCategoryID()
		return nil
	case category.FieldCoverImageAssetID:
		m.ClearCoverImageAssetID()
		return nil
	case category.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldColour:
		m.ResetColour()
		return nil
	case category.FieldSort:
		m.ResetSort()
		return nil
	case category.FieldAdmin:
		m.ResetAdmin()
		return nil
	case category.FieldParentCategoryID:
		m.ResetParentCategoryID()
		return nil
	case category.FieldCoverImageAssetID:
		m.ResetCoverImageAssetID()
		return nil
	case category.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.posts != nil {
		edges = append(edges, category.EdgePosts)
	}
	if m.parent != nil {
		edges = append(edges, category.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, category.EdgeChildren)
	}
	if m.cover_image != nil {
		edges = append(edges, category.EdgeCoverImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeCoverImage:
		if id := m.cover_image; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedposts != nil {
		edges = append(edges, category.EdgePosts)
	}
	if m.removedchildren != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedposts {
		edges = append(edges, category.EdgePosts)
	}
	if m.clearedparent {
		edges = append(edges, category.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, category.EdgeChildren)
	}
	if m.clearedcover_image {
		edges = append(edges, category.EdgeCoverImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgePosts:
		return m.clearedposts
	case category.EdgeParent:
		return m.clearedparent
	case category.EdgeChildren:
		return m.clearedchildren
	case category.EdgeCoverImage:
		return m.clearedcover_image
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeParent:
		m.ClearParent()
		return nil
	case category.EdgeCoverImage:
		m.ClearCoverImage()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgePosts:
		m.ResetPosts()
		return nil
	case category.EdgeParent:
		m.ResetParent()
		return nil
	case category.EdgeChildren:
		m.ResetChildren()
		return nil
	case category.EdgeCoverImage:
		m.ResetCoverImage()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CollectionMutation represents an operation that mutates the Collection nodes in the graph.
type CollectionMutation struct {
	config
	op                 Op
	typ                string
	id                 *xid.ID
	created_at         *time.Time
	updated_at         *time.Time
	indexed_at         *time.Time
	name               *string
	slug               *string
	description        *string
	visibility         *collection.Visibility
	clearedFields      map[string]struct{}
	owner              *xid.ID
	clearedowner       bool
	cover_image        *xid.ID
	clearedcover_image bool
	posts              map[xid.ID]struct{}
	removedposts       map[xid.ID]struct{}
	clearedposts       bool
	nodes              map[xid.ID]struct{}
	removednodes       map[xid.ID]struct{}
	clearednodes       bool
	done               bool
	oldValue           func(context.Context) (*Collection, error)
	predicates         []predicate.Collection
}

var _ ent.Mutation = (*CollectionMutation)(nil)

// collectionOption allows management of the mutation configuration using functional options.
type collectionOption func(*CollectionMutation)

// newCollectionMutation creates new mutation for the Collection entity.
func newCollectionMutation(c config, op Op, opts ...collectionOption) *CollectionMutation {
	m := &CollectionMutation{
		config:        c,
		op:            op,
		typ:           TypeCollection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollectionID sets the ID field of the mutation.
func withCollectionID(id xid.ID) collectionOption {
	return func(m *CollectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Collection
		)
		m.oldValue = func(ctx context.Context) (*Collection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Collection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollection sets the old Collection of the mutation.
func withCollection(node *Collection) collectionOption {
	return func(m *CollectionMutation) {
		m.oldValue = func(context.Context) (*Collection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Collection entities.
func (m *CollectionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CollectionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CollectionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Collection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CollectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CollectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CollectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIndexedAt sets the "indexed_at" field.
func (m *CollectionMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *CollectionMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *CollectionMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[collection.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *CollectionMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[collection.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *CollectionMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, collection.FieldIndexedAt)
}

// SetName sets the "name" field.
func (m *CollectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CollectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CollectionMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *CollectionMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CollectionMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CollectionMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *CollectionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CollectionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CollectionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[collection.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CollectionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[collection.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CollectionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, collection.FieldDescription)
}

// SetCoverAssetID sets the "cover_asset_id" field.
func (m *CollectionMutation) SetCoverAssetID(x xid.ID) {
	m.cover_image = &x
}

// CoverAssetID returns the value of the "cover_asset_id" field in the mutation.
func (m *CollectionMutation) CoverAssetID() (r xid.ID, exists bool) {
	v := m.cover_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverAssetID returns the old "cover_asset_id" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldCoverAssetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverAssetID: %w", err)
	}
	return oldValue.CoverAssetID, nil
}

// ClearCoverAssetID clears the value of the "cover_asset_id" field.
func (m *CollectionMutation) ClearCoverAssetID() {
	m.cover_image = nil
	m.clearedFields[collection.FieldCoverAssetID] = struct{}{}
}

// CoverAssetIDCleared returns if the "cover_asset_id" field was cleared in this mutation.
func (m *CollectionMutation) CoverAssetIDCleared() bool {
	_, ok := m.clearedFields[collection.FieldCoverAssetID]
	return ok
}

// ResetCoverAssetID resets all changes to the "cover_asset_id" field.
func (m *CollectionMutation) ResetCoverAssetID() {
	m.cover_image = nil
	delete(m.clearedFields, collection.FieldCoverAssetID)
}

// SetVisibility sets the "visibility" field.
func (m *CollectionMutation) SetVisibility(c collection.Visibility) {
	m.visibility = &c
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *CollectionMutation) Visibility() (r collection.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldVisibility(ctx context.Context) (v collection.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *CollectionMutation) ResetVisibility() {
	m.visibility = nil
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *CollectionMutation) SetOwnerID(id xid.ID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *CollectionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *CollectionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CollectionMutation) OwnerID() (id xid.ID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CollectionMutation) OwnerIDs() (ids []xid.ID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CollectionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetCoverImageID sets the "cover_image" edge to the Asset entity by id.
func (m *CollectionMutation) SetCoverImageID(id xid.ID) {
	m.cover_image = &id
}

// ClearCoverImage clears the "cover_image" edge to the Asset entity.
func (m *CollectionMutation) ClearCoverImage() {
	m.clearedcover_image = true
	m.clearedFields[collection.FieldCoverAssetID] = struct{}{}
}

// CoverImageCleared reports if the "cover_image" edge to the Asset entity was cleared.
func (m *CollectionMutation) CoverImageCleared() bool {
	return m.CoverAssetIDCleared() || m.clearedcover_image
}

// CoverImageID returns the "cover_image" edge ID in the mutation.
func (m *CollectionMutation) CoverImageID() (id xid.ID, exists bool) {
	if m.cover_image != nil {
		return *m.cover_image, true
	}
	return
}

// CoverImageIDs returns the "cover_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoverImageID instead. It exists only for internal usage by the builders.
func (m *CollectionMutation) CoverImageIDs() (ids []xid.ID) {
	if id := m.cover_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoverImage resets all changes to the "cover_image" edge.
func (m *CollectionMutation) ResetCoverImage() {
	m.cover_image = nil
	m.clearedcover_image = false
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *CollectionMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *CollectionMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *CollectionMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *CollectionMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *CollectionMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *CollectionMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *CollectionMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *CollectionMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *CollectionMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *CollectionMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *CollectionMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *CollectionMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *CollectionMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *CollectionMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// Where appends a list predicates to the CollectionMutation builder.
func (m *CollectionMutation) Where(ps ...predicate.Collection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Collection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Collection).
func (m *CollectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, collection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, collection.FieldUpdatedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, collection.FieldIndexedAt)
	}
	if m.name != nil {
		fields = append(fields, collection.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, collection.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, collection.FieldDescription)
	}
	if m.cover_image != nil {
		fields = append(fields, collection.FieldCoverAssetID)
	}
	if m.visibility != nil {
		fields = append(fields, collection.FieldVisibility)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collection.FieldCreatedAt:
		return m.CreatedAt()
	case collection.FieldUpdatedAt:
		return m.UpdatedAt()
	case collection.FieldIndexedAt:
		return m.IndexedAt()
	case collection.FieldName:
		return m.Name()
	case collection.FieldSlug:
		return m.Slug()
	case collection.FieldDescription:
		return m.Description()
	case collection.FieldCoverAssetID:
		return m.CoverAssetID()
	case collection.FieldVisibility:
		return m.Visibility()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case collection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case collection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case collection.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case collection.FieldName:
		return m.OldName(ctx)
	case collection.FieldSlug:
		return m.OldSlug(ctx)
	case collection.FieldDescription:
		return m.OldDescription(ctx)
	case collection.FieldCoverAssetID:
		return m.OldCoverAssetID(ctx)
	case collection.FieldVisibility:
		return m.OldVisibility(ctx)
	}
	return nil, fmt.Errorf("unknown Collection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case collection.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case collection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case collection.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case collection.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case collection.FieldCoverAssetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverAssetID(v)
		return nil
	case collection.FieldVisibility:
		v, ok := value.(collection.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Collection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(collection.FieldIndexedAt) {
		fields = append(fields, collection.FieldIndexedAt)
	}
	if m.FieldCleared(collection.FieldDescription) {
		fields = append(fields, collection.FieldDescription)
	}
	if m.FieldCleared(collection.FieldCoverAssetID) {
		fields = append(fields, collection.FieldCoverAssetID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectionMutation) ClearField(name string) error {
	switch name {
	case collection.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case collection.FieldDescription:
		m.ClearDescription()
		return nil
	case collection.FieldCoverAssetID:
		m.ClearCoverAssetID()
		return nil
	}
	return fmt.Errorf("unknown Collection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectionMutation) ResetField(name string) error {
	switch name {
	case collection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case collection.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case collection.FieldName:
		m.ResetName()
		return nil
	case collection.FieldSlug:
		m.ResetSlug()
		return nil
	case collection.FieldDescription:
		m.ResetDescription()
		return nil
	case collection.FieldCoverAssetID:
		m.ResetCoverAssetID()
		return nil
	case collection.FieldVisibility:
		m.ResetVisibility()
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, collection.EdgeOwner)
	}
	if m.cover_image != nil {
		edges = append(edges, collection.EdgeCoverImage)
	}
	if m.posts != nil {
		edges = append(edges, collection.EdgePosts)
	}
	if m.nodes != nil {
		edges = append(edges, collection.EdgeNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collection.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case collection.EdgeCoverImage:
		if id := m.cover_image; id != nil {
			return []ent.Value{*id}
		}
	case collection.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedposts != nil {
		edges = append(edges, collection.EdgePosts)
	}
	if m.removednodes != nil {
		edges = append(edges, collection.EdgeNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case collection.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, collection.EdgeOwner)
	}
	if m.clearedcover_image {
		edges = append(edges, collection.EdgeCoverImage)
	}
	if m.clearedposts {
		edges = append(edges, collection.EdgePosts)
	}
	if m.clearednodes {
		edges = append(edges, collection.EdgeNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectionMutation) EdgeCleared(name string) bool {
	switch name {
	case collection.EdgeOwner:
		return m.clearedowner
	case collection.EdgeCoverImage:
		return m.clearedcover_image
	case collection.EdgePosts:
		return m.clearedposts
	case collection.EdgeNodes:
		return m.clearednodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectionMutation) ClearEdge(name string) error {
	switch name {
	case collection.EdgeOwner:
		m.ClearOwner()
		return nil
	case collection.EdgeCoverImage:
		m.ClearCoverImage()
		return nil
	}
	return fmt.Errorf("unknown Collection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectionMutation) ResetEdge(name string) error {
	switch name {
	case collection.EdgeOwner:
		m.ResetOwner()
		return nil
	case collection.EdgeCoverImage:
		m.ResetCoverImage()
		return nil
	case collection.EdgePosts:
		m.ResetPosts()
		return nil
	case collection.EdgeNodes:
		m.ResetNodes()
		return nil
	}
	return fmt.Errorf("unknown Collection edge %s", name)
}

// CollectionNodeMutation represents an operation that mutates the CollectionNode nodes in the graph.
type CollectionNodeMutation struct {
	config
	op                Op
	typ               string
	created_at        *time.Time
	membership_type   *string
	clearedFields     map[string]struct{}
	collection        *xid.ID
	clearedcollection bool
	node              *xid.ID
	clearednode       bool
	done              bool
	oldValue          func(context.Context) (*CollectionNode, error)
	predicates        []predicate.CollectionNode
}

var _ ent.Mutation = (*CollectionNodeMutation)(nil)

// collectionnodeOption allows management of the mutation configuration using functional options.
type collectionnodeOption func(*CollectionNodeMutation)

// newCollectionNodeMutation creates new mutation for the CollectionNode entity.
func newCollectionNodeMutation(c config, op Op, opts ...collectionnodeOption) *CollectionNodeMutation {
	m := &CollectionNodeMutation{
		config:        c,
		op:            op,
		typ:           TypeCollectionNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectionNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectionNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectionNodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectionNodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectionNodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCollectionID sets the "collection_id" field.
func (m *CollectionNodeMutation) SetCollectionID(x xid.ID) {
	m.collection = &x
}

// CollectionID returns the value of the "collection_id" field in the mutation.
func (m *CollectionNodeMutation) CollectionID() (r xid.ID, exists bool) {
	v := m.collection
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectionID resets all changes to the "collection_id" field.
func (m *CollectionNodeMutation) ResetCollectionID() {
	m.collection = nil
}

// SetNodeID sets the "node_id" field.
func (m *CollectionNodeMutation) SetNodeID(x xid.ID) {
	m.node = &x
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *CollectionNodeMutation) NodeID() (r xid.ID, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *CollectionNodeMutation) ResetNodeID() {
	m.node = nil
}

// SetMembershipType sets the "membership_type" field.
func (m *CollectionNodeMutation) SetMembershipType(s string) {
	m.membership_type = &s
}

// MembershipType returns the value of the "membership_type" field in the mutation.
func (m *CollectionNodeMutation) MembershipType() (r string, exists bool) {
	v := m.membership_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetMembershipType resets all changes to the "membership_type" field.
func (m *CollectionNodeMutation) ResetMembershipType() {
	m.membership_type = nil
}

// ClearCollection clears the "collection" edge to the Collection entity.
func (m *CollectionNodeMutation) ClearCollection() {
	m.clearedcollection = true
	m.clearedFields[collectionnode.FieldCollectionID] = struct{}{}
}

// CollectionCleared reports if the "collection" edge to the Collection entity was cleared.
func (m *CollectionNodeMutation) CollectionCleared() bool {
	return m.clearedcollection
}

// CollectionIDs returns the "collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollectionID instead. It exists only for internal usage by the builders.
func (m *CollectionNodeMutation) CollectionIDs() (ids []xid.ID) {
	if id := m.collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollection resets all changes to the "collection" edge.
func (m *CollectionNodeMutation) ResetCollection() {
	m.collection = nil
	m.clearedcollection = false
}

// ClearNode clears the "node" edge to the Node entity.
func (m *CollectionNodeMutation) ClearNode() {
	m.clearednode = true
	m.clearedFields[collectionnode.FieldNodeID] = struct{}{}
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *CollectionNodeMutation) NodeCleared() bool {
	return m.clearednode
}

// NodeIDs returns the "node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeID instead. It exists only for internal usage by the builders.
func (m *CollectionNodeMutation) NodeIDs() (ids []xid.ID) {
	if id := m.node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *CollectionNodeMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
}

// Where appends a list predicates to the CollectionNodeMutation builder.
func (m *CollectionNodeMutation) Where(ps ...predicate.CollectionNode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollectionNodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollectionNodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CollectionNode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollectionNodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollectionNodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CollectionNode).
func (m *CollectionNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectionNodeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, collectionnode.FieldCreatedAt)
	}
	if m.collection != nil {
		fields = append(fields, collectionnode.FieldCollectionID)
	}
	if m.node != nil {
		fields = append(fields, collectionnode.FieldNodeID)
	}
	if m.membership_type != nil {
		fields = append(fields, collectionnode.FieldMembershipType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectionNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collectionnode.FieldCreatedAt:
		return m.CreatedAt()
	case collectionnode.FieldCollectionID:
		return m.CollectionID()
	case collectionnode.FieldNodeID:
		return m.NodeID()
	case collectionnode.FieldMembershipType:
		return m.MembershipType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectionNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema CollectionNode does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collectionnode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collectionnode.FieldCollectionID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionID(v)
		return nil
	case collectionnode.FieldNodeID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case collectionnode.FieldMembershipType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembershipType(v)
		return nil
	}
	return fmt.Errorf("unknown CollectionNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectionNodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectionNodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CollectionNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectionNodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectionNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectionNodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CollectionNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectionNodeMutation) ResetField(name string) error {
	switch name {
	case collectionnode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collectionnode.FieldCollectionID:
		m.ResetCollectionID()
		return nil
	case collectionnode.FieldNodeID:
		m.ResetNodeID()
		return nil
	case collectionnode.FieldMembershipType:
		m.ResetMembershipType()
		return nil
	}
	return fmt.Errorf("unknown CollectionNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectionNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.collection != nil {
		edges = append(edges, collectionnode.EdgeCollection)
	}
	if m.node != nil {
		edges = append(edges, collectionnode.EdgeNode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectionNodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collectionnode.EdgeCollection:
		if id := m.collection; id != nil {
			return []ent.Value{*id}
		}
	case collectionnode.EdgeNode:
		if id := m.node; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectionNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectionNodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectionNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcollection {
		edges = append(edges, collectionnode.EdgeCollection)
	}
	if m.clearednode {
		edges = append(edges, collectionnode.EdgeNode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectionNodeMutation) EdgeCleared(name string) bool {
	switch name {
	case collectionnode.EdgeCollection:
		return m.clearedcollection
	case collectionnode.EdgeNode:
		return m.clearednode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectionNodeMutation) ClearEdge(name string) error {
	switch name {
	case collectionnode.EdgeCollection:
		m.ClearCollection()
		return nil
	case collectionnode.EdgeNode:
		m.ClearNode()
		return nil
	}
	return fmt.Errorf("unknown CollectionNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectionNodeMutation) ResetEdge(name string) error {
	switch name {
	case collectionnode.EdgeCollection:
		m.ResetCollection()
		return nil
	case collectionnode.EdgeNode:
		m.ResetNode()
		return nil
	}
	return fmt.Errorf("unknown CollectionNode edge %s", name)
}

// CollectionPostMutation represents an operation that mutates the CollectionPost nodes in the graph.
type CollectionPostMutation struct {
	config
	op                Op
	typ               string
	created_at        *time.Time
	membership_type   *string
	clearedFields     map[string]struct{}
	collection        *xid.ID
	clearedcollection bool
	post              *xid.ID
	clearedpost       bool
	done              bool
	oldValue          func(context.Context) (*CollectionPost, error)
	predicates        []predicate.CollectionPost
}

var _ ent.Mutation = (*CollectionPostMutation)(nil)

// collectionpostOption allows management of the mutation configuration using functional options.
type collectionpostOption func(*CollectionPostMutation)

// newCollectionPostMutation creates new mutation for the CollectionPost entity.
func newCollectionPostMutation(c config, op Op, opts ...collectionpostOption) *CollectionPostMutation {
	m := &CollectionPostMutation{
		config:        c,
		op:            op,
		typ:           TypeCollectionPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectionPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectionPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectionPostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectionPostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectionPostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCollectionID sets the "collection_id" field.
func (m *CollectionPostMutation) SetCollectionID(x xid.ID) {
	m.collection = &x
}

// CollectionID returns the value of the "collection_id" field in the mutation.
func (m *CollectionPostMutation) CollectionID() (r xid.ID, exists bool) {
	v := m.collection
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectionID resets all changes to the "collection_id" field.
func (m *CollectionPostMutation) ResetCollectionID() {
	m.collection = nil
}

// SetPostID sets the "post_id" field.
func (m *CollectionPostMutation) SetPostID(x xid.ID) {
	m.post = &x
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *CollectionPostMutation) PostID() (r xid.ID, exists bool) {
	v := m.post
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostID resets all changes to the "post_id" field.
func (m *CollectionPostMutation) ResetPostID() {
	m.post = nil
}

// SetMembershipType sets the "membership_type" field.
func (m *CollectionPostMutation) SetMembershipType(s string) {
	m.membership_type = &s
}

// MembershipType returns the value of the "membership_type" field in the mutation.
func (m *CollectionPostMutation) MembershipType() (r string, exists bool) {
	v := m.membership_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetMembershipType resets all changes to the "membership_type" field.
func (m *CollectionPostMutation) ResetMembershipType() {
	m.membership_type = nil
}

// ClearCollection clears the "collection" edge to the Collection entity.
func (m *CollectionPostMutation) ClearCollection() {
	m.clearedcollection = true
	m.clearedFields[collectionpost.FieldCollectionID] = struct{}{}
}

// CollectionCleared reports if the "collection" edge to the Collection entity was cleared.
func (m *CollectionPostMutation) CollectionCleared() bool {
	return m.clearedcollection
}

// CollectionIDs returns the "collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollectionID instead. It exists only for internal usage by the builders.
func (m *CollectionPostMutation) CollectionIDs() (ids []xid.ID) {
	if id := m.collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollection resets all changes to the "collection" edge.
func (m *CollectionPostMutation) ResetCollection() {
	m.collection = nil
	m.clearedcollection = false
}

// ClearPost clears the "post" edge to the Post entity.
func (m *CollectionPostMutation) ClearPost() {
	m.clearedpost = true
	m.clearedFields[collectionpost.FieldPostID] = struct{}{}
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *CollectionPostMutation) PostCleared() bool {
	return m.clearedpost
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *CollectionPostMutation) PostIDs() (ids []xid.ID) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *CollectionPostMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the CollectionPostMutation builder.
func (m *CollectionPostMutation) Where(ps ...predicate.CollectionPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollectionPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollectionPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CollectionPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollectionPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollectionPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CollectionPost).
func (m *CollectionPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectionPostMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, collectionpost.FieldCreatedAt)
	}
	if m.collection != nil {
		fields = append(fields, collectionpost.FieldCollectionID)
	}
	if m.post != nil {
		fields = append(fields, collectionpost.FieldPostID)
	}
	if m.membership_type != nil {
		fields = append(fields, collectionpost.FieldMembershipType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectionPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collectionpost.FieldCreatedAt:
		return m.CreatedAt()
	case collectionpost.FieldCollectionID:
		return m.CollectionID()
	case collectionpost.FieldPostID:
		return m.PostID()
	case collectionpost.FieldMembershipType:
		return m.MembershipType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectionPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema CollectionPost does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collectionpost.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collectionpost.FieldCollectionID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionID(v)
		return nil
	case collectionpost.FieldPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case collectionpost.FieldMembershipType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembershipType(v)
		return nil
	}
	return fmt.Errorf("unknown CollectionPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectionPostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectionPostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CollectionPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectionPostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectionPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectionPostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CollectionPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectionPostMutation) ResetField(name string) error {
	switch name {
	case collectionpost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collectionpost.FieldCollectionID:
		m.ResetCollectionID()
		return nil
	case collectionpost.FieldPostID:
		m.ResetPostID()
		return nil
	case collectionpost.FieldMembershipType:
		m.ResetMembershipType()
		return nil
	}
	return fmt.Errorf("unknown CollectionPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectionPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.collection != nil {
		edges = append(edges, collectionpost.EdgeCollection)
	}
	if m.post != nil {
		edges = append(edges, collectionpost.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectionPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collectionpost.EdgeCollection:
		if id := m.collection; id != nil {
			return []ent.Value{*id}
		}
	case collectionpost.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectionPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectionPostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectionPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcollection {
		edges = append(edges, collectionpost.EdgeCollection)
	}
	if m.clearedpost {
		edges = append(edges, collectionpost.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectionPostMutation) EdgeCleared(name string) bool {
	switch name {
	case collectionpost.EdgeCollection:
		return m.clearedcollection
	case collectionpost.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectionPostMutation) ClearEdge(name string) error {
	switch name {
	case collectionpost.EdgeCollection:
		m.ClearCollection()
		return nil
	case collectionpost.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown CollectionPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectionPostMutation) ResetEdge(name string) error {
	switch name {
	case collectionpost.EdgeCollection:
		m.ResetCollection()
		return nil
	case collectionpost.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown CollectionPost edge %s", name)
}

// EmailMutation represents an operation that mutates the Email nodes in the graph.
type EmailMutation struct {
	config
	op                Op
	typ               string
	id                *xid.ID
	created_at        *time.Time
	email_address     *string
	verification_code *string
	verified          *bool
	clearedFields     map[string]struct{}
	account           *xid.ID
	clearedaccount    bool
	done              bool
	oldValue          func(context.Context) (*Email, error)
	predicates        []predicate.Email
}

var _ ent.Mutation = (*EmailMutation)(nil)

// emailOption allows management of the mutation configuration using functional options.
type emailOption func(*EmailMutation)

// newEmailMutation creates new mutation for the Email entity.
func newEmailMutation(c config, op Op, opts ...emailOption) *EmailMutation {
	m := &EmailMutation{
		config:        c,
		op:            op,
		typ:           TypeEmail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailID sets the ID field of the mutation.
func withEmailID(id xid.ID) emailOption {
	return func(m *EmailMutation) {
		var (
			err   error
			once  sync.Once
			value *Email
		)
		m.oldValue = func(ctx context.Context) (*Email, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Email.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmail sets the old Email of the mutation.
func withEmail(node *Email) emailOption {
	return func(m *EmailMutation) {
		m.oldValue = func(context.Context) (*Email, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Email entities.
func (m *EmailMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Email.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountID sets the "account_id" field.
func (m *EmailMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *EmailMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldAccountID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *EmailMutation) ClearAccountID() {
	m.account = nil
	m.clearedFields[email.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *EmailMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[email.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *EmailMutation) ResetAccountID() {
	m.account = nil
	delete(m.clearedFields, email.FieldAccountID)
}

// SetEmailAddress sets the "email_address" field.
func (m *EmailMutation) SetEmailAddress(s string) {
	m.email_address = &s
}

// EmailAddress returns the value of the "email_address" field in the mutation.
func (m *EmailMutation) EmailAddress() (r string, exists bool) {
	v := m.email_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddress returns the old "email_address" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldEmailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddress: %w", err)
	}
	return oldValue.EmailAddress, nil
}

// ResetEmailAddress resets all changes to the "email_address" field.
func (m *EmailMutation) ResetEmailAddress() {
	m.email_address = nil
}

// SetVerificationCode sets the "verification_code" field.
func (m *EmailMutation) SetVerificationCode(s string) {
	m.verification_code = &s
}

// VerificationCode returns the value of the "verification_code" field in the mutation.
func (m *EmailMutation) VerificationCode() (r string, exists bool) {
	v := m.verification_code
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationCode returns the old "verification_code" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldVerificationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationCode: %w", err)
	}
	return oldValue.VerificationCode, nil
}

// ResetVerificationCode resets all changes to the "verification_code" field.
func (m *EmailMutation) ResetVerificationCode() {
	m.verification_code = nil
}

// SetVerified sets the "verified" field.
func (m *EmailMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *EmailMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *EmailMutation) ResetVerified() {
	m.verified = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *EmailMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[email.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *EmailMutation) AccountCleared() bool {
	return m.AccountIDCleared() || m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *EmailMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *EmailMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the EmailMutation builder.
func (m *EmailMutation) Where(ps ...predicate.Email) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Email, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Email).
func (m *EmailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, email.FieldCreatedAt)
	}
	if m.account != nil {
		fields = append(fields, email.FieldAccountID)
	}
	if m.email_address != nil {
		fields = append(fields, email.FieldEmailAddress)
	}
	if m.verification_code != nil {
		fields = append(fields, email.FieldVerificationCode)
	}
	if m.verified != nil {
		fields = append(fields, email.FieldVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case email.FieldCreatedAt:
		return m.CreatedAt()
	case email.FieldAccountID:
		return m.AccountID()
	case email.FieldEmailAddress:
		return m.EmailAddress()
	case email.FieldVerificationCode:
		return m.VerificationCode()
	case email.FieldVerified:
		return m.Verified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case email.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case email.FieldAccountID:
		return m.OldAccountID(ctx)
	case email.FieldEmailAddress:
		return m.OldEmailAddress(ctx)
	case email.FieldVerificationCode:
		return m.OldVerificationCode(ctx)
	case email.FieldVerified:
		return m.OldVerified(ctx)
	}
	return nil, fmt.Errorf("unknown Email field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case email.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case email.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case email.FieldEmailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddress(v)
		return nil
	case email.FieldVerificationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationCode(v)
		return nil
	case email.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Email numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(email.FieldAccountID) {
		fields = append(fields, email.FieldAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailMutation) ClearField(name string) error {
	switch name {
	case email.FieldAccountID:
		m.ClearAccountID()
		return nil
	}
	return fmt.Errorf("unknown Email nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailMutation) ResetField(name string) error {
	switch name {
	case email.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case email.FieldAccountID:
		m.ResetAccountID()
		return nil
	case email.FieldEmailAddress:
		m.ResetEmailAddress()
		return nil
	case email.FieldVerificationCode:
		m.ResetVerificationCode()
		return nil
	case email.FieldVerified:
		m.ResetVerified()
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.account != nil {
		edges = append(edges, email.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case email.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccount {
		edges = append(edges, email.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailMutation) EdgeCleared(name string) bool {
	switch name {
	case email.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailMutation) ClearEdge(name string) error {
	switch name {
	case email.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Email unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailMutation) ResetEdge(name string) error {
	switch name {
	case email.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown Email edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                    Op
	typ                   string
	id                    *xid.ID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	indexed_at            *time.Time
	name                  *string
	slug                  *string
	description           *string
	start_time            *time.Time
	end_time              *time.Time
	participation_policy  *string
	visibility            *event.Visibility
	location_type         *string
	location_name         *string
	location_address      *string
	location_latitude     *float64
	addlocation_latitude  *float64
	location_longitude    *float64
	addlocation_longitude *float64
	location_url          *string
	capacity              *int
	addcapacity           *int
	metadata              *map[string]interface{}
	clearedFields         map[string]struct{}
	participants          map[xid.ID]struct{}
	removedparticipants   map[xid.ID]struct{}
	clearedparticipants   bool
	thread                *xid.ID
	clearedthread         bool
	primary_image         *xid.ID
	clearedprimary_image  bool
	done                  bool
	oldValue              func(context.Context) (*Event, error)
	predicates            []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id xid.ID) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[event.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[event.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, event.FieldDeletedAt)
}

// SetIndexedAt sets the "indexed_at" field.
func (m *EventMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *EventMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *EventMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[event.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *EventMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[event.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *EventMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, event.FieldIndexedAt)
}

// SetName sets the "name" field.
func (m *EventMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EventMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EventMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *EventMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *EventMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *EventMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *EventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[event.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[event.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, event.FieldDescription)
}

// SetStartTime sets the "start_time" field.
func (m *EventMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *EventMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *EventMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *EventMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *EventMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *EventMutation) ResetEndTime() {
	m.end_time = nil
}

// SetParticipationPolicy sets the "participation_policy" field.
func (m *EventMutation) SetParticipationPolicy(s string) {
	m.participation_policy = &s
}

// ParticipationPolicy returns the value of the "participation_policy" field in the mutation.
func (m *EventMutation) ParticipationPolicy() (r string, exists bool) {
	v := m.participation_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipationPolicy returns the old "participation_policy" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldParticipationPolicy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParticipationPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParticipationPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipationPolicy: %w", err)
	}
	return oldValue.ParticipationPolicy, nil
}

// ResetParticipationPolicy resets all changes to the "participation_policy" field.
func (m *EventMutation) ResetParticipationPolicy() {
	m.participation_policy = nil
}

// SetVisibility sets the "visibility" field.
func (m *EventMutation) SetVisibility(e event.Visibility) {
	m.visibility = &e
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *EventMutation) Visibility() (r event.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVisibility(ctx context.Context) (v event.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *EventMutation) ResetVisibility() {
	m.visibility = nil
}

// SetLocationType sets the "location_type" field.
func (m *EventMutation) SetLocationType(s string) {
	m.location_type = &s
}

// LocationType returns the value of the "location_type" field in the mutation.
func (m *EventMutation) LocationType() (r string, exists bool) {
	v := m.location_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationType returns the old "location_type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationType: %w", err)
	}
	return oldValue.LocationType, nil
}

// ClearLocationType clears the value of the "location_type" field.
func (m *EventMutation) ClearLocationType() {
	m.location_type = nil
	m.clearedFields[event.FieldLocationType] = struct{}{}
}

// LocationTypeCleared returns if the "location_type" field was cleared in this mutation.
func (m *EventMutation) LocationTypeCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationType]
	return ok
}

// ResetLocationType resets all changes to the "location_type" field.
func (m *EventMutation) ResetLocationType() {
	m.location_type = nil
	delete(m.clearedFields, event.FieldLocationType)
}

// SetLocationName sets the "location_name" field.
func (m *EventMutation) SetLocationName(s string) {
	m.location_name = &s
}

// LocationName returns the value of the "location_name" field in the mutation.
func (m *EventMutation) LocationName() (r string, exists bool) {
	v := m.location_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationName returns the old "location_name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationName: %w", err)
	}
	return oldValue.LocationName, nil
}

// ClearLocationName clears the value of the "location_name" field.
func (m *EventMutation) ClearLocationName() {
	m.location_name = nil
	m.clearedFields[event.FieldLocationName] = struct{}{}
}

// LocationNameCleared returns if the "location_name" field was cleared in this mutation.
func (m *EventMutation) LocationNameCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationName]
	return ok
}

// ResetLocationName resets all changes to the "location_name" field.
func (m *EventMutation) ResetLocationName() {
	m.location_name = nil
	delete(m.clearedFields, event.FieldLocationName)
}

// SetLocationAddress sets the "location_address" field.
func (m *EventMutation) SetLocationAddress(s string) {
	m.location_address = &s
}

// LocationAddress returns the value of the "location_address" field in the mutation.
func (m *EventMutation) LocationAddress() (r string, exists bool) {
	v := m.location_address
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationAddress returns the old "location_address" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationAddress: %w", err)
	}
	return oldValue.LocationAddress, nil
}

// ClearLocationAddress clears the value of the "location_address" field.
func (m *EventMutation) ClearLocationAddress() {
	m.location_address = nil
	m.clearedFields[event.FieldLocationAddress] = struct{}{}
}

// LocationAddressCleared returns if the "location_address" field was cleared in this mutation.
func (m *EventMutation) LocationAddressCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationAddress]
	return ok
}

// ResetLocationAddress resets all changes to the "location_address" field.
func (m *EventMutation) ResetLocationAddress() {
	m.location_address = nil
	delete(m.clearedFields, event.FieldLocationAddress)
}

// SetLocationLatitude sets the "location_latitude" field.
func (m *EventMutation) SetLocationLatitude(f float64) {
	m.location_latitude = &f
	m.addlocation_latitude = nil
}

// LocationLatitude returns the value of the "location_latitude" field in the mutation.
func (m *EventMutation) LocationLatitude() (r float64, exists bool) {
	v := m.location_latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationLatitude returns the old "location_latitude" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationLatitude: %w", err)
	}
	return oldValue.LocationLatitude, nil
}

// AddLocationLatitude adds f to the "location_latitude" field.
func (m *EventMutation) AddLocationLatitude(f float64) {
	if m.addlocation_latitude != nil {
		*m.addlocation_latitude += f
	} else {
		m.addlocation_latitude = &f
	}
}

// AddedLocationLatitude returns the value that was added to the "location_latitude" field in this mutation.
func (m *EventMutation) AddedLocationLatitude() (r float64, exists bool) {
	v := m.addlocation_latitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocationLatitude clears the value of the "location_latitude" field.
func (m *EventMutation) ClearLocationLatitude() {
	m.location_latitude = nil
	m.addlocation_latitude = nil
	m.clearedFields[event.FieldLocationLatitude] = struct{}{}
}

// LocationLatitudeCleared returns if the "location_latitude" field was cleared in this mutation.
func (m *EventMutation) LocationLatitudeCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationLatitude]
	return ok
}

// ResetLocationLatitude resets all changes to the "location_latitude" field.
func (m *EventMutation) ResetLocationLatitude() {
	m.location_latitude = nil
	m.addlocation_latitude = nil
	delete(m.clearedFields, event.FieldLocationLatitude)
}

// SetLocationLongitude sets the "location_longitude" field.
func (m *EventMutation) SetLocationLongitude(f float64) {
	m.location_longitude = &f
	m.addlocation_longitude = nil
}

// LocationLongitude returns the value of the "location_longitude" field in the mutation.
func (m *EventMutation) LocationLongitude() (r float64, exists bool) {
	v := m.location_longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationLongitude returns the old "location_longitude" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationLongitude: %w", err)
	}
	return oldValue.LocationLongitude, nil
}

// AddLocationLongitude adds f to the "location_longitude" field.
func (m *EventMutation) AddLocationLongitude(f float64) {
	if m.addlocation_longitude != nil {
		*m.addlocation_longitude += f
	} else {
		m.addlocation_longitude = &f
	}
}

// AddedLocationLongitude returns the value that was added to the "location_longitude" field in this mutation.
func (m *EventMutation) AddedLocationLongitude() (r float64, exists bool) {
	v := m.addlocation_longitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocationLongitude clears the value of the "location_longitude" field.
func (m *EventMutation) ClearLocationLongitude() {
	m.location_longitude = nil
	m.addlocation_longitude = nil
	m.clearedFields[event.FieldLocationLongitude] = struct{}{}
}

// LocationLongitudeCleared returns if the "location_longitude" field was cleared in this mutation.
func (m *EventMutation) LocationLongitudeCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationLongitude]
	return ok
}

// ResetLocationLongitude resets all changes to the "location_longitude" field.
func (m *EventMutation) ResetLocationLongitude() {
	m.location_longitude = nil
	m.addlocation_longitude = nil
	delete(m.clearedFields, event.FieldLocationLongitude)
}

// SetLocationURL sets the "location_url" field.
func (m *EventMutation) SetLocationURL(s string) {
	m.location_url = &s
}

// LocationURL returns the value of the "location_url" field in the mutation.
func (m *EventMutation) LocationURL() (r string, exists bool) {
	v := m.location_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationURL returns the old "location_url" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationURL: %w", err)
	}
	return oldValue.LocationURL, nil
}

// ClearLocationURL clears the value of the "location_url" field.
func (m *EventMutation) ClearLocationURL() {
	m.location_url = nil
	m.clearedFields[event.FieldLocationURL] = struct{}{}
}

// LocationURLCleared returns if the "location_url" field was cleared in this mutation.
func (m *EventMutation) LocationURLCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationURL]
	return ok
}

// ResetLocationURL resets all changes to the "location_url" field.
func (m *EventMutation) ResetLocationURL() {
	m.location_url = nil
	delete(m.clearedFields, event.FieldLocationURL)
}

// SetCapacity sets the "capacity" field.
func (m *EventMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *EventMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCapacity(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *EventMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *EventMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCapacity clears the value of the "capacity" field.
func (m *EventMutation) ClearCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	m.clearedFields[event.FieldCapacity] = struct{}{}
}

// CapacityCleared returns if the "capacity" field was cleared in this mutation.
func (m *EventMutation) CapacityCleared() bool {
	_, ok := m.clearedFields[event.FieldCapacity]
	return ok
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *EventMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	delete(m.clearedFields, event.FieldCapacity)
}

// SetMetadata sets the "metadata" field.
func (m *EventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[event.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[event.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, event.FieldMetadata)
}

// AddParticipantIDs adds the "participants" edge to the EventParticipant entity by ids.
func (m *EventMutation) AddParticipantIDs(ids ...xid.ID) {
	if m.participants == nil {
		m.participants = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the EventParticipant entity.
func (m *EventMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the EventParticipant entity was cleared.
func (m *EventMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the EventParticipant entity by IDs.
func (m *EventMutation) RemoveParticipantIDs(ids ...xid.ID) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the EventParticipant entity.
func (m *EventMutation) RemovedParticipantsIDs() (ids []xid.ID) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *EventMutation) ParticipantsIDs() (ids []xid.ID) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *EventMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// SetThreadID sets the "thread" edge to the Post entity by id.
func (m *EventMutation) SetThreadID(id xid.ID) {
	m.thread = &id
}

// ClearThread clears the "thread" edge to the Post entity.
func (m *EventMutation) ClearThread() {
	m.clearedthread = true
}

// ThreadCleared reports if the "thread" edge to the Post entity was cleared.
func (m *EventMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadID returns the "thread" edge ID in the mutation.
func (m *EventMutation) ThreadID() (id xid.ID, exists bool) {
	if m.thread != nil {
		return *m.thread, true
	}
	return
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *EventMutation) ThreadIDs() (ids []xid.ID) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *EventMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// SetPrimaryImageID sets the "primary_image" edge to the Asset entity by id.
func (m *EventMutation) SetPrimaryImageID(id xid.ID) {
	m.primary_image = &id
}

// ClearPrimaryImage clears the "primary_image" edge to the Asset entity.
func (m *EventMutation) ClearPrimaryImage() {
	m.clearedprimary_image = true
}

// PrimaryImageCleared reports if the "primary_image" edge to the Asset entity was cleared.
func (m *EventMutation) PrimaryImageCleared() bool {
	return m.clearedprimary_image
}

// PrimaryImageID returns the "primary_image" edge ID in the mutation.
func (m *EventMutation) PrimaryImageID() (id xid.ID, exists bool) {
	if m.primary_image != nil {
		return *m.primary_image, true
	}
	return
}

// PrimaryImageIDs returns the "primary_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryImageID instead. It exists only for internal usage by the builders.
func (m *EventMutation) PrimaryImageIDs() (ids []xid.ID) {
	if id := m.primary_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryImage resets all changes to the "primary_image" edge.
func (m *EventMutation) ResetPrimaryImage() {
	m.primary_image = nil
	m.clearedprimary_image = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, event.FieldIndexedAt)
	}
	if m.name != nil {
		fields = append(fields, event.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, event.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, event.FieldDescription)
	}
	if m.start_time != nil {
		fields = append(fields, event.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, event.FieldEndTime)
	}
	if m.participation_policy != nil {
		fields = append(fields, event.FieldParticipationPolicy)
	}
	if m.visibility != nil {
		fields = append(fields, event.FieldVisibility)
	}
	if m.location_type != nil {
		fields = append(fields, event.FieldLocationType)
	}
	if m.location_name != nil {
		fields = append(fields, event.FieldLocationName)
	}
	if m.location_address != nil {
		fields = append(fields, event.FieldLocationAddress)
	}
	if m.location_latitude != nil {
		fields = append(fields, event.FieldLocationLatitude)
	}
	if m.location_longitude != nil {
		fields = append(fields, event.FieldLocationLongitude)
	}
	if m.location_url != nil {
		fields = append(fields, event.FieldLocationURL)
	}
	if m.capacity != nil {
		fields = append(fields, event.FieldCapacity)
	}
	if m.metadata != nil {
		fields = append(fields, event.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldDeletedAt:
		return m.DeletedAt()
	case event.FieldIndexedAt:
		return m.IndexedAt()
	case event.FieldName:
		return m.Name()
	case event.FieldSlug:
		return m.Slug()
	case event.FieldDescription:
		return m.Description()
	case event.FieldStartTime:
		return m.StartTime()
	case event.FieldEndTime:
		return m.EndTime()
	case event.FieldParticipationPolicy:
		return m.ParticipationPolicy()
	case event.FieldVisibility:
		return m.Visibility()
	case event.FieldLocationType:
		return m.LocationType()
	case event.FieldLocationName:
		return m.LocationName()
	case event.FieldLocationAddress:
		return m.LocationAddress()
	case event.FieldLocationLatitude:
		return m.LocationLatitude()
	case event.FieldLocationLongitude:
		return m.LocationLongitude()
	case event.FieldLocationURL:
		return m.LocationURL()
	case event.FieldCapacity:
		return m.Capacity()
	case event.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case event.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case event.FieldName:
		return m.OldName(ctx)
	case event.FieldSlug:
		return m.OldSlug(ctx)
	case event.FieldDescription:
		return m.OldDescription(ctx)
	case event.FieldStartTime:
		return m.OldStartTime(ctx)
	case event.FieldEndTime:
		return m.OldEndTime(ctx)
	case event.FieldParticipationPolicy:
		return m.OldParticipationPolicy(ctx)
	case event.FieldVisibility:
		return m.OldVisibility(ctx)
	case event.FieldLocationType:
		return m.OldLocationType(ctx)
	case event.FieldLocationName:
		return m.OldLocationName(ctx)
	case event.FieldLocationAddress:
		return m.OldLocationAddress(ctx)
	case event.FieldLocationLatitude:
		return m.OldLocationLatitude(ctx)
	case event.FieldLocationLongitude:
		return m.OldLocationLongitude(ctx)
	case event.FieldLocationURL:
		return m.OldLocationURL(ctx)
	case event.FieldCapacity:
		return m.OldCapacity(ctx)
	case event.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case event.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case event.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case event.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case event.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case event.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case event.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case event.FieldParticipationPolicy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipationPolicy(v)
		return nil
	case event.FieldVisibility:
		v, ok := value.(event.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case event.FieldLocationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationType(v)
		return nil
	case event.FieldLocationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationName(v)
		return nil
	case event.FieldLocationAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationAddress(v)
		return nil
	case event.FieldLocationLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationLatitude(v)
		return nil
	case event.FieldLocationLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationLongitude(v)
		return nil
	case event.FieldLocationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationURL(v)
		return nil
	case event.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case event.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addlocation_latitude != nil {
		fields = append(fields, event.FieldLocationLatitude)
	}
	if m.addlocation_longitude != nil {
		fields = append(fields, event.FieldLocationLongitude)
	}
	if m.addcapacity != nil {
		fields = append(fields, event.FieldCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldLocationLatitude:
		return m.AddedLocationLatitude()
	case event.FieldLocationLongitude:
		return m.AddedLocationLongitude()
	case event.FieldCapacity:
		return m.AddedCapacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldLocationLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationLatitude(v)
		return nil
	case event.FieldLocationLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationLongitude(v)
		return nil
	case event.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldDeletedAt) {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.FieldCleared(event.FieldIndexedAt) {
		fields = append(fields, event.FieldIndexedAt)
	}
	if m.FieldCleared(event.FieldDescription) {
		fields = append(fields, event.FieldDescription)
	}
	if m.FieldCleared(event.FieldLocationType) {
		fields = append(fields, event.FieldLocationType)
	}
	if m.FieldCleared(event.FieldLocationName) {
		fields = append(fields, event.FieldLocationName)
	}
	if m.FieldCleared(event.FieldLocationAddress) {
		fields = append(fields, event.FieldLocationAddress)
	}
	if m.FieldCleared(event.FieldLocationLatitude) {
		fields = append(fields, event.FieldLocationLatitude)
	}
	if m.FieldCleared(event.FieldLocationLongitude) {
		fields = append(fields, event.FieldLocationLongitude)
	}
	if m.FieldCleared(event.FieldLocationURL) {
		fields = append(fields, event.FieldLocationURL)
	}
	if m.FieldCleared(event.FieldCapacity) {
		fields = append(fields, event.FieldCapacity)
	}
	if m.FieldCleared(event.FieldMetadata) {
		fields = append(fields, event.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case event.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case event.FieldDescription:
		m.ClearDescription()
		return nil
	case event.FieldLocationType:
		m.ClearLocationType()
		return nil
	case event.FieldLocationName:
		m.ClearLocationName()
		return nil
	case event.FieldLocationAddress:
		m.ClearLocationAddress()
		return nil
	case event.FieldLocationLatitude:
		m.ClearLocationLatitude()
		return nil
	case event.FieldLocationLongitude:
		m.ClearLocationLongitude()
		return nil
	case event.FieldLocationURL:
		m.ClearLocationURL()
		return nil
	case event.FieldCapacity:
		m.ClearCapacity()
		return nil
	case event.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case event.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case event.FieldName:
		m.ResetName()
		return nil
	case event.FieldSlug:
		m.ResetSlug()
		return nil
	case event.FieldDescription:
		m.ResetDescription()
		return nil
	case event.FieldStartTime:
		m.ResetStartTime()
		return nil
	case event.FieldEndTime:
		m.ResetEndTime()
		return nil
	case event.FieldParticipationPolicy:
		m.ResetParticipationPolicy()
		return nil
	case event.FieldVisibility:
		m.ResetVisibility()
		return nil
	case event.FieldLocationType:
		m.ResetLocationType()
		return nil
	case event.FieldLocationName:
		m.ResetLocationName()
		return nil
	case event.FieldLocationAddress:
		m.ResetLocationAddress()
		return nil
	case event.FieldLocationLatitude:
		m.ResetLocationLatitude()
		return nil
	case event.FieldLocationLongitude:
		m.ResetLocationLongitude()
		return nil
	case event.FieldLocationURL:
		m.ResetLocationURL()
		return nil
	case event.FieldCapacity:
		m.ResetCapacity()
		return nil
	case event.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.participants != nil {
		edges = append(edges, event.EdgeParticipants)
	}
	if m.thread != nil {
		edges = append(edges, event.EdgeThread)
	}
	if m.primary_image != nil {
		edges = append(edges, event.EdgePrimaryImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgePrimaryImage:
		if id := m.primary_image; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedparticipants != nil {
		edges = append(edges, event.EdgeParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparticipants {
		edges = append(edges, event.EdgeParticipants)
	}
	if m.clearedthread {
		edges = append(edges, event.EdgeThread)
	}
	if m.clearedprimary_image {
		edges = append(edges, event.EdgePrimaryImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeParticipants:
		return m.clearedparticipants
	case event.EdgeThread:
		return m.clearedthread
	case event.EdgePrimaryImage:
		return m.clearedprimary_image
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeThread:
		m.ClearThread()
		return nil
	case event.EdgePrimaryImage:
		m.ClearPrimaryImage()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case event.EdgeThread:
		m.ResetThread()
		return nil
	case event.EdgePrimaryImage:
		m.ResetPrimaryImage()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// EventParticipantMutation represents an operation that mutates the EventParticipant nodes in the graph.
type EventParticipantMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	role           *string
	status         *string
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	event          *xid.ID
	clearedevent   bool
	done           bool
	oldValue       func(context.Context) (*EventParticipant, error)
	predicates     []predicate.EventParticipant
}

var _ ent.Mutation = (*EventParticipantMutation)(nil)

// eventparticipantOption allows management of the mutation configuration using functional options.
type eventparticipantOption func(*EventParticipantMutation)

// newEventParticipantMutation creates new mutation for the EventParticipant entity.
func newEventParticipantMutation(c config, op Op, opts ...eventparticipantOption) *EventParticipantMutation {
	m := &EventParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeEventParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventParticipantID sets the ID field of the mutation.
func withEventParticipantID(id xid.ID) eventparticipantOption {
	return func(m *EventParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *EventParticipant
		)
		m.oldValue = func(ctx context.Context) (*EventParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventParticipant sets the old EventParticipant of the mutation.
func withEventParticipant(node *EventParticipant) eventparticipantOption {
	return func(m *EventParticipantMutation) {
		m.oldValue = func(context.Context) (*EventParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventParticipant entities.
func (m *EventParticipantMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventParticipantMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventParticipantMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventParticipantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventParticipantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventParticipantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetRole sets the "role" field.
func (m *EventParticipantMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *EventParticipantMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *EventParticipantMutation) ResetRole() {
	m.role = nil
}

// SetStatus sets the "status" field.
func (m *EventParticipantMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EventParticipantMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EventParticipantMutation) ResetStatus() {
	m.status = nil
}

// SetAccountID sets the "account_id" field.
func (m *EventParticipantMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *EventParticipantMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *EventParticipantMutation) ResetAccountID() {
	m.account = nil
}

// SetEventID sets the "event_id" field.
func (m *EventParticipantMutation) SetEventID(x xid.ID) {
	m.event = &x
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *EventParticipantMutation) EventID() (r xid.ID, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldEventID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *EventParticipantMutation) ResetEventID() {
	m.event = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *EventParticipantMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[eventparticipant.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *EventParticipantMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *EventParticipantMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *EventParticipantMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *EventParticipantMutation) ClearEvent() {
	m.clearedevent = true
	m.clearedFields[eventparticipant.FieldEventID] = struct{}{}
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *EventParticipantMutation) EventCleared() bool {
	return m.clearedevent
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *EventParticipantMutation) EventIDs() (ids []xid.ID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *EventParticipantMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the EventParticipantMutation builder.
func (m *EventParticipantMutation) Where(ps ...predicate.EventParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventParticipant).
func (m *EventParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventParticipantMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, eventparticipant.FieldCreatedAt)
	}
	if m.role != nil {
		fields = append(fields, eventparticipant.FieldRole)
	}
	if m.status != nil {
		fields = append(fields, eventparticipant.FieldStatus)
	}
	if m.account != nil {
		fields = append(fields, eventparticipant.FieldAccountID)
	}
	if m.event != nil {
		fields = append(fields, eventparticipant.FieldEventID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventparticipant.FieldCreatedAt:
		return m.CreatedAt()
	case eventparticipant.FieldRole:
		return m.Role()
	case eventparticipant.FieldStatus:
		return m.Status()
	case eventparticipant.FieldAccountID:
		return m.AccountID()
	case eventparticipant.FieldEventID:
		return m.EventID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventparticipant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case eventparticipant.FieldRole:
		return m.OldRole(ctx)
	case eventparticipant.FieldStatus:
		return m.OldStatus(ctx)
	case eventparticipant.FieldAccountID:
		return m.OldAccountID(ctx)
	case eventparticipant.FieldEventID:
		return m.OldEventID(ctx)
	}
	return nil, fmt.Errorf("unknown EventParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventparticipant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case eventparticipant.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case eventparticipant.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case eventparticipant.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case eventparticipant.FieldEventID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	}
	return fmt.Errorf("unknown EventParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventParticipantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventParticipantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventParticipantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventParticipantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EventParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventParticipantMutation) ResetField(name string) error {
	switch name {
	case eventparticipant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case eventparticipant.FieldRole:
		m.ResetRole()
		return nil
	case eventparticipant.FieldStatus:
		m.ResetStatus()
		return nil
	case eventparticipant.FieldAccountID:
		m.ResetAccountID()
		return nil
	case eventparticipant.FieldEventID:
		m.ResetEventID()
		return nil
	}
	return fmt.Errorf("unknown EventParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, eventparticipant.EdgeAccount)
	}
	if m.event != nil {
		edges = append(edges, eventparticipant.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventparticipant.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case eventparticipant.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventParticipantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, eventparticipant.EdgeAccount)
	}
	if m.clearedevent {
		edges = append(edges, eventparticipant.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case eventparticipant.EdgeAccount:
		return m.clearedaccount
	case eventparticipant.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventParticipantMutation) ClearEdge(name string) error {
	switch name {
	case eventparticipant.EdgeAccount:
		m.ClearAccount()
		return nil
	case eventparticipant.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown EventParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventParticipantMutation) ResetEdge(name string) error {
	switch name {
	case eventparticipant.EdgeAccount:
		m.ResetAccount()
		return nil
	case eventparticipant.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown EventParticipant edge %s", name)
}

// InvitationMutation represents an operation that mutates the Invitation nodes in the graph.
type InvitationMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	message        *string
	clearedFields  map[string]struct{}
	creator        *xid.ID
	clearedcreator bool
	invited        map[xid.ID]struct{}
	removedinvited map[xid.ID]struct{}
	clearedinvited bool
	done           bool
	oldValue       func(context.Context) (*Invitation, error)
	predicates     []predicate.Invitation
}

var _ ent.Mutation = (*InvitationMutation)(nil)

// invitationOption allows management of the mutation configuration using functional options.
type invitationOption func(*InvitationMutation)

// newInvitationMutation creates new mutation for the Invitation entity.
func newInvitationMutation(c config, op Op, opts ...invitationOption) *InvitationMutation {
	m := &InvitationMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationID sets the ID field of the mutation.
func withInvitationID(id xid.ID) invitationOption {
	return func(m *InvitationMutation) {
		var (
			err   error
			once  sync.Once
			value *Invitation
		)
		m.oldValue = func(ctx context.Context) (*Invitation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invitation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitation sets the old Invitation of the mutation.
func withInvitation(node *Invitation) invitationOption {
	return func(m *InvitationMutation) {
		m.oldValue = func(context.Context) (*Invitation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invitation entities.
func (m *InvitationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invitation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvitationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvitationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvitationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InvitationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InvitationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InvitationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[invitation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InvitationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[invitation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InvitationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, invitation.FieldDeletedAt)
}

// SetMessage sets the "message" field.
func (m *InvitationMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *InvitationMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *InvitationMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[invitation.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *InvitationMutation) MessageCleared() bool {
	_, ok := m.clearedFields[invitation.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *InvitationMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, invitation.FieldMessage)
}

// SetCreatorAccountID sets the "creator_account_id" field.
func (m *InvitationMutation) SetCreatorAccountID(x xid.ID) {
	m.creator = &x
}

// CreatorAccountID returns the value of the "creator_account_id" field in the mutation.
func (m *InvitationMutation) CreatorAccountID() (r xid.ID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorAccountID returns the old "creator_account_id" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldCreatorAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorAccountID: %w", err)
	}
	return oldValue.CreatorAccountID, nil
}

// ResetCreatorAccountID resets all changes to the "creator_account_id" field.
func (m *InvitationMutation) ResetCreatorAccountID() {
	m.creator = nil
}

// SetCreatorID sets the "creator" edge to the Account entity by id.
func (m *InvitationMutation) SetCreatorID(id xid.ID) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Account entity.
func (m *InvitationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[invitation.FieldCreatorAccountID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Account entity was cleared.
func (m *InvitationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *InvitationMutation) CreatorID() (id xid.ID, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *InvitationMutation) CreatorIDs() (ids []xid.ID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *InvitationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddInvitedIDs adds the "invited" edge to the Account entity by ids.
func (m *InvitationMutation) AddInvitedIDs(ids ...xid.ID) {
	if m.invited == nil {
		m.invited = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.invited[ids[i]] = struct{}{}
	}
}

// ClearInvited clears the "invited" edge to the Account entity.
func (m *InvitationMutation) ClearInvited() {
	m.clearedinvited = true
}

// InvitedCleared reports if the "invited" edge to the Account entity was cleared.
func (m *InvitationMutation) InvitedCleared() bool {
	return m.clearedinvited
}

// RemoveInvitedIDs removes the "invited" edge to the Account entity by IDs.
func (m *InvitationMutation) RemoveInvitedIDs(ids ...xid.ID) {
	if m.removedinvited == nil {
		m.removedinvited = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.invited, ids[i])
		m.removedinvited[ids[i]] = struct{}{}
	}
}

// RemovedInvited returns the removed IDs of the "invited" edge to the Account entity.
func (m *InvitationMutation) RemovedInvitedIDs() (ids []xid.ID) {
	for id := range m.removedinvited {
		ids = append(ids, id)
	}
	return
}

// InvitedIDs returns the "invited" edge IDs in the mutation.
func (m *InvitationMutation) InvitedIDs() (ids []xid.ID) {
	for id := range m.invited {
		ids = append(ids, id)
	}
	return
}

// ResetInvited resets all changes to the "invited" edge.
func (m *InvitationMutation) ResetInvited() {
	m.invited = nil
	m.clearedinvited = false
	m.removedinvited = nil
}

// Where appends a list predicates to the InvitationMutation builder.
func (m *InvitationMutation) Where(ps ...predicate.Invitation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvitationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvitationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invitation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvitationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvitationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invitation).
func (m *InvitationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, invitation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invitation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, invitation.FieldDeletedAt)
	}
	if m.message != nil {
		fields = append(fields, invitation.FieldMessage)
	}
	if m.creator != nil {
		fields = append(fields, invitation.FieldCreatorAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitation.FieldCreatedAt:
		return m.CreatedAt()
	case invitation.FieldUpdatedAt:
		return m.UpdatedAt()
	case invitation.FieldDeletedAt:
		return m.DeletedAt()
	case invitation.FieldMessage:
		return m.Message()
	case invitation.FieldCreatorAccountID:
		return m.CreatorAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invitation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invitation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case invitation.FieldMessage:
		return m.OldMessage(ctx)
	case invitation.FieldCreatorAccountID:
		return m.OldCreatorAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown Invitation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invitation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invitation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case invitation.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case invitation.FieldCreatorAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invitation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invitation.FieldDeletedAt) {
		fields = append(fields, invitation.FieldDeletedAt)
	}
	if m.FieldCleared(invitation.FieldMessage) {
		fields = append(fields, invitation.FieldMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationMutation) ClearField(name string) error {
	switch name {
	case invitation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case invitation.FieldMessage:
		m.ClearMessage()
		return nil
	}
	return fmt.Errorf("unknown Invitation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationMutation) ResetField(name string) error {
	switch name {
	case invitation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invitation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invitation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case invitation.FieldMessage:
		m.ResetMessage()
		return nil
	case invitation.FieldCreatorAccountID:
		m.ResetCreatorAccountID()
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.creator != nil {
		edges = append(edges, invitation.EdgeCreator)
	}
	if m.invited != nil {
		edges = append(edges, invitation.EdgeInvited)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case invitation.EdgeInvited:
		ids := make([]ent.Value, 0, len(m.invited))
		for id := range m.invited {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinvited != nil {
		edges = append(edges, invitation.EdgeInvited)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invitation.EdgeInvited:
		ids := make([]ent.Value, 0, len(m.removedinvited))
		for id := range m.removedinvited {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcreator {
		edges = append(edges, invitation.EdgeCreator)
	}
	if m.clearedinvited {
		edges = append(edges, invitation.EdgeInvited)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationMutation) EdgeCleared(name string) bool {
	switch name {
	case invitation.EdgeCreator:
		return m.clearedcreator
	case invitation.EdgeInvited:
		return m.clearedinvited
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationMutation) ClearEdge(name string) error {
	switch name {
	case invitation.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown Invitation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationMutation) ResetEdge(name string) error {
	switch name {
	case invitation.EdgeCreator:
		m.ResetCreator()
		return nil
	case invitation.EdgeInvited:
		m.ResetInvited()
		return nil
	}
	return fmt.Errorf("unknown Invitation edge %s", name)
}

// LikePostMutation represents an operation that mutates the LikePost nodes in the graph.
type LikePostMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	_Post          *xid.ID
	cleared_Post   bool
	done           bool
	oldValue       func(context.Context) (*LikePost, error)
	predicates     []predicate.LikePost
}

var _ ent.Mutation = (*LikePostMutation)(nil)

// likepostOption allows management of the mutation configuration using functional options.
type likepostOption func(*LikePostMutation)

// newLikePostMutation creates new mutation for the LikePost entity.
func newLikePostMutation(c config, op Op, opts ...likepostOption) *LikePostMutation {
	m := &LikePostMutation{
		config:        c,
		op:            op,
		typ:           TypeLikePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLikePostID sets the ID field of the mutation.
func withLikePostID(id xid.ID) likepostOption {
	return func(m *LikePostMutation) {
		var (
			err   error
			once  sync.Once
			value *LikePost
		)
		m.oldValue = func(ctx context.Context) (*LikePost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LikePost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLikePost sets the old LikePost of the mutation.
func withLikePost(node *LikePost) likepostOption {
	return func(m *LikePostMutation) {
		m.oldValue = func(context.Context) (*LikePost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LikePostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LikePostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LikePost entities.
func (m *LikePostMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LikePostMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LikePostMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LikePost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LikePostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LikePostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LikePost entity.
// If the LikePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikePostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LikePostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountID sets the "account_id" field.
func (m *LikePostMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *LikePostMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the LikePost entity.
// If the LikePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikePostMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *LikePostMutation) ResetAccountID() {
	m.account = nil
}

// SetPostID sets the "post_id" field.
func (m *LikePostMutation) SetPostID(x xid.ID) {
	m._Post = &x
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *LikePostMutation) PostID() (r xid.ID, exists bool) {
	v := m._Post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the LikePost entity.
// If the LikePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikePostMutation) OldPostID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *LikePostMutation) ResetPostID() {
	m._Post = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *LikePostMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[likepost.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *LikePostMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *LikePostMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *LikePostMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearPost clears the "Post" edge to the Post entity.
func (m *LikePostMutation) ClearPost() {
	m.cleared_Post = true
	m.clearedFields[likepost.FieldPostID] = struct{}{}
}

// PostCleared reports if the "Post" edge to the Post entity was cleared.
func (m *LikePostMutation) PostCleared() bool {
	return m.cleared_Post
}

// PostIDs returns the "Post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *LikePostMutation) PostIDs() (ids []xid.ID) {
	if id := m._Post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "Post" edge.
func (m *LikePostMutation) ResetPost() {
	m._Post = nil
	m.cleared_Post = false
}

// Where appends a list predicates to the LikePostMutation builder.
func (m *LikePostMutation) Where(ps ...predicate.LikePost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LikePostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LikePostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LikePost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LikePostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LikePostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LikePost).
func (m *LikePostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LikePostMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, likepost.FieldCreatedAt)
	}
	if m.account != nil {
		fields = append(fields, likepost.FieldAccountID)
	}
	if m._Post != nil {
		fields = append(fields, likepost.FieldPostID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LikePostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case likepost.FieldCreatedAt:
		return m.CreatedAt()
	case likepost.FieldAccountID:
		return m.AccountID()
	case likepost.FieldPostID:
		return m.PostID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LikePostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case likepost.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case likepost.FieldAccountID:
		return m.OldAccountID(ctx)
	case likepost.FieldPostID:
		return m.OldPostID(ctx)
	}
	return nil, fmt.Errorf("unknown LikePost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikePostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case likepost.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case likepost.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case likepost.FieldPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	}
	return fmt.Errorf("unknown LikePost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LikePostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LikePostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikePostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LikePost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LikePostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LikePostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LikePostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LikePost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LikePostMutation) ResetField(name string) error {
	switch name {
	case likepost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case likepost.FieldAccountID:
		m.ResetAccountID()
		return nil
	case likepost.FieldPostID:
		m.ResetPostID()
		return nil
	}
	return fmt.Errorf("unknown LikePost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LikePostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, likepost.EdgeAccount)
	}
	if m._Post != nil {
		edges = append(edges, likepost.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LikePostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case likepost.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case likepost.EdgePost:
		if id := m._Post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LikePostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LikePostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LikePostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, likepost.EdgeAccount)
	}
	if m.cleared_Post {
		edges = append(edges, likepost.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LikePostMutation) EdgeCleared(name string) bool {
	switch name {
	case likepost.EdgeAccount:
		return m.clearedaccount
	case likepost.EdgePost:
		return m.cleared_Post
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LikePostMutation) ClearEdge(name string) error {
	switch name {
	case likepost.EdgeAccount:
		m.ClearAccount()
		return nil
	case likepost.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown LikePost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LikePostMutation) ResetEdge(name string) error {
	switch name {
	case likepost.EdgeAccount:
		m.ResetAccount()
		return nil
	case likepost.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown LikePost edge %s", name)
}

// LinkMutation represents an operation that mutates the Link nodes in the graph.
type LinkMutation struct {
	config
	op                             Op
	typ                            string
	id                             *xid.ID
	created_at                     *time.Time
	url                            *string
	slug                           *string
	domain                         *string
	title                          *string
	description                    *string
	clearedFields                  map[string]struct{}
	posts                          map[xid.ID]struct{}
	removedposts                   map[xid.ID]struct{}
	clearedposts                   bool
	post_content_references        map[xid.ID]struct{}
	removedpost_content_references map[xid.ID]struct{}
	clearedpost_content_references bool
	nodes                          map[xid.ID]struct{}
	removednodes                   map[xid.ID]struct{}
	clearednodes                   bool
	node_content_references        map[xid.ID]struct{}
	removednode_content_references map[xid.ID]struct{}
	clearednode_content_references bool
	primary_image                  *xid.ID
	clearedprimary_image           bool
	favicon_image                  *xid.ID
	clearedfavicon_image           bool
	assets                         map[xid.ID]struct{}
	removedassets                  map[xid.ID]struct{}
	clearedassets                  bool
	done                           bool
	oldValue                       func(context.Context) (*Link, error)
	predicates                     []predicate.Link
}

var _ ent.Mutation = (*LinkMutation)(nil)

// linkOption allows management of the mutation configuration using functional options.
type linkOption func(*LinkMutation)

// newLinkMutation creates new mutation for the Link entity.
func newLinkMutation(c config, op Op, opts ...linkOption) *LinkMutation {
	m := &LinkMutation{
		config:        c,
		op:            op,
		typ:           TypeLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkID sets the ID field of the mutation.
func withLinkID(id xid.ID) linkOption {
	return func(m *LinkMutation) {
		var (
			err   error
			once  sync.Once
			value *Link
		)
		m.oldValue = func(ctx context.Context) (*Link, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Link.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLink sets the old Link of the mutation.
func withLink(node *Link) linkOption {
	return func(m *LinkMutation) {
		m.oldValue = func(context.Context) (*Link, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Link entities.
func (m *LinkMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Link.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetURL sets the "url" field.
func (m *LinkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *LinkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *LinkMutation) ResetURL() {
	m.url = nil
}

// SetSlug sets the "slug" field.
func (m *LinkMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *LinkMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *LinkMutation) ResetSlug() {
	m.slug = nil
}

// SetDomain sets the "domain" field.
func (m *LinkMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *LinkMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *LinkMutation) ResetDomain() {
	m.domain = nil
}

// SetTitle sets the "title" field.
func (m *LinkMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *LinkMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *LinkMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *LinkMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LinkMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *LinkMutation) ResetDescription() {
	m.description = nil
}

// SetPrimaryAssetID sets the "primary_asset_id" field.
func (m *LinkMutation) SetPrimaryAssetID(x xid.ID) {
	m.primary_image = &x
}

// PrimaryAssetID returns the value of the "primary_asset_id" field in the mutation.
func (m *LinkMutation) PrimaryAssetID() (r xid.ID, exists bool) {
	v := m.primary_image
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryAssetID returns the old "primary_asset_id" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldPrimaryAssetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryAssetID: %w", err)
	}
	return oldValue.PrimaryAssetID, nil
}

// ClearPrimaryAssetID clears the value of the "primary_asset_id" field.
func (m *LinkMutation) ClearPrimaryAssetID() {
	m.primary_image = nil
	m.clearedFields[link.FieldPrimaryAssetID] = struct{}{}
}

// PrimaryAssetIDCleared returns if the "primary_asset_id" field was cleared in this mutation.
func (m *LinkMutation) PrimaryAssetIDCleared() bool {
	_, ok := m.clearedFields[link.FieldPrimaryAssetID]
	return ok
}

// ResetPrimaryAssetID resets all changes to the "primary_asset_id" field.
func (m *LinkMutation) ResetPrimaryAssetID() {
	m.primary_image = nil
	delete(m.clearedFields, link.FieldPrimaryAssetID)
}

// SetFaviconAssetID sets the "favicon_asset_id" field.
func (m *LinkMutation) SetFaviconAssetID(x xid.ID) {
	m.favicon_image = &x
}

// FaviconAssetID returns the value of the "favicon_asset_id" field in the mutation.
func (m *LinkMutation) FaviconAssetID() (r xid.ID, exists bool) {
	v := m.favicon_image
	if v == nil {
		return
	}
	return *v, true
}

// OldFaviconAssetID returns the old "favicon_asset_id" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldFaviconAssetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaviconAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaviconAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaviconAssetID: %w", err)
	}
	return oldValue.FaviconAssetID, nil
}

// ClearFaviconAssetID clears the value of the "favicon_asset_id" field.
func (m *LinkMutation) ClearFaviconAssetID() {
	m.favicon_image = nil
	m.clearedFields[link.FieldFaviconAssetID] = struct{}{}
}

// FaviconAssetIDCleared returns if the "favicon_asset_id" field was cleared in this mutation.
func (m *LinkMutation) FaviconAssetIDCleared() bool {
	_, ok := m.clearedFields[link.FieldFaviconAssetID]
	return ok
}

// ResetFaviconAssetID resets all changes to the "favicon_asset_id" field.
func (m *LinkMutation) ResetFaviconAssetID() {
	m.favicon_image = nil
	delete(m.clearedFields, link.FieldFaviconAssetID)
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *LinkMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *LinkMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *LinkMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *LinkMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *LinkMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *LinkMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *LinkMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddPostContentReferenceIDs adds the "post_content_references" edge to the Post entity by ids.
func (m *LinkMutation) AddPostContentReferenceIDs(ids ...xid.ID) {
	if m.post_content_references == nil {
		m.post_content_references = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.post_content_references[ids[i]] = struct{}{}
	}
}

// ClearPostContentReferences clears the "post_content_references" edge to the Post entity.
func (m *LinkMutation) ClearPostContentReferences() {
	m.clearedpost_content_references = true
}

// PostContentReferencesCleared reports if the "post_content_references" edge to the Post entity was cleared.
func (m *LinkMutation) PostContentReferencesCleared() bool {
	return m.clearedpost_content_references
}

// RemovePostContentReferenceIDs removes the "post_content_references" edge to the Post entity by IDs.
func (m *LinkMutation) RemovePostContentReferenceIDs(ids ...xid.ID) {
	if m.removedpost_content_references == nil {
		m.removedpost_content_references = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.post_content_references, ids[i])
		m.removedpost_content_references[ids[i]] = struct{}{}
	}
}

// RemovedPostContentReferences returns the removed IDs of the "post_content_references" edge to the Post entity.
func (m *LinkMutation) RemovedPostContentReferencesIDs() (ids []xid.ID) {
	for id := range m.removedpost_content_references {
		ids = append(ids, id)
	}
	return
}

// PostContentReferencesIDs returns the "post_content_references" edge IDs in the mutation.
func (m *LinkMutation) PostContentReferencesIDs() (ids []xid.ID) {
	for id := range m.post_content_references {
		ids = append(ids, id)
	}
	return
}

// ResetPostContentReferences resets all changes to the "post_content_references" edge.
func (m *LinkMutation) ResetPostContentReferences() {
	m.post_content_references = nil
	m.clearedpost_content_references = false
	m.removedpost_content_references = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *LinkMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *LinkMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *LinkMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *LinkMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *LinkMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *LinkMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *LinkMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddNodeContentReferenceIDs adds the "node_content_references" edge to the Node entity by ids.
func (m *LinkMutation) AddNodeContentReferenceIDs(ids ...xid.ID) {
	if m.node_content_references == nil {
		m.node_content_references = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.node_content_references[ids[i]] = struct{}{}
	}
}

// ClearNodeContentReferences clears the "node_content_references" edge to the Node entity.
func (m *LinkMutation) ClearNodeContentReferences() {
	m.clearednode_content_references = true
}

// NodeContentReferencesCleared reports if the "node_content_references" edge to the Node entity was cleared.
func (m *LinkMutation) NodeContentReferencesCleared() bool {
	return m.clearednode_content_references
}

// RemoveNodeContentReferenceIDs removes the "node_content_references" edge to the Node entity by IDs.
func (m *LinkMutation) RemoveNodeContentReferenceIDs(ids ...xid.ID) {
	if m.removednode_content_references == nil {
		m.removednode_content_references = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.node_content_references, ids[i])
		m.removednode_content_references[ids[i]] = struct{}{}
	}
}

// RemovedNodeContentReferences returns the removed IDs of the "node_content_references" edge to the Node entity.
func (m *LinkMutation) RemovedNodeContentReferencesIDs() (ids []xid.ID) {
	for id := range m.removednode_content_references {
		ids = append(ids, id)
	}
	return
}

// NodeContentReferencesIDs returns the "node_content_references" edge IDs in the mutation.
func (m *LinkMutation) NodeContentReferencesIDs() (ids []xid.ID) {
	for id := range m.node_content_references {
		ids = append(ids, id)
	}
	return
}

// ResetNodeContentReferences resets all changes to the "node_content_references" edge.
func (m *LinkMutation) ResetNodeContentReferences() {
	m.node_content_references = nil
	m.clearednode_content_references = false
	m.removednode_content_references = nil
}

// SetPrimaryImageID sets the "primary_image" edge to the Asset entity by id.
func (m *LinkMutation) SetPrimaryImageID(id xid.ID) {
	m.primary_image = &id
}

// ClearPrimaryImage clears the "primary_image" edge to the Asset entity.
func (m *LinkMutation) ClearPrimaryImage() {
	m.clearedprimary_image = true
	m.clearedFields[link.FieldPrimaryAssetID] = struct{}{}
}

// PrimaryImageCleared reports if the "primary_image" edge to the Asset entity was cleared.
func (m *LinkMutation) PrimaryImageCleared() bool {
	return m.PrimaryAssetIDCleared() || m.clearedprimary_image
}

// PrimaryImageID returns the "primary_image" edge ID in the mutation.
func (m *LinkMutation) PrimaryImageID() (id xid.ID, exists bool) {
	if m.primary_image != nil {
		return *m.primary_image, true
	}
	return
}

// PrimaryImageIDs returns the "primary_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryImageID instead. It exists only for internal usage by the builders.
func (m *LinkMutation) PrimaryImageIDs() (ids []xid.ID) {
	if id := m.primary_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryImage resets all changes to the "primary_image" edge.
func (m *LinkMutation) ResetPrimaryImage() {
	m.primary_image = nil
	m.clearedprimary_image = false
}

// SetFaviconImageID sets the "favicon_image" edge to the Asset entity by id.
func (m *LinkMutation) SetFaviconImageID(id xid.ID) {
	m.favicon_image = &id
}

// ClearFaviconImage clears the "favicon_image" edge to the Asset entity.
func (m *LinkMutation) ClearFaviconImage() {
	m.clearedfavicon_image = true
	m.clearedFields[link.FieldFaviconAssetID] = struct{}{}
}

// FaviconImageCleared reports if the "favicon_image" edge to the Asset entity was cleared.
func (m *LinkMutation) FaviconImageCleared() bool {
	return m.FaviconAssetIDCleared() || m.clearedfavicon_image
}

// FaviconImageID returns the "favicon_image" edge ID in the mutation.
func (m *LinkMutation) FaviconImageID() (id xid.ID, exists bool) {
	if m.favicon_image != nil {
		return *m.favicon_image, true
	}
	return
}

// FaviconImageIDs returns the "favicon_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FaviconImageID instead. It exists only for internal usage by the builders.
func (m *LinkMutation) FaviconImageIDs() (ids []xid.ID) {
	if id := m.favicon_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFaviconImage resets all changes to the "favicon_image" edge.
func (m *LinkMutation) ResetFaviconImage() {
	m.favicon_image = nil
	m.clearedfavicon_image = false
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *LinkMutation) AddAssetIDs(ids ...xid.ID) {
	if m.assets == nil {
		m.assets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *LinkMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *LinkMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *LinkMutation) RemoveAssetIDs(ids ...xid.ID) {
	if m.removedassets == nil {
		m.removedassets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *LinkMutation) RemovedAssetsIDs() (ids []xid.ID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *LinkMutation) AssetsIDs() (ids []xid.ID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *LinkMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// Where appends a list predicates to the LinkMutation builder.
func (m *LinkMutation) Where(ps ...predicate.Link) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Link, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Link).
func (m *LinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, link.FieldCreatedAt)
	}
	if m.url != nil {
		fields = append(fields, link.FieldURL)
	}
	if m.slug != nil {
		fields = append(fields, link.FieldSlug)
	}
	if m.domain != nil {
		fields = append(fields, link.FieldDomain)
	}
	if m.title != nil {
		fields = append(fields, link.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, link.FieldDescription)
	}
	if m.primary_image != nil {
		fields = append(fields, link.FieldPrimaryAssetID)
	}
	if m.favicon_image != nil {
		fields = append(fields, link.FieldFaviconAssetID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case link.FieldCreatedAt:
		return m.CreatedAt()
	case link.FieldURL:
		return m.URL()
	case link.FieldSlug:
		return m.Slug()
	case link.FieldDomain:
		return m.Domain()
	case link.FieldTitle:
		return m.Title()
	case link.FieldDescription:
		return m.Description()
	case link.FieldPrimaryAssetID:
		return m.PrimaryAssetID()
	case link.FieldFaviconAssetID:
		return m.FaviconAssetID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case link.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case link.FieldURL:
		return m.OldURL(ctx)
	case link.FieldSlug:
		return m.OldSlug(ctx)
	case link.FieldDomain:
		return m.OldDomain(ctx)
	case link.FieldTitle:
		return m.OldTitle(ctx)
	case link.FieldDescription:
		return m.OldDescription(ctx)
	case link.FieldPrimaryAssetID:
		return m.OldPrimaryAssetID(ctx)
	case link.FieldFaviconAssetID:
		return m.OldFaviconAssetID(ctx)
	}
	return nil, fmt.Errorf("unknown Link field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case link.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case link.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case link.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case link.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case link.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case link.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case link.FieldPrimaryAssetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryAssetID(v)
		return nil
	case link.FieldFaviconAssetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaviconAssetID(v)
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Link numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(link.FieldPrimaryAssetID) {
		fields = append(fields, link.FieldPrimaryAssetID)
	}
	if m.FieldCleared(link.FieldFaviconAssetID) {
		fields = append(fields, link.FieldFaviconAssetID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkMutation) ClearField(name string) error {
	switch name {
	case link.FieldPrimaryAssetID:
		m.ClearPrimaryAssetID()
		return nil
	case link.FieldFaviconAssetID:
		m.ClearFaviconAssetID()
		return nil
	}
	return fmt.Errorf("unknown Link nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkMutation) ResetField(name string) error {
	switch name {
	case link.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case link.FieldURL:
		m.ResetURL()
		return nil
	case link.FieldSlug:
		m.ResetSlug()
		return nil
	case link.FieldDomain:
		m.ResetDomain()
		return nil
	case link.FieldTitle:
		m.ResetTitle()
		return nil
	case link.FieldDescription:
		m.ResetDescription()
		return nil
	case link.FieldPrimaryAssetID:
		m.ResetPrimaryAssetID()
		return nil
	case link.FieldFaviconAssetID:
		m.ResetFaviconAssetID()
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.posts != nil {
		edges = append(edges, link.EdgePosts)
	}
	if m.post_content_references != nil {
		edges = append(edges, link.EdgePostContentReferences)
	}
	if m.nodes != nil {
		edges = append(edges, link.EdgeNodes)
	}
	if m.node_content_references != nil {
		edges = append(edges, link.EdgeNodeContentReferences)
	}
	if m.primary_image != nil {
		edges = append(edges, link.EdgePrimaryImage)
	}
	if m.favicon_image != nil {
		edges = append(edges, link.EdgeFaviconImage)
	}
	if m.assets != nil {
		edges = append(edges, link.EdgeAssets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case link.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case link.EdgePostContentReferences:
		ids := make([]ent.Value, 0, len(m.post_content_references))
		for id := range m.post_content_references {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeNodeContentReferences:
		ids := make([]ent.Value, 0, len(m.node_content_references))
		for id := range m.node_content_references {
			ids = append(ids, id)
		}
		return ids
	case link.EdgePrimaryImage:
		if id := m.primary_image; id != nil {
			return []ent.Value{*id}
		}
	case link.EdgeFaviconImage:
		if id := m.favicon_image; id != nil {
			return []ent.Value{*id}
		}
	case link.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedposts != nil {
		edges = append(edges, link.EdgePosts)
	}
	if m.removedpost_content_references != nil {
		edges = append(edges, link.EdgePostContentReferences)
	}
	if m.removednodes != nil {
		edges = append(edges, link.EdgeNodes)
	}
	if m.removednode_content_references != nil {
		edges = append(edges, link.EdgeNodeContentReferences)
	}
	if m.removedassets != nil {
		edges = append(edges, link.EdgeAssets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case link.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case link.EdgePostContentReferences:
		ids := make([]ent.Value, 0, len(m.removedpost_content_references))
		for id := range m.removedpost_content_references {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeNodeContentReferences:
		ids := make([]ent.Value, 0, len(m.removednode_content_references))
		for id := range m.removednode_content_references {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedposts {
		edges = append(edges, link.EdgePosts)
	}
	if m.clearedpost_content_references {
		edges = append(edges, link.EdgePostContentReferences)
	}
	if m.clearednodes {
		edges = append(edges, link.EdgeNodes)
	}
	if m.clearednode_content_references {
		edges = append(edges, link.EdgeNodeContentReferences)
	}
	if m.clearedprimary_image {
		edges = append(edges, link.EdgePrimaryImage)
	}
	if m.clearedfavicon_image {
		edges = append(edges, link.EdgeFaviconImage)
	}
	if m.clearedassets {
		edges = append(edges, link.EdgeAssets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkMutation) EdgeCleared(name string) bool {
	switch name {
	case link.EdgePosts:
		return m.clearedposts
	case link.EdgePostContentReferences:
		return m.clearedpost_content_references
	case link.EdgeNodes:
		return m.clearednodes
	case link.EdgeNodeContentReferences:
		return m.clearednode_content_references
	case link.EdgePrimaryImage:
		return m.clearedprimary_image
	case link.EdgeFaviconImage:
		return m.clearedfavicon_image
	case link.EdgeAssets:
		return m.clearedassets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkMutation) ClearEdge(name string) error {
	switch name {
	case link.EdgePrimaryImage:
		m.ClearPrimaryImage()
		return nil
	case link.EdgeFaviconImage:
		m.ClearFaviconImage()
		return nil
	}
	return fmt.Errorf("unknown Link unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkMutation) ResetEdge(name string) error {
	switch name {
	case link.EdgePosts:
		m.ResetPosts()
		return nil
	case link.EdgePostContentReferences:
		m.ResetPostContentReferences()
		return nil
	case link.EdgeNodes:
		m.ResetNodes()
		return nil
	case link.EdgeNodeContentReferences:
		m.ResetNodeContentReferences()
		return nil
	case link.EdgePrimaryImage:
		m.ResetPrimaryImage()
		return nil
	case link.EdgeFaviconImage:
		m.ResetFaviconImage()
		return nil
	case link.EdgeAssets:
		m.ResetAssets()
		return nil
	}
	return fmt.Errorf("unknown Link edge %s", name)
}

// MentionProfileMutation represents an operation that mutates the MentionProfile nodes in the graph.
type MentionProfileMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	_Post          *xid.ID
	cleared_Post   bool
	done           bool
	oldValue       func(context.Context) (*MentionProfile, error)
	predicates     []predicate.MentionProfile
}

var _ ent.Mutation = (*MentionProfileMutation)(nil)

// mentionprofileOption allows management of the mutation configuration using functional options.
type mentionprofileOption func(*MentionProfileMutation)

// newMentionProfileMutation creates new mutation for the MentionProfile entity.
func newMentionProfileMutation(c config, op Op, opts ...mentionprofileOption) *MentionProfileMutation {
	m := &MentionProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeMentionProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMentionProfileID sets the ID field of the mutation.
func withMentionProfileID(id xid.ID) mentionprofileOption {
	return func(m *MentionProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *MentionProfile
		)
		m.oldValue = func(ctx context.Context) (*MentionProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MentionProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMentionProfile sets the old MentionProfile of the mutation.
func withMentionProfile(node *MentionProfile) mentionprofileOption {
	return func(m *MentionProfileMutation) {
		m.oldValue = func(context.Context) (*MentionProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MentionProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MentionProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MentionProfile entities.
func (m *MentionProfileMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MentionProfileMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MentionProfileMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MentionProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MentionProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MentionProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MentionProfile entity.
// If the MentionProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentionProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MentionProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountID sets the "account_id" field.
func (m *MentionProfileMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *MentionProfileMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the MentionProfile entity.
// If the MentionProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentionProfileMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *MentionProfileMutation) ResetAccountID() {
	m.account = nil
}

// SetPostID sets the "post_id" field.
func (m *MentionProfileMutation) SetPostID(x xid.ID) {
	m._Post = &x
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *MentionProfileMutation) PostID() (r xid.ID, exists bool) {
	v := m._Post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the MentionProfile entity.
// If the MentionProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentionProfileMutation) OldPostID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *MentionProfileMutation) ResetPostID() {
	m._Post = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *MentionProfileMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[mentionprofile.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *MentionProfileMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *MentionProfileMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *MentionProfileMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearPost clears the "Post" edge to the Post entity.
func (m *MentionProfileMutation) ClearPost() {
	m.cleared_Post = true
	m.clearedFields[mentionprofile.FieldPostID] = struct{}{}
}

// PostCleared reports if the "Post" edge to the Post entity was cleared.
func (m *MentionProfileMutation) PostCleared() bool {
	return m.cleared_Post
}

// PostIDs returns the "Post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *MentionProfileMutation) PostIDs() (ids []xid.ID) {
	if id := m._Post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "Post" edge.
func (m *MentionProfileMutation) ResetPost() {
	m._Post = nil
	m.cleared_Post = false
}

// Where appends a list predicates to the MentionProfileMutation builder.
func (m *MentionProfileMutation) Where(ps ...predicate.MentionProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MentionProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MentionProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MentionProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MentionProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MentionProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MentionProfile).
func (m *MentionProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MentionProfileMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, mentionprofile.FieldCreatedAt)
	}
	if m.account != nil {
		fields = append(fields, mentionprofile.FieldAccountID)
	}
	if m._Post != nil {
		fields = append(fields, mentionprofile.FieldPostID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MentionProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mentionprofile.FieldCreatedAt:
		return m.CreatedAt()
	case mentionprofile.FieldAccountID:
		return m.AccountID()
	case mentionprofile.FieldPostID:
		return m.PostID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MentionProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mentionprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mentionprofile.FieldAccountID:
		return m.OldAccountID(ctx)
	case mentionprofile.FieldPostID:
		return m.OldPostID(ctx)
	}
	return nil, fmt.Errorf("unknown MentionProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentionProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mentionprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mentionprofile.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case mentionprofile.FieldPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	}
	return fmt.Errorf("unknown MentionProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MentionProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MentionProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentionProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MentionProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MentionProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MentionProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MentionProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MentionProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MentionProfileMutation) ResetField(name string) error {
	switch name {
	case mentionprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mentionprofile.FieldAccountID:
		m.ResetAccountID()
		return nil
	case mentionprofile.FieldPostID:
		m.ResetPostID()
		return nil
	}
	return fmt.Errorf("unknown MentionProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MentionProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, mentionprofile.EdgeAccount)
	}
	if m._Post != nil {
		edges = append(edges, mentionprofile.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MentionProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mentionprofile.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case mentionprofile.EdgePost:
		if id := m._Post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MentionProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MentionProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MentionProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, mentionprofile.EdgeAccount)
	}
	if m.cleared_Post {
		edges = append(edges, mentionprofile.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MentionProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case mentionprofile.EdgeAccount:
		return m.clearedaccount
	case mentionprofile.EdgePost:
		return m.cleared_Post
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MentionProfileMutation) ClearEdge(name string) error {
	switch name {
	case mentionprofile.EdgeAccount:
		m.ClearAccount()
		return nil
	case mentionprofile.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown MentionProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MentionProfileMutation) ResetEdge(name string) error {
	switch name {
	case mentionprofile.EdgeAccount:
		m.ResetAccount()
		return nil
	case mentionprofile.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown MentionProfile edge %s", name)
}

// NodeMutation represents an operation that mutates the Node nodes in the graph.
type NodeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *xid.ID
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	indexed_at             *time.Time
	name                   *string
	slug                   *string
	description            *string
	content                *string
	hide_child_tree        *bool
	visibility             *node.Visibility
	sort                   *lexorank.Key
	metadata               *map[string]interface{}
	clearedFields          map[string]struct{}
	owner                  *xid.ID
	clearedowner           bool
	parent                 *xid.ID
	clearedparent          bool
	nodes                  map[xid.ID]struct{}
	removednodes           map[xid.ID]struct{}
	clearednodes           bool
	primary_image          *xid.ID
	clearedprimary_image   bool
	assets                 map[xid.ID]struct{}
	removedassets          map[xid.ID]struct{}
	clearedassets          bool
	tags                   map[xid.ID]struct{}
	removedtags            map[xid.ID]struct{}
	clearedtags            bool
	properties             map[xid.ID]struct{}
	removedproperties      map[xid.ID]struct{}
	clearedproperties      bool
	property_schema        *xid.ID
	clearedproperty_schema bool
	link                   *xid.ID
	clearedlink            bool
	content_links          map[xid.ID]struct{}
	removedcontent_links   map[xid.ID]struct{}
	clearedcontent_links   bool
	collections            map[xid.ID]struct{}
	removedcollections     map[xid.ID]struct{}
	clearedcollections     bool
	done                   bool
	oldValue               func(context.Context) (*Node, error)
	predicates             []predicate.Node
}

var _ ent.Mutation = (*NodeMutation)(nil)

// nodeOption allows management of the mutation configuration using functional options.
type nodeOption func(*NodeMutation)

// newNodeMutation creates new mutation for the Node entity.
func newNodeMutation(c config, op Op, opts ...nodeOption) *NodeMutation {
	m := &NodeMutation{
		config:        c,
		op:            op,
		typ:           TypeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeID sets the ID field of the mutation.
func withNodeID(id xid.ID) nodeOption {
	return func(m *NodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Node
		)
		m.oldValue = func(ctx context.Context) (*Node, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Node.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNode sets the old Node of the mutation.
func withNode(node *Node) nodeOption {
	return func(m *NodeMutation) {
		m.oldValue = func(context.Context) (*Node, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Node entities.
func (m *NodeMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodeMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Node.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NodeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NodeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NodeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[node.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NodeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[node.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, node.FieldDeletedAt)
}

// SetIndexedAt sets the "indexed_at" field.
func (m *NodeMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *NodeMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *NodeMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[node.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *NodeMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[node.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *NodeMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, node.FieldIndexedAt)
}

// SetName sets the "name" field.
func (m *NodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NodeMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *NodeMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *NodeMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *NodeMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *NodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NodeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[node.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NodeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[node.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NodeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, node.FieldDescription)
}

// SetContent sets the "content" field.
func (m *NodeMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *NodeMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *NodeMutation) ClearContent() {
	m.content = nil
	m.clearedFields[node.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *NodeMutation) ContentCleared() bool {
	_, ok := m.clearedFields[node.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *NodeMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, node.FieldContent)
}

// SetParentNodeID sets the "parent_node_id" field.
func (m *NodeMutation) SetParentNodeID(x xid.ID) {
	m.parent = &x
}

// ParentNodeID returns the value of the "parent_node_id" field in the mutation.
func (m *NodeMutation) ParentNodeID() (r xid.ID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentNodeID returns the old "parent_node_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldParentNodeID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentNodeID: %w", err)
	}
	return oldValue.ParentNodeID, nil
}

// ClearParentNodeID clears the value of the "parent_node_id" field.
func (m *NodeMutation) ClearParentNodeID() {
	m.parent = nil
	m.clearedFields[node.FieldParentNodeID] = struct{}{}
}

// ParentNodeIDCleared returns if the "parent_node_id" field was cleared in this mutation.
func (m *NodeMutation) ParentNodeIDCleared() bool {
	_, ok := m.clearedFields[node.FieldParentNodeID]
	return ok
}

// ResetParentNodeID resets all changes to the "parent_node_id" field.
func (m *NodeMutation) ResetParentNodeID() {
	m.parent = nil
	delete(m.clearedFields, node.FieldParentNodeID)
}

// SetHideChildTree sets the "hide_child_tree" field.
func (m *NodeMutation) SetHideChildTree(b bool) {
	m.hide_child_tree = &b
}

// HideChildTree returns the value of the "hide_child_tree" field in the mutation.
func (m *NodeMutation) HideChildTree() (r bool, exists bool) {
	v := m.hide_child_tree
	if v == nil {
		return
	}
	return *v, true
}

// OldHideChildTree returns the old "hide_child_tree" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldHideChildTree(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideChildTree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideChildTree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideChildTree: %w", err)
	}
	return oldValue.HideChildTree, nil
}

// ResetHideChildTree resets all changes to the "hide_child_tree" field.
func (m *NodeMutation) ResetHideChildTree() {
	m.hide_child_tree = nil
}

// SetAccountID sets the "account_id" field.
func (m *NodeMutation) SetAccountID(x xid.ID) {
	m.owner = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *NodeMutation) AccountID() (r xid.ID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *NodeMutation) ResetAccountID() {
	m.owner = nil
}

// SetPropertySchemaID sets the "property_schema_id" field.
func (m *NodeMutation) SetPropertySchemaID(x xid.ID) {
	m.property_schema = &x
}

// PropertySchemaID returns the value of the "property_schema_id" field in the mutation.
func (m *NodeMutation) PropertySchemaID() (r xid.ID, exists bool) {
	v := m.property_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertySchemaID returns the old "property_schema_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPropertySchemaID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertySchemaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertySchemaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertySchemaID: %w", err)
	}
	return oldValue.PropertySchemaID, nil
}

// ClearPropertySchemaID clears the value of the "property_schema_id" field.
func (m *NodeMutation) ClearPropertySchemaID() {
	m.property_schema = nil
	m.clearedFields[node.FieldPropertySchemaID] = struct{}{}
}

// PropertySchemaIDCleared returns if the "property_schema_id" field was cleared in this mutation.
func (m *NodeMutation) PropertySchemaIDCleared() bool {
	_, ok := m.clearedFields[node.FieldPropertySchemaID]
	return ok
}

// ResetPropertySchemaID resets all changes to the "property_schema_id" field.
func (m *NodeMutation) ResetPropertySchemaID() {
	m.property_schema = nil
	delete(m.clearedFields, node.FieldPropertySchemaID)
}

// SetPrimaryAssetID sets the "primary_asset_id" field.
func (m *NodeMutation) SetPrimaryAssetID(x xid.ID) {
	m.primary_image = &x
}

// PrimaryAssetID returns the value of the "primary_asset_id" field in the mutation.
func (m *NodeMutation) PrimaryAssetID() (r xid.ID, exists bool) {
	v := m.primary_image
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryAssetID returns the old "primary_asset_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPrimaryAssetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryAssetID: %w", err)
	}
	return oldValue.PrimaryAssetID, nil
}

// ClearPrimaryAssetID clears the value of the "primary_asset_id" field.
func (m *NodeMutation) ClearPrimaryAssetID() {
	m.primary_image = nil
	m.clearedFields[node.FieldPrimaryAssetID] = struct{}{}
}

// PrimaryAssetIDCleared returns if the "primary_asset_id" field was cleared in this mutation.
func (m *NodeMutation) PrimaryAssetIDCleared() bool {
	_, ok := m.clearedFields[node.FieldPrimaryAssetID]
	return ok
}

// ResetPrimaryAssetID resets all changes to the "primary_asset_id" field.
func (m *NodeMutation) ResetPrimaryAssetID() {
	m.primary_image = nil
	delete(m.clearedFields, node.FieldPrimaryAssetID)
}

// SetLinkID sets the "link_id" field.
func (m *NodeMutation) SetLinkID(x xid.ID) {
	m.link = &x
}

// LinkID returns the value of the "link_id" field in the mutation.
func (m *NodeMutation) LinkID() (r xid.ID, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkID returns the old "link_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldLinkID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkID: %w", err)
	}
	return oldValue.LinkID, nil
}

// ClearLinkID clears the value of the "link_id" field.
func (m *NodeMutation) ClearLinkID() {
	m.link = nil
	m.clearedFields[node.FieldLinkID] = struct{}{}
}

// LinkIDCleared returns if the "link_id" field was cleared in this mutation.
func (m *NodeMutation) LinkIDCleared() bool {
	_, ok := m.clearedFields[node.FieldLinkID]
	return ok
}

// ResetLinkID resets all changes to the "link_id" field.
func (m *NodeMutation) ResetLinkID() {
	m.link = nil
	delete(m.clearedFields, node.FieldLinkID)
}

// SetVisibility sets the "visibility" field.
func (m *NodeMutation) SetVisibility(n node.Visibility) {
	m.visibility = &n
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *NodeMutation) Visibility() (r node.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldVisibility(ctx context.Context) (v node.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *NodeMutation) ResetVisibility() {
	m.visibility = nil
}

// SetSort sets the "sort" field.
func (m *NodeMutation) SetSort(l lexorank.Key) {
	m.sort = &l
}

// Sort returns the value of the "sort" field in the mutation.
func (m *NodeMutation) Sort() (r lexorank.Key, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldSort(ctx context.Context) (v lexorank.Key, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// ResetSort resets all changes to the "sort" field.
func (m *NodeMutation) ResetSort() {
	m.sort = nil
}

// SetMetadata sets the "metadata" field.
func (m *NodeMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *NodeMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *NodeMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[node.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *NodeMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[node.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *NodeMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, node.FieldMetadata)
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *NodeMutation) SetOwnerID(id xid.ID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *NodeMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[node.FieldAccountID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *NodeMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NodeMutation) OwnerID() (id xid.ID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) OwnerIDs() (ids []xid.ID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NodeMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetParentID sets the "parent" edge to the Node entity by id.
func (m *NodeMutation) SetParentID(id xid.ID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Node entity.
func (m *NodeMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[node.FieldParentNodeID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Node entity was cleared.
func (m *NodeMutation) ParentCleared() bool {
	return m.ParentNodeIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *NodeMutation) ParentID() (id xid.ID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) ParentIDs() (ids []xid.ID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *NodeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *NodeMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *NodeMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *NodeMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *NodeMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *NodeMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *NodeMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *NodeMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// SetPrimaryImageID sets the "primary_image" edge to the Asset entity by id.
func (m *NodeMutation) SetPrimaryImageID(id xid.ID) {
	m.primary_image = &id
}

// ClearPrimaryImage clears the "primary_image" edge to the Asset entity.
func (m *NodeMutation) ClearPrimaryImage() {
	m.clearedprimary_image = true
	m.clearedFields[node.FieldPrimaryAssetID] = struct{}{}
}

// PrimaryImageCleared reports if the "primary_image" edge to the Asset entity was cleared.
func (m *NodeMutation) PrimaryImageCleared() bool {
	return m.PrimaryAssetIDCleared() || m.clearedprimary_image
}

// PrimaryImageID returns the "primary_image" edge ID in the mutation.
func (m *NodeMutation) PrimaryImageID() (id xid.ID, exists bool) {
	if m.primary_image != nil {
		return *m.primary_image, true
	}
	return
}

// PrimaryImageIDs returns the "primary_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryImageID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) PrimaryImageIDs() (ids []xid.ID) {
	if id := m.primary_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryImage resets all changes to the "primary_image" edge.
func (m *NodeMutation) ResetPrimaryImage() {
	m.primary_image = nil
	m.clearedprimary_image = false
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *NodeMutation) AddAssetIDs(ids ...xid.ID) {
	if m.assets == nil {
		m.assets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *NodeMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *NodeMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *NodeMutation) RemoveAssetIDs(ids ...xid.ID) {
	if m.removedassets == nil {
		m.removedassets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *NodeMutation) RemovedAssetsIDs() (ids []xid.ID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *NodeMutation) AssetsIDs() (ids []xid.ID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *NodeMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *NodeMutation) AddTagIDs(ids ...xid.ID) {
	if m.tags == nil {
		m.tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *NodeMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *NodeMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *NodeMutation) RemoveTagIDs(ids ...xid.ID) {
	if m.removedtags == nil {
		m.removedtags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *NodeMutation) RemovedTagsIDs() (ids []xid.ID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *NodeMutation) TagsIDs() (ids []xid.ID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *NodeMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *NodeMutation) AddPropertyIDs(ids ...xid.ID) {
	if m.properties == nil {
		m.properties = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *NodeMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *NodeMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *NodeMutation) RemovePropertyIDs(ids ...xid.ID) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *NodeMutation) RemovedPropertiesIDs() (ids []xid.ID) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *NodeMutation) PropertiesIDs() (ids []xid.ID) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *NodeMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// ClearPropertySchema clears the "property_schema" edge to the PropertySchema entity.
func (m *NodeMutation) ClearPropertySchema() {
	m.clearedproperty_schema = true
	m.clearedFields[node.FieldPropertySchemaID] = struct{}{}
}

// PropertySchemaCleared reports if the "property_schema" edge to the PropertySchema entity was cleared.
func (m *NodeMutation) PropertySchemaCleared() bool {
	return m.PropertySchemaIDCleared() || m.clearedproperty_schema
}

// PropertySchemaIDs returns the "property_schema" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PropertySchemaID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) PropertySchemaIDs() (ids []xid.ID) {
	if id := m.property_schema; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPropertySchema resets all changes to the "property_schema" edge.
func (m *NodeMutation) ResetPropertySchema() {
	m.property_schema = nil
	m.clearedproperty_schema = false
}

// ClearLink clears the "link" edge to the Link entity.
func (m *NodeMutation) ClearLink() {
	m.clearedlink = true
	m.clearedFields[node.FieldLinkID] = struct{}{}
}

// LinkCleared reports if the "link" edge to the Link entity was cleared.
func (m *NodeMutation) LinkCleared() bool {
	return m.LinkIDCleared() || m.clearedlink
}

// LinkIDs returns the "link" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LinkID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) LinkIDs() (ids []xid.ID) {
	if id := m.link; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLink resets all changes to the "link" edge.
func (m *NodeMutation) ResetLink() {
	m.link = nil
	m.clearedlink = false
}

// AddContentLinkIDs adds the "content_links" edge to the Link entity by ids.
func (m *NodeMutation) AddContentLinkIDs(ids ...xid.ID) {
	if m.content_links == nil {
		m.content_links = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.content_links[ids[i]] = struct{}{}
	}
}

// ClearContentLinks clears the "content_links" edge to the Link entity.
func (m *NodeMutation) ClearContentLinks() {
	m.clearedcontent_links = true
}

// ContentLinksCleared reports if the "content_links" edge to the Link entity was cleared.
func (m *NodeMutation) ContentLinksCleared() bool {
	return m.clearedcontent_links
}

// RemoveContentLinkIDs removes the "content_links" edge to the Link entity by IDs.
func (m *NodeMutation) RemoveContentLinkIDs(ids ...xid.ID) {
	if m.removedcontent_links == nil {
		m.removedcontent_links = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.content_links, ids[i])
		m.removedcontent_links[ids[i]] = struct{}{}
	}
}

// RemovedContentLinks returns the removed IDs of the "content_links" edge to the Link entity.
func (m *NodeMutation) RemovedContentLinksIDs() (ids []xid.ID) {
	for id := range m.removedcontent_links {
		ids = append(ids, id)
	}
	return
}

// ContentLinksIDs returns the "content_links" edge IDs in the mutation.
func (m *NodeMutation) ContentLinksIDs() (ids []xid.ID) {
	for id := range m.content_links {
		ids = append(ids, id)
	}
	return
}

// ResetContentLinks resets all changes to the "content_links" edge.
func (m *NodeMutation) ResetContentLinks() {
	m.content_links = nil
	m.clearedcontent_links = false
	m.removedcontent_links = nil
}

// AddCollectionIDs adds the "collections" edge to the Collection entity by ids.
func (m *NodeMutation) AddCollectionIDs(ids ...xid.ID) {
	if m.collections == nil {
		m.collections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.collections[ids[i]] = struct{}{}
	}
}

// ClearCollections clears the "collections" edge to the Collection entity.
func (m *NodeMutation) ClearCollections() {
	m.clearedcollections = true
}

// CollectionsCleared reports if the "collections" edge to the Collection entity was cleared.
func (m *NodeMutation) CollectionsCleared() bool {
	return m.clearedcollections
}

// RemoveCollectionIDs removes the "collections" edge to the Collection entity by IDs.
func (m *NodeMutation) RemoveCollectionIDs(ids ...xid.ID) {
	if m.removedcollections == nil {
		m.removedcollections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.collections, ids[i])
		m.removedcollections[ids[i]] = struct{}{}
	}
}

// RemovedCollections returns the removed IDs of the "collections" edge to the Collection entity.
func (m *NodeMutation) RemovedCollectionsIDs() (ids []xid.ID) {
	for id := range m.removedcollections {
		ids = append(ids, id)
	}
	return
}

// CollectionsIDs returns the "collections" edge IDs in the mutation.
func (m *NodeMutation) CollectionsIDs() (ids []xid.ID) {
	for id := range m.collections {
		ids = append(ids, id)
	}
	return
}

// ResetCollections resets all changes to the "collections" edge.
func (m *NodeMutation) ResetCollections() {
	m.collections = nil
	m.clearedcollections = false
	m.removedcollections = nil
}

// Where appends a list predicates to the NodeMutation builder.
func (m *NodeMutation) Where(ps ...predicate.Node) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Node, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Node).
func (m *NodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, node.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, node.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, node.FieldDeletedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, node.FieldIndexedAt)
	}
	if m.name != nil {
		fields = append(fields, node.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, node.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, node.FieldDescription)
	}
	if m.content != nil {
		fields = append(fields, node.FieldContent)
	}
	if m.parent != nil {
		fields = append(fields, node.FieldParentNodeID)
	}
	if m.hide_child_tree != nil {
		fields = append(fields, node.FieldHideChildTree)
	}
	if m.owner != nil {
		fields = append(fields, node.FieldAccountID)
	}
	if m.property_schema != nil {
		fields = append(fields, node.FieldPropertySchemaID)
	}
	if m.primary_image != nil {
		fields = append(fields, node.FieldPrimaryAssetID)
	}
	if m.link != nil {
		fields = append(fields, node.FieldLinkID)
	}
	if m.visibility != nil {
		fields = append(fields, node.FieldVisibility)
	}
	if m.sort != nil {
		fields = append(fields, node.FieldSort)
	}
	if m.metadata != nil {
		fields = append(fields, node.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case node.FieldCreatedAt:
		return m.CreatedAt()
	case node.FieldUpdatedAt:
		return m.UpdatedAt()
	case node.FieldDeletedAt:
		return m.DeletedAt()
	case node.FieldIndexedAt:
		return m.IndexedAt()
	case node.FieldName:
		return m.Name()
	case node.FieldSlug:
		return m.Slug()
	case node.FieldDescription:
		return m.Description()
	case node.FieldContent:
		return m.Content()
	case node.FieldParentNodeID:
		return m.ParentNodeID()
	case node.FieldHideChildTree:
		return m.HideChildTree()
	case node.FieldAccountID:
		return m.AccountID()
	case node.FieldPropertySchemaID:
		return m.PropertySchemaID()
	case node.FieldPrimaryAssetID:
		return m.PrimaryAssetID()
	case node.FieldLinkID:
		return m.LinkID()
	case node.FieldVisibility:
		return m.Visibility()
	case node.FieldSort:
		return m.Sort()
	case node.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case node.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case node.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case node.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case node.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case node.FieldName:
		return m.OldName(ctx)
	case node.FieldSlug:
		return m.OldSlug(ctx)
	case node.FieldDescription:
		return m.OldDescription(ctx)
	case node.FieldContent:
		return m.OldContent(ctx)
	case node.FieldParentNodeID:
		return m.OldParentNodeID(ctx)
	case node.FieldHideChildTree:
		return m.OldHideChildTree(ctx)
	case node.FieldAccountID:
		return m.OldAccountID(ctx)
	case node.FieldPropertySchemaID:
		return m.OldPropertySchemaID(ctx)
	case node.FieldPrimaryAssetID:
		return m.OldPrimaryAssetID(ctx)
	case node.FieldLinkID:
		return m.OldLinkID(ctx)
	case node.FieldVisibility:
		return m.OldVisibility(ctx)
	case node.FieldSort:
		return m.OldSort(ctx)
	case node.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Node field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case node.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case node.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case node.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case node.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case node.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case node.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case node.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case node.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case node.FieldParentNodeID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentNodeID(v)
		return nil
	case node.FieldHideChildTree:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideChildTree(v)
		return nil
	case node.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case node.FieldPropertySchemaID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertySchemaID(v)
		return nil
	case node.FieldPrimaryAssetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryAssetID(v)
		return nil
	case node.FieldLinkID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkID(v)
		return nil
	case node.FieldVisibility:
		v, ok := value.(node.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case node.FieldSort:
		v, ok := value.(lexorank.Key)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case node.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Node numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(node.FieldDeletedAt) {
		fields = append(fields, node.FieldDeletedAt)
	}
	if m.FieldCleared(node.FieldIndexedAt) {
		fields = append(fields, node.FieldIndexedAt)
	}
	if m.FieldCleared(node.FieldDescription) {
		fields = append(fields, node.FieldDescription)
	}
	if m.FieldCleared(node.FieldContent) {
		fields = append(fields, node.FieldContent)
	}
	if m.FieldCleared(node.FieldParentNodeID) {
		fields = append(fields, node.FieldParentNodeID)
	}
	if m.FieldCleared(node.FieldPropertySchemaID) {
		fields = append(fields, node.FieldPropertySchemaID)
	}
	if m.FieldCleared(node.FieldPrimaryAssetID) {
		fields = append(fields, node.FieldPrimaryAssetID)
	}
	if m.FieldCleared(node.FieldLinkID) {
		fields = append(fields, node.FieldLinkID)
	}
	if m.FieldCleared(node.FieldMetadata) {
		fields = append(fields, node.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeMutation) ClearField(name string) error {
	switch name {
	case node.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case node.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case node.FieldDescription:
		m.ClearDescription()
		return nil
	case node.FieldContent:
		m.ClearContent()
		return nil
	case node.FieldParentNodeID:
		m.ClearParentNodeID()
		return nil
	case node.FieldPropertySchemaID:
		m.ClearPropertySchemaID()
		return nil
	case node.FieldPrimaryAssetID:
		m.ClearPrimaryAssetID()
		return nil
	case node.FieldLinkID:
		m.ClearLinkID()
		return nil
	case node.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Node nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeMutation) ResetField(name string) error {
	switch name {
	case node.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case node.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case node.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case node.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case node.FieldName:
		m.ResetName()
		return nil
	case node.FieldSlug:
		m.ResetSlug()
		return nil
	case node.FieldDescription:
		m.ResetDescription()
		return nil
	case node.FieldContent:
		m.ResetContent()
		return nil
	case node.FieldParentNodeID:
		m.ResetParentNodeID()
		return nil
	case node.FieldHideChildTree:
		m.ResetHideChildTree()
		return nil
	case node.FieldAccountID:
		m.ResetAccountID()
		return nil
	case node.FieldPropertySchemaID:
		m.ResetPropertySchemaID()
		return nil
	case node.FieldPrimaryAssetID:
		m.ResetPrimaryAssetID()
		return nil
	case node.FieldLinkID:
		m.ResetLinkID()
		return nil
	case node.FieldVisibility:
		m.ResetVisibility()
		return nil
	case node.FieldSort:
		m.ResetSort()
		return nil
	case node.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.owner != nil {
		edges = append(edges, node.EdgeOwner)
	}
	if m.parent != nil {
		edges = append(edges, node.EdgeParent)
	}
	if m.nodes != nil {
		edges = append(edges, node.EdgeNodes)
	}
	if m.primary_image != nil {
		edges = append(edges, node.EdgePrimaryImage)
	}
	if m.assets != nil {
		edges = append(edges, node.EdgeAssets)
	}
	if m.tags != nil {
		edges = append(edges, node.EdgeTags)
	}
	if m.properties != nil {
		edges = append(edges, node.EdgeProperties)
	}
	if m.property_schema != nil {
		edges = append(edges, node.EdgePropertySchema)
	}
	if m.link != nil {
		edges = append(edges, node.EdgeLink)
	}
	if m.content_links != nil {
		edges = append(edges, node.EdgeContentLinks)
	}
	if m.collections != nil {
		edges = append(edges, node.EdgeCollections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case node.EdgePrimaryImage:
		if id := m.primary_image; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case node.EdgePropertySchema:
		if id := m.property_schema; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeLink:
		if id := m.link; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeContentLinks:
		ids := make([]ent.Value, 0, len(m.content_links))
		for id := range m.content_links {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.collections))
		for id := range m.collections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removednodes != nil {
		edges = append(edges, node.EdgeNodes)
	}
	if m.removedassets != nil {
		edges = append(edges, node.EdgeAssets)
	}
	if m.removedtags != nil {
		edges = append(edges, node.EdgeTags)
	}
	if m.removedproperties != nil {
		edges = append(edges, node.EdgeProperties)
	}
	if m.removedcontent_links != nil {
		edges = append(edges, node.EdgeContentLinks)
	}
	if m.removedcollections != nil {
		edges = append(edges, node.EdgeCollections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeContentLinks:
		ids := make([]ent.Value, 0, len(m.removedcontent_links))
		for id := range m.removedcontent_links {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.removedcollections))
		for id := range m.removedcollections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedowner {
		edges = append(edges, node.EdgeOwner)
	}
	if m.clearedparent {
		edges = append(edges, node.EdgeParent)
	}
	if m.clearednodes {
		edges = append(edges, node.EdgeNodes)
	}
	if m.clearedprimary_image {
		edges = append(edges, node.EdgePrimaryImage)
	}
	if m.clearedassets {
		edges = append(edges, node.EdgeAssets)
	}
	if m.clearedtags {
		edges = append(edges, node.EdgeTags)
	}
	if m.clearedproperties {
		edges = append(edges, node.EdgeProperties)
	}
	if m.clearedproperty_schema {
		edges = append(edges, node.EdgePropertySchema)
	}
	if m.clearedlink {
		edges = append(edges, node.EdgeLink)
	}
	if m.clearedcontent_links {
		edges = append(edges, node.EdgeContentLinks)
	}
	if m.clearedcollections {
		edges = append(edges, node.EdgeCollections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeMutation) EdgeCleared(name string) bool {
	switch name {
	case node.EdgeOwner:
		return m.clearedowner
	case node.EdgeParent:
		return m.clearedparent
	case node.EdgeNodes:
		return m.clearednodes
	case node.EdgePrimaryImage:
		return m.clearedprimary_image
	case node.EdgeAssets:
		return m.clearedassets
	case node.EdgeTags:
		return m.clearedtags
	case node.EdgeProperties:
		return m.clearedproperties
	case node.EdgePropertySchema:
		return m.clearedproperty_schema
	case node.EdgeLink:
		return m.clearedlink
	case node.EdgeContentLinks:
		return m.clearedcontent_links
	case node.EdgeCollections:
		return m.clearedcollections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeMutation) ClearEdge(name string) error {
	switch name {
	case node.EdgeOwner:
		m.ClearOwner()
		return nil
	case node.EdgeParent:
		m.ClearParent()
		return nil
	case node.EdgePrimaryImage:
		m.ClearPrimaryImage()
		return nil
	case node.EdgePropertySchema:
		m.ClearPropertySchema()
		return nil
	case node.EdgeLink:
		m.ClearLink()
		return nil
	}
	return fmt.Errorf("unknown Node unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeMutation) ResetEdge(name string) error {
	switch name {
	case node.EdgeOwner:
		m.ResetOwner()
		return nil
	case node.EdgeParent:
		m.ResetParent()
		return nil
	case node.EdgeNodes:
		m.ResetNodes()
		return nil
	case node.EdgePrimaryImage:
		m.ResetPrimaryImage()
		return nil
	case node.EdgeAssets:
		m.ResetAssets()
		return nil
	case node.EdgeTags:
		m.ResetTags()
		return nil
	case node.EdgeProperties:
		m.ResetProperties()
		return nil
	case node.EdgePropertySchema:
		m.ResetPropertySchema()
		return nil
	case node.EdgeLink:
		m.ResetLink()
		return nil
	case node.EdgeContentLinks:
		m.ResetContentLinks()
		return nil
	case node.EdgeCollections:
		m.ResetCollections()
		return nil
	}
	return fmt.Errorf("unknown Node edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	deleted_at     *time.Time
	event_type     *string
	datagraph_kind *string
	datagraph_id   *xid.ID
	read           *bool
	clearedFields  map[string]struct{}
	owner          *xid.ID
	clearedowner   bool
	source         *xid.ID
	clearedsource  bool
	done           bool
	oldValue       func(context.Context) (*Notification, error)
	predicates     []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id xid.ID) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notification.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notification.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notification.FieldDeletedAt)
}

// SetEventType sets the "event_type" field.
func (m *NotificationMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *NotificationMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *NotificationMutation) ResetEventType() {
	m.event_type = nil
}

// SetDatagraphKind sets the "datagraph_kind" field.
func (m *NotificationMutation) SetDatagraphKind(s string) {
	m.datagraph_kind = &s
}

// DatagraphKind returns the value of the "datagraph_kind" field in the mutation.
func (m *NotificationMutation) DatagraphKind() (r string, exists bool) {
	v := m.datagraph_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldDatagraphKind returns the old "datagraph_kind" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldDatagraphKind(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatagraphKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatagraphKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatagraphKind: %w", err)
	}
	return oldValue.DatagraphKind, nil
}

// ClearDatagraphKind clears the value of the "datagraph_kind" field.
func (m *NotificationMutation) ClearDatagraphKind() {
	m.datagraph_kind = nil
	m.clearedFields[notification.FieldDatagraphKind] = struct{}{}
}

// DatagraphKindCleared returns if the "datagraph_kind" field was cleared in this mutation.
func (m *NotificationMutation) DatagraphKindCleared() bool {
	_, ok := m.clearedFields[notification.FieldDatagraphKind]
	return ok
}

// ResetDatagraphKind resets all changes to the "datagraph_kind" field.
func (m *NotificationMutation) ResetDatagraphKind() {
	m.datagraph_kind = nil
	delete(m.clearedFields, notification.FieldDatagraphKind)
}

// SetDatagraphID sets the "datagraph_id" field.
func (m *NotificationMutation) SetDatagraphID(x xid.ID) {
	m.datagraph_id = &x
}

// DatagraphID returns the value of the "datagraph_id" field in the mutation.
func (m *NotificationMutation) DatagraphID() (r xid.ID, exists bool) {
	v := m.datagraph_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDatagraphID returns the old "datagraph_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldDatagraphID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatagraphID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatagraphID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatagraphID: %w", err)
	}
	return oldValue.DatagraphID, nil
}

// ClearDatagraphID clears the value of the "datagraph_id" field.
func (m *NotificationMutation) ClearDatagraphID() {
	m.datagraph_id = nil
	m.clearedFields[notification.FieldDatagraphID] = struct{}{}
}

// DatagraphIDCleared returns if the "datagraph_id" field was cleared in this mutation.
func (m *NotificationMutation) DatagraphIDCleared() bool {
	_, ok := m.clearedFields[notification.FieldDatagraphID]
	return ok
}

// ResetDatagraphID resets all changes to the "datagraph_id" field.
func (m *NotificationMutation) ResetDatagraphID() {
	m.datagraph_id = nil
	delete(m.clearedFields, notification.FieldDatagraphID)
}

// SetRead sets the "read" field.
func (m *NotificationMutation) SetRead(b bool) {
	m.read = &b
}

// Read returns the value of the "read" field in the mutation.
func (m *NotificationMutation) Read() (r bool, exists bool) {
	v := m.read
	if v == nil {
		return
	}
	return *v, true
}

// OldRead returns the old "read" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRead: %w", err)
	}
	return oldValue.Read, nil
}

// ResetRead resets all changes to the "read" field.
func (m *NotificationMutation) ResetRead() {
	m.read = nil
}

// SetOwnerAccountID sets the "owner_account_id" field.
func (m *NotificationMutation) SetOwnerAccountID(x xid.ID) {
	m.owner = &x
}

// OwnerAccountID returns the value of the "owner_account_id" field in the mutation.
func (m *NotificationMutation) OwnerAccountID() (r xid.ID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerAccountID returns the old "owner_account_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldOwnerAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerAccountID: %w", err)
	}
	return oldValue.OwnerAccountID, nil
}

// ResetOwnerAccountID resets all changes to the "owner_account_id" field.
func (m *NotificationMutation) ResetOwnerAccountID() {
	m.owner = nil
}

// SetSourceAccountID sets the "source_account_id" field.
func (m *NotificationMutation) SetSourceAccountID(x xid.ID) {
	m.source = &x
}

// SourceAccountID returns the value of the "source_account_id" field in the mutation.
func (m *NotificationMutation) SourceAccountID() (r xid.ID, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceAccountID returns the old "source_account_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSourceAccountID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceAccountID: %w", err)
	}
	return oldValue.SourceAccountID, nil
}

// ClearSourceAccountID clears the value of the "source_account_id" field.
func (m *NotificationMutation) ClearSourceAccountID() {
	m.source = nil
	m.clearedFields[notification.FieldSourceAccountID] = struct{}{}
}

// SourceAccountIDCleared returns if the "source_account_id" field was cleared in this mutation.
func (m *NotificationMutation) SourceAccountIDCleared() bool {
	_, ok := m.clearedFields[notification.FieldSourceAccountID]
	return ok
}

// ResetSourceAccountID resets all changes to the "source_account_id" field.
func (m *NotificationMutation) ResetSourceAccountID() {
	m.source = nil
	delete(m.clearedFields, notification.FieldSourceAccountID)
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *NotificationMutation) SetOwnerID(id xid.ID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *NotificationMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[notification.FieldOwnerAccountID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *NotificationMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NotificationMutation) OwnerID() (id xid.ID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) OwnerIDs() (ids []xid.ID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NotificationMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetSourceID sets the "source" edge to the Account entity by id.
func (m *NotificationMutation) SetSourceID(id xid.ID) {
	m.source = &id
}

// ClearSource clears the "source" edge to the Account entity.
func (m *NotificationMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[notification.FieldSourceAccountID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the Account entity was cleared.
func (m *NotificationMutation) SourceCleared() bool {
	return m.SourceAccountIDCleared() || m.clearedsource
}

// SourceID returns the "source" edge ID in the mutation.
func (m *NotificationMutation) SourceID() (id xid.ID, exists bool) {
	if m.source != nil {
		return *m.source, true
	}
	return
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) SourceIDs() (ids []xid.ID) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *NotificationMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notification.FieldDeletedAt)
	}
	if m.event_type != nil {
		fields = append(fields, notification.FieldEventType)
	}
	if m.datagraph_kind != nil {
		fields = append(fields, notification.FieldDatagraphKind)
	}
	if m.datagraph_id != nil {
		fields = append(fields, notification.FieldDatagraphID)
	}
	if m.read != nil {
		fields = append(fields, notification.FieldRead)
	}
	if m.owner != nil {
		fields = append(fields, notification.FieldOwnerAccountID)
	}
	if m.source != nil {
		fields = append(fields, notification.FieldSourceAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldDeletedAt:
		return m.DeletedAt()
	case notification.FieldEventType:
		return m.EventType()
	case notification.FieldDatagraphKind:
		return m.DatagraphKind()
	case notification.FieldDatagraphID:
		return m.DatagraphID()
	case notification.FieldRead:
		return m.Read()
	case notification.FieldOwnerAccountID:
		return m.OwnerAccountID()
	case notification.FieldSourceAccountID:
		return m.SourceAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notification.FieldEventType:
		return m.OldEventType(ctx)
	case notification.FieldDatagraphKind:
		return m.OldDatagraphKind(ctx)
	case notification.FieldDatagraphID:
		return m.OldDatagraphID(ctx)
	case notification.FieldRead:
		return m.OldRead(ctx)
	case notification.FieldOwnerAccountID:
		return m.OldOwnerAccountID(ctx)
	case notification.FieldSourceAccountID:
		return m.OldSourceAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notification.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case notification.FieldDatagraphKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatagraphKind(v)
		return nil
	case notification.FieldDatagraphID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatagraphID(v)
		return nil
	case notification.FieldRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRead(v)
		return nil
	case notification.FieldOwnerAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerAccountID(v)
		return nil
	case notification.FieldSourceAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldDeletedAt) {
		fields = append(fields, notification.FieldDeletedAt)
	}
	if m.FieldCleared(notification.FieldDatagraphKind) {
		fields = append(fields, notification.FieldDatagraphKind)
	}
	if m.FieldCleared(notification.FieldDatagraphID) {
		fields = append(fields, notification.FieldDatagraphID)
	}
	if m.FieldCleared(notification.FieldSourceAccountID) {
		fields = append(fields, notification.FieldSourceAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notification.FieldDatagraphKind:
		m.ClearDatagraphKind()
		return nil
	case notification.FieldDatagraphID:
		m.ClearDatagraphID()
		return nil
	case notification.FieldSourceAccountID:
		m.ClearSourceAccountID()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notification.FieldEventType:
		m.ResetEventType()
		return nil
	case notification.FieldDatagraphKind:
		m.ResetDatagraphKind()
		return nil
	case notification.FieldDatagraphID:
		m.ResetDatagraphID()
		return nil
	case notification.FieldRead:
		m.ResetRead()
		return nil
	case notification.FieldOwnerAccountID:
		m.ResetOwnerAccountID()
		return nil
	case notification.FieldSourceAccountID:
		m.ResetSourceAccountID()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, notification.EdgeOwner)
	}
	if m.source != nil {
		edges = append(edges, notification.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case notification.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, notification.EdgeOwner)
	}
	if m.clearedsource {
		edges = append(edges, notification.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeOwner:
		return m.clearedowner
	case notification.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeOwner:
		m.ClearOwner()
		return nil
	case notification.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeOwner:
		m.ResetOwner()
		return nil
	case notification.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                   Op
	typ                  string
	id                   *xid.ID
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	indexed_at           *time.Time
	title                *string
	slug                 *string
	pinned_rank          *int
	addpinned_rank       *int
	last_reply_at        *time.Time
	body                 *string
	short                *string
	metadata             *map[string]interface{}
	visibility           *post.Visibility
	clearedFields        map[string]struct{}
	author               *xid.ID
	clearedauthor        bool
	category             *xid.ID
	clearedcategory      bool
	tags                 map[xid.ID]struct{}
	removedtags          map[xid.ID]struct{}
	clearedtags          bool
	root                 *xid.ID
	clearedroot          bool
	posts                map[xid.ID]struct{}
	removedposts         map[xid.ID]struct{}
	clearedposts         bool
	replyTo              *xid.ID
	clearedreplyTo       bool
	replies              map[xid.ID]struct{}
	removedreplies       map[xid.ID]struct{}
	clearedreplies       bool
	reacts               map[xid.ID]struct{}
	removedreacts        map[xid.ID]struct{}
	clearedreacts        bool
	likes                map[xid.ID]struct{}
	removedlikes         map[xid.ID]struct{}
	clearedlikes         bool
	mentions             map[xid.ID]struct{}
	removedmentions      map[xid.ID]struct{}
	clearedmentions      bool
	assets               map[xid.ID]struct{}
	removedassets        map[xid.ID]struct{}
	clearedassets        bool
	collections          map[xid.ID]struct{}
	removedcollections   map[xid.ID]struct{}
	clearedcollections   bool
	link                 *xid.ID
	clearedlink          bool
	content_links        map[xid.ID]struct{}
	removedcontent_links map[xid.ID]struct{}
	clearedcontent_links bool
	event                map[xid.ID]struct{}
	removedevent         map[xid.ID]struct{}
	clearedevent         bool
	post_reads           map[xid.ID]struct{}
	removedpost_reads    map[xid.ID]struct{}
	clearedpost_reads    bool
	done                 bool
	oldValue             func(context.Context) (*Post, error)
	predicates           []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id xid.ID) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PostMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PostMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PostMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[post.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PostMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PostMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, post.FieldDeletedAt)
}

// SetIndexedAt sets the "indexed_at" field.
func (m *PostMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *PostMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *PostMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[post.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *PostMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *PostMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, post.FieldIndexedAt)
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *PostMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[post.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *PostMutation) TitleCleared() bool {
	_, ok := m.clearedFields[post.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, post.FieldTitle)
}

// SetSlug sets the "slug" field.
func (m *PostMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *PostMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[post.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *PostMutation) SlugCleared() bool {
	_, ok := m.clearedFields[post.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, post.FieldSlug)
}

// SetPinnedRank sets the "pinned_rank" field.
func (m *PostMutation) SetPinnedRank(i int) {
	m.pinned_rank = &i
	m.addpinned_rank = nil
}

// PinnedRank returns the value of the "pinned_rank" field in the mutation.
func (m *PostMutation) PinnedRank() (r int, exists bool) {
	v := m.pinned_rank
	if v == nil {
		return
	}
	return *v, true
}

// OldPinnedRank returns the old "pinned_rank" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPinnedRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinnedRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinnedRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinnedRank: %w", err)
	}
	return oldValue.PinnedRank, nil
}

// AddPinnedRank adds i to the "pinned_rank" field.
func (m *PostMutation) AddPinnedRank(i int) {
	if m.addpinned_rank != nil {
		*m.addpinned_rank += i
	} else {
		m.addpinned_rank = &i
	}
}

// AddedPinnedRank returns the value that was added to the "pinned_rank" field in this mutation.
func (m *PostMutation) AddedPinnedRank() (r int, exists bool) {
	v := m.addpinned_rank
	if v == nil {
		return
	}
	return *v, true
}

// ResetPinnedRank resets all changes to the "pinned_rank" field.
func (m *PostMutation) ResetPinnedRank() {
	m.pinned_rank = nil
	m.addpinned_rank = nil
}

// SetLastReplyAt sets the "last_reply_at" field.
func (m *PostMutation) SetLastReplyAt(t time.Time) {
	m.last_reply_at = &t
}

// LastReplyAt returns the value of the "last_reply_at" field in the mutation.
func (m *PostMutation) LastReplyAt() (r time.Time, exists bool) {
	v := m.last_reply_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReplyAt returns the old "last_reply_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldLastReplyAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReplyAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReplyAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReplyAt: %w", err)
	}
	return oldValue.LastReplyAt, nil
}

// ResetLastReplyAt resets all changes to the "last_reply_at" field.
func (m *PostMutation) ResetLastReplyAt() {
	m.last_reply_at = nil
}

// SetRootPostID sets the "root_post_id" field.
func (m *PostMutation) SetRootPostID(x xid.ID) {
	m.root = &x
}

// RootPostID returns the value of the "root_post_id" field in the mutation.
func (m *PostMutation) RootPostID() (r xid.ID, exists bool) {
	v := m.root
	if v == nil {
		return
	}
	return *v, true
}

// OldRootPostID returns the old "root_post_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldRootPostID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootPostID: %w", err)
	}
	return oldValue.RootPostID, nil
}

// ClearRootPostID clears the value of the "root_post_id" field.
func (m *PostMutation) ClearRootPostID() {
	m.root = nil
	m.clearedFields[post.FieldRootPostID] = struct{}{}
}

// RootPostIDCleared returns if the "root_post_id" field was cleared in this mutation.
func (m *PostMutation) RootPostIDCleared() bool {
	_, ok := m.clearedFields[post.FieldRootPostID]
	return ok
}

// ResetRootPostID resets all changes to the "root_post_id" field.
func (m *PostMutation) ResetRootPostID() {
	m.root = nil
	delete(m.clearedFields, post.FieldRootPostID)
}

// SetReplyToPostID sets the "reply_to_post_id" field.
func (m *PostMutation) SetReplyToPostID(x xid.ID) {
	m.replyTo = &x
}

// ReplyToPostID returns the value of the "reply_to_post_id" field in the mutation.
func (m *PostMutation) ReplyToPostID() (r xid.ID, exists bool) {
	v := m.replyTo
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyToPostID returns the old "reply_to_post_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldReplyToPostID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyToPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyToPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyToPostID: %w", err)
	}
	return oldValue.ReplyToPostID, nil
}

// ClearReplyToPostID clears the value of the "reply_to_post_id" field.
func (m *PostMutation) ClearReplyToPostID() {
	m.replyTo = nil
	m.clearedFields[post.FieldReplyToPostID] = struct{}{}
}

// ReplyToPostIDCleared returns if the "reply_to_post_id" field was cleared in this mutation.
func (m *PostMutation) ReplyToPostIDCleared() bool {
	_, ok := m.clearedFields[post.FieldReplyToPostID]
	return ok
}

// ResetReplyToPostID resets all changes to the "reply_to_post_id" field.
func (m *PostMutation) ResetReplyToPostID() {
	m.replyTo = nil
	delete(m.clearedFields, post.FieldReplyToPostID)
}

// SetBody sets the "body" field.
func (m *PostMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *PostMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *PostMutation) ResetBody() {
	m.body = nil
}

// SetShort sets the "short" field.
func (m *PostMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *PostMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *PostMutation) ResetShort() {
	m.short = nil
}

// SetMetadata sets the "metadata" field.
func (m *PostMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PostMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PostMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[post.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PostMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[post.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PostMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, post.FieldMetadata)
}

// SetVisibility sets the "visibility" field.
func (m *PostMutation) SetVisibility(po post.Visibility) {
	m.visibility = &po
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *PostMutation) Visibility() (r post.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldVisibility(ctx context.Context) (v post.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *PostMutation) ResetVisibility() {
	m.visibility = nil
}

// SetAccountPosts sets the "account_posts" field.
func (m *PostMutation) SetAccountPosts(x xid.ID) {
	m.author = &x
}

// AccountPosts returns the value of the "account_posts" field in the mutation.
func (m *PostMutation) AccountPosts() (r xid.ID, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountPosts returns the old "account_posts" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldAccountPosts(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountPosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountPosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountPosts: %w", err)
	}
	return oldValue.AccountPosts, nil
}

// ResetAccountPosts resets all changes to the "account_posts" field.
func (m *PostMutation) ResetAccountPosts() {
	m.author = nil
}

// SetCategoryID sets the "category_id" field.
func (m *PostMutation) SetCategoryID(x xid.ID) {
	m.category = &x
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *PostMutation) CategoryID() (r xid.ID, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCategoryID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *PostMutation) ClearCategoryID() {
	m.category = nil
	m.clearedFields[post.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *PostMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[post.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *PostMutation) ResetCategoryID() {
	m.category = nil
	delete(m.clearedFields, post.FieldCategoryID)
}

// SetLinkID sets the "link_id" field.
func (m *PostMutation) SetLinkID(x xid.ID) {
	m.link = &x
}

// LinkID returns the value of the "link_id" field in the mutation.
func (m *PostMutation) LinkID() (r xid.ID, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkID returns the old "link_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldLinkID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkID: %w", err)
	}
	return oldValue.LinkID, nil
}

// ClearLinkID clears the value of the "link_id" field.
func (m *PostMutation) ClearLinkID() {
	m.link = nil
	m.clearedFields[post.FieldLinkID] = struct{}{}
}

// LinkIDCleared returns if the "link_id" field was cleared in this mutation.
func (m *PostMutation) LinkIDCleared() bool {
	_, ok := m.clearedFields[post.FieldLinkID]
	return ok
}

// ResetLinkID resets all changes to the "link_id" field.
func (m *PostMutation) ResetLinkID() {
	m.link = nil
	delete(m.clearedFields, post.FieldLinkID)
}

// SetAuthorID sets the "author" edge to the Account entity by id.
func (m *PostMutation) SetAuthorID(id xid.ID) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the Account entity.
func (m *PostMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[post.FieldAccountPosts] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the Account entity was cleared.
func (m *PostMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *PostMutation) AuthorID() (id xid.ID, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *PostMutation) AuthorIDs() (ids []xid.ID) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *PostMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *PostMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[post.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *PostMutation) CategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *PostMutation) CategoryIDs() (ids []xid.ID) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *PostMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *PostMutation) AddTagIDs(ids ...xid.ID) {
	if m.tags == nil {
		m.tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *PostMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *PostMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *PostMutation) RemoveTagIDs(ids ...xid.ID) {
	if m.removedtags == nil {
		m.removedtags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *PostMutation) RemovedTagsIDs() (ids []xid.ID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *PostMutation) TagsIDs() (ids []xid.ID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *PostMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// SetRootID sets the "root" edge to the Post entity by id.
func (m *PostMutation) SetRootID(id xid.ID) {
	m.root = &id
}

// ClearRoot clears the "root" edge to the Post entity.
func (m *PostMutation) ClearRoot() {
	m.clearedroot = true
	m.clearedFields[post.FieldRootPostID] = struct{}{}
}

// RootCleared reports if the "root" edge to the Post entity was cleared.
func (m *PostMutation) RootCleared() bool {
	return m.RootPostIDCleared() || m.clearedroot
}

// RootID returns the "root" edge ID in the mutation.
func (m *PostMutation) RootID() (id xid.ID, exists bool) {
	if m.root != nil {
		return *m.root, true
	}
	return
}

// RootIDs returns the "root" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RootID instead. It exists only for internal usage by the builders.
func (m *PostMutation) RootIDs() (ids []xid.ID) {
	if id := m.root; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoot resets all changes to the "root" edge.
func (m *PostMutation) ResetRoot() {
	m.root = nil
	m.clearedroot = false
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *PostMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *PostMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *PostMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *PostMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *PostMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *PostMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *PostMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// SetReplyToID sets the "replyTo" edge to the Post entity by id.
func (m *PostMutation) SetReplyToID(id xid.ID) {
	m.replyTo = &id
}

// ClearReplyTo clears the "replyTo" edge to the Post entity.
func (m *PostMutation) ClearReplyTo() {
	m.clearedreplyTo = true
	m.clearedFields[post.FieldReplyToPostID] = struct{}{}
}

// ReplyToCleared reports if the "replyTo" edge to the Post entity was cleared.
func (m *PostMutation) ReplyToCleared() bool {
	return m.ReplyToPostIDCleared() || m.clearedreplyTo
}

// ReplyToID returns the "replyTo" edge ID in the mutation.
func (m *PostMutation) ReplyToID() (id xid.ID, exists bool) {
	if m.replyTo != nil {
		return *m.replyTo, true
	}
	return
}

// ReplyToIDs returns the "replyTo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReplyToID instead. It exists only for internal usage by the builders.
func (m *PostMutation) ReplyToIDs() (ids []xid.ID) {
	if id := m.replyTo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReplyTo resets all changes to the "replyTo" edge.
func (m *PostMutation) ResetReplyTo() {
	m.replyTo = nil
	m.clearedreplyTo = false
}

// AddReplyIDs adds the "replies" edge to the Post entity by ids.
func (m *PostMutation) AddReplyIDs(ids ...xid.ID) {
	if m.replies == nil {
		m.replies = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the Post entity.
func (m *PostMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the Post entity was cleared.
func (m *PostMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the Post entity by IDs.
func (m *PostMutation) RemoveReplyIDs(ids ...xid.ID) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the Post entity.
func (m *PostMutation) RemovedRepliesIDs() (ids []xid.ID) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *PostMutation) RepliesIDs() (ids []xid.ID) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *PostMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// AddReactIDs adds the "reacts" edge to the React entity by ids.
func (m *PostMutation) AddReactIDs(ids ...xid.ID) {
	if m.reacts == nil {
		m.reacts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.reacts[ids[i]] = struct{}{}
	}
}

// ClearReacts clears the "reacts" edge to the React entity.
func (m *PostMutation) ClearReacts() {
	m.clearedreacts = true
}

// ReactsCleared reports if the "reacts" edge to the React entity was cleared.
func (m *PostMutation) ReactsCleared() bool {
	return m.clearedreacts
}

// RemoveReactIDs removes the "reacts" edge to the React entity by IDs.
func (m *PostMutation) RemoveReactIDs(ids ...xid.ID) {
	if m.removedreacts == nil {
		m.removedreacts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.reacts, ids[i])
		m.removedreacts[ids[i]] = struct{}{}
	}
}

// RemovedReacts returns the removed IDs of the "reacts" edge to the React entity.
func (m *PostMutation) RemovedReactsIDs() (ids []xid.ID) {
	for id := range m.removedreacts {
		ids = append(ids, id)
	}
	return
}

// ReactsIDs returns the "reacts" edge IDs in the mutation.
func (m *PostMutation) ReactsIDs() (ids []xid.ID) {
	for id := range m.reacts {
		ids = append(ids, id)
	}
	return
}

// ResetReacts resets all changes to the "reacts" edge.
func (m *PostMutation) ResetReacts() {
	m.reacts = nil
	m.clearedreacts = false
	m.removedreacts = nil
}

// AddLikeIDs adds the "likes" edge to the LikePost entity by ids.
func (m *PostMutation) AddLikeIDs(ids ...xid.ID) {
	if m.likes == nil {
		m.likes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the LikePost entity.
func (m *PostMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the LikePost entity was cleared.
func (m *PostMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the LikePost entity by IDs.
func (m *PostMutation) RemoveLikeIDs(ids ...xid.ID) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the LikePost entity.
func (m *PostMutation) RemovedLikesIDs() (ids []xid.ID) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *PostMutation) LikesIDs() (ids []xid.ID) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *PostMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// AddMentionIDs adds the "mentions" edge to the MentionProfile entity by ids.
func (m *PostMutation) AddMentionIDs(ids ...xid.ID) {
	if m.mentions == nil {
		m.mentions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.mentions[ids[i]] = struct{}{}
	}
}

// ClearMentions clears the "mentions" edge to the MentionProfile entity.
func (m *PostMutation) ClearMentions() {
	m.clearedmentions = true
}

// MentionsCleared reports if the "mentions" edge to the MentionProfile entity was cleared.
func (m *PostMutation) MentionsCleared() bool {
	return m.clearedmentions
}

// RemoveMentionIDs removes the "mentions" edge to the MentionProfile entity by IDs.
func (m *PostMutation) RemoveMentionIDs(ids ...xid.ID) {
	if m.removedmentions == nil {
		m.removedmentions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.mentions, ids[i])
		m.removedmentions[ids[i]] = struct{}{}
	}
}

// RemovedMentions returns the removed IDs of the "mentions" edge to the MentionProfile entity.
func (m *PostMutation) RemovedMentionsIDs() (ids []xid.ID) {
	for id := range m.removedmentions {
		ids = append(ids, id)
	}
	return
}

// MentionsIDs returns the "mentions" edge IDs in the mutation.
func (m *PostMutation) MentionsIDs() (ids []xid.ID) {
	for id := range m.mentions {
		ids = append(ids, id)
	}
	return
}

// ResetMentions resets all changes to the "mentions" edge.
func (m *PostMutation) ResetMentions() {
	m.mentions = nil
	m.clearedmentions = false
	m.removedmentions = nil
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *PostMutation) AddAssetIDs(ids ...xid.ID) {
	if m.assets == nil {
		m.assets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *PostMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *PostMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *PostMutation) RemoveAssetIDs(ids ...xid.ID) {
	if m.removedassets == nil {
		m.removedassets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *PostMutation) RemovedAssetsIDs() (ids []xid.ID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *PostMutation) AssetsIDs() (ids []xid.ID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *PostMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// AddCollectionIDs adds the "collections" edge to the Collection entity by ids.
func (m *PostMutation) AddCollectionIDs(ids ...xid.ID) {
	if m.collections == nil {
		m.collections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.collections[ids[i]] = struct{}{}
	}
}

// ClearCollections clears the "collections" edge to the Collection entity.
func (m *PostMutation) ClearCollections() {
	m.clearedcollections = true
}

// CollectionsCleared reports if the "collections" edge to the Collection entity was cleared.
func (m *PostMutation) CollectionsCleared() bool {
	return m.clearedcollections
}

// RemoveCollectionIDs removes the "collections" edge to the Collection entity by IDs.
func (m *PostMutation) RemoveCollectionIDs(ids ...xid.ID) {
	if m.removedcollections == nil {
		m.removedcollections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.collections, ids[i])
		m.removedcollections[ids[i]] = struct{}{}
	}
}

// RemovedCollections returns the removed IDs of the "collections" edge to the Collection entity.
func (m *PostMutation) RemovedCollectionsIDs() (ids []xid.ID) {
	for id := range m.removedcollections {
		ids = append(ids, id)
	}
	return
}

// CollectionsIDs returns the "collections" edge IDs in the mutation.
func (m *PostMutation) CollectionsIDs() (ids []xid.ID) {
	for id := range m.collections {
		ids = append(ids, id)
	}
	return
}

// ResetCollections resets all changes to the "collections" edge.
func (m *PostMutation) ResetCollections() {
	m.collections = nil
	m.clearedcollections = false
	m.removedcollections = nil
}

// ClearLink clears the "link" edge to the Link entity.
func (m *PostMutation) ClearLink() {
	m.clearedlink = true
	m.clearedFields[post.FieldLinkID] = struct{}{}
}

// LinkCleared reports if the "link" edge to the Link entity was cleared.
func (m *PostMutation) LinkCleared() bool {
	return m.LinkIDCleared() || m.clearedlink
}

// LinkIDs returns the "link" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LinkID instead. It exists only for internal usage by the builders.
func (m *PostMutation) LinkIDs() (ids []xid.ID) {
	if id := m.link; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLink resets all changes to the "link" edge.
func (m *PostMutation) ResetLink() {
	m.link = nil
	m.clearedlink = false
}

// AddContentLinkIDs adds the "content_links" edge to the Link entity by ids.
func (m *PostMutation) AddContentLinkIDs(ids ...xid.ID) {
	if m.content_links == nil {
		m.content_links = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.content_links[ids[i]] = struct{}{}
	}
}

// ClearContentLinks clears the "content_links" edge to the Link entity.
func (m *PostMutation) ClearContentLinks() {
	m.clearedcontent_links = true
}

// ContentLinksCleared reports if the "content_links" edge to the Link entity was cleared.
func (m *PostMutation) ContentLinksCleared() bool {
	return m.clearedcontent_links
}

// RemoveContentLinkIDs removes the "content_links" edge to the Link entity by IDs.
func (m *PostMutation) RemoveContentLinkIDs(ids ...xid.ID) {
	if m.removedcontent_links == nil {
		m.removedcontent_links = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.content_links, ids[i])
		m.removedcontent_links[ids[i]] = struct{}{}
	}
}

// RemovedContentLinks returns the removed IDs of the "content_links" edge to the Link entity.
func (m *PostMutation) RemovedContentLinksIDs() (ids []xid.ID) {
	for id := range m.removedcontent_links {
		ids = append(ids, id)
	}
	return
}

// ContentLinksIDs returns the "content_links" edge IDs in the mutation.
func (m *PostMutation) ContentLinksIDs() (ids []xid.ID) {
	for id := range m.content_links {
		ids = append(ids, id)
	}
	return
}

// ResetContentLinks resets all changes to the "content_links" edge.
func (m *PostMutation) ResetContentLinks() {
	m.content_links = nil
	m.clearedcontent_links = false
	m.removedcontent_links = nil
}

// AddEventIDs adds the "event" edge to the Event entity by ids.
func (m *PostMutation) AddEventIDs(ids ...xid.ID) {
	if m.event == nil {
		m.event = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.event[ids[i]] = struct{}{}
	}
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *PostMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *PostMutation) EventCleared() bool {
	return m.clearedevent
}

// RemoveEventIDs removes the "event" edge to the Event entity by IDs.
func (m *PostMutation) RemoveEventIDs(ids ...xid.ID) {
	if m.removedevent == nil {
		m.removedevent = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.event, ids[i])
		m.removedevent[ids[i]] = struct{}{}
	}
}

// RemovedEvent returns the removed IDs of the "event" edge to the Event entity.
func (m *PostMutation) RemovedEventIDs() (ids []xid.ID) {
	for id := range m.removedevent {
		ids = append(ids, id)
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
func (m *PostMutation) EventIDs() (ids []xid.ID) {
	for id := range m.event {
		ids = append(ids, id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *PostMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
	m.removedevent = nil
}

// AddPostReadIDs adds the "post_reads" edge to the PostRead entity by ids.
func (m *PostMutation) AddPostReadIDs(ids ...xid.ID) {
	if m.post_reads == nil {
		m.post_reads = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.post_reads[ids[i]] = struct{}{}
	}
}

// ClearPostReads clears the "post_reads" edge to the PostRead entity.
func (m *PostMutation) ClearPostReads() {
	m.clearedpost_reads = true
}

// PostReadsCleared reports if the "post_reads" edge to the PostRead entity was cleared.
func (m *PostMutation) PostReadsCleared() bool {
	return m.clearedpost_reads
}

// RemovePostReadIDs removes the "post_reads" edge to the PostRead entity by IDs.
func (m *PostMutation) RemovePostReadIDs(ids ...xid.ID) {
	if m.removedpost_reads == nil {
		m.removedpost_reads = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.post_reads, ids[i])
		m.removedpost_reads[ids[i]] = struct{}{}
	}
}

// RemovedPostReads returns the removed IDs of the "post_reads" edge to the PostRead entity.
func (m *PostMutation) RemovedPostReadsIDs() (ids []xid.ID) {
	for id := range m.removedpost_reads {
		ids = append(ids, id)
	}
	return
}

// PostReadsIDs returns the "post_reads" edge IDs in the mutation.
func (m *PostMutation) PostReadsIDs() (ids []xid.ID) {
	for id := range m.post_reads {
		ids = append(ids, id)
	}
	return
}

// ResetPostReads resets all changes to the "post_reads" edge.
func (m *PostMutation) ResetPostReads() {
	m.post_reads = nil
	m.clearedpost_reads = false
	m.removedpost_reads = nil
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, post.FieldDeletedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, post.FieldIndexedAt)
	}
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, post.FieldSlug)
	}
	if m.pinned_rank != nil {
		fields = append(fields, post.FieldPinnedRank)
	}
	if m.last_reply_at != nil {
		fields = append(fields, post.FieldLastReplyAt)
	}
	if m.root != nil {
		fields = append(fields, post.FieldRootPostID)
	}
	if m.replyTo != nil {
		fields = append(fields, post.FieldReplyToPostID)
	}
	if m.body != nil {
		fields = append(fields, post.FieldBody)
	}
	if m.short != nil {
		fields = append(fields, post.FieldShort)
	}
	if m.metadata != nil {
		fields = append(fields, post.FieldMetadata)
	}
	if m.visibility != nil {
		fields = append(fields, post.FieldVisibility)
	}
	if m.author != nil {
		fields = append(fields, post.FieldAccountPosts)
	}
	if m.category != nil {
		fields = append(fields, post.FieldCategoryID)
	}
	if m.link != nil {
		fields = append(fields, post.FieldLinkID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldDeletedAt:
		return m.DeletedAt()
	case post.FieldIndexedAt:
		return m.IndexedAt()
	case post.FieldTitle:
		return m.Title()
	case post.FieldSlug:
		return m.Slug()
	case post.FieldPinnedRank:
		return m.PinnedRank()
	case post.FieldLastReplyAt:
		return m.LastReplyAt()
	case post.FieldRootPostID:
		return m.RootPostID()
	case post.FieldReplyToPostID:
		return m.ReplyToPostID()
	case post.FieldBody:
		return m.Body()
	case post.FieldShort:
		return m.Short()
	case post.FieldMetadata:
		return m.Metadata()
	case post.FieldVisibility:
		return m.Visibility()
	case post.FieldAccountPosts:
		return m.AccountPosts()
	case post.FieldCategoryID:
		return m.CategoryID()
	case post.FieldLinkID:
		return m.LinkID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case post.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldSlug:
		return m.OldSlug(ctx)
	case post.FieldPinnedRank:
		return m.OldPinnedRank(ctx)
	case post.FieldLastReplyAt:
		return m.OldLastReplyAt(ctx)
	case post.FieldRootPostID:
		return m.OldRootPostID(ctx)
	case post.FieldReplyToPostID:
		return m.OldReplyToPostID(ctx)
	case post.FieldBody:
		return m.OldBody(ctx)
	case post.FieldShort:
		return m.OldShort(ctx)
	case post.FieldMetadata:
		return m.OldMetadata(ctx)
	case post.FieldVisibility:
		return m.OldVisibility(ctx)
	case post.FieldAccountPosts:
		return m.OldAccountPosts(ctx)
	case post.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case post.FieldLinkID:
		return m.OldLinkID(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case post.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case post.FieldPinnedRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinnedRank(v)
		return nil
	case post.FieldLastReplyAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReplyAt(v)
		return nil
	case post.FieldRootPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootPostID(v)
		return nil
	case post.FieldReplyToPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyToPostID(v)
		return nil
	case post.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case post.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case post.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case post.FieldVisibility:
		v, ok := value.(post.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case post.FieldAccountPosts:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountPosts(v)
		return nil
	case post.FieldCategoryID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case post.FieldLinkID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkID(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	var fields []string
	if m.addpinned_rank != nil {
		fields = append(fields, post.FieldPinnedRank)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case post.FieldPinnedRank:
		return m.AddedPinnedRank()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case post.FieldPinnedRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPinnedRank(v)
		return nil
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldDeletedAt) {
		fields = append(fields, post.FieldDeletedAt)
	}
	if m.FieldCleared(post.FieldIndexedAt) {
		fields = append(fields, post.FieldIndexedAt)
	}
	if m.FieldCleared(post.FieldTitle) {
		fields = append(fields, post.FieldTitle)
	}
	if m.FieldCleared(post.FieldSlug) {
		fields = append(fields, post.FieldSlug)
	}
	if m.FieldCleared(post.FieldRootPostID) {
		fields = append(fields, post.FieldRootPostID)
	}
	if m.FieldCleared(post.FieldReplyToPostID) {
		fields = append(fields, post.FieldReplyToPostID)
	}
	if m.FieldCleared(post.FieldMetadata) {
		fields = append(fields, post.FieldMetadata)
	}
	if m.FieldCleared(post.FieldCategoryID) {
		fields = append(fields, post.FieldCategoryID)
	}
	if m.FieldCleared(post.FieldLinkID) {
		fields = append(fields, post.FieldLinkID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case post.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case post.FieldTitle:
		m.ClearTitle()
		return nil
	case post.FieldSlug:
		m.ClearSlug()
		return nil
	case post.FieldRootPostID:
		m.ClearRootPostID()
		return nil
	case post.FieldReplyToPostID:
		m.ClearReplyToPostID()
		return nil
	case post.FieldMetadata:
		m.ClearMetadata()
		return nil
	case post.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case post.FieldLinkID:
		m.ClearLinkID()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case post.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldSlug:
		m.ResetSlug()
		return nil
	case post.FieldPinnedRank:
		m.ResetPinnedRank()
		return nil
	case post.FieldLastReplyAt:
		m.ResetLastReplyAt()
		return nil
	case post.FieldRootPostID:
		m.ResetRootPostID()
		return nil
	case post.FieldReplyToPostID:
		m.ResetReplyToPostID()
		return nil
	case post.FieldBody:
		m.ResetBody()
		return nil
	case post.FieldShort:
		m.ResetShort()
		return nil
	case post.FieldMetadata:
		m.ResetMetadata()
		return nil
	case post.FieldVisibility:
		m.ResetVisibility()
		return nil
	case post.FieldAccountPosts:
		m.ResetAccountPosts()
		return nil
	case post.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case post.FieldLinkID:
		m.ResetLinkID()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.author != nil {
		edges = append(edges, post.EdgeAuthor)
	}
	if m.category != nil {
		edges = append(edges, post.EdgeCategory)
	}
	if m.tags != nil {
		edges = append(edges, post.EdgeTags)
	}
	if m.root != nil {
		edges = append(edges, post.EdgeRoot)
	}
	if m.posts != nil {
		edges = append(edges, post.EdgePosts)
	}
	if m.replyTo != nil {
		edges = append(edges, post.EdgeReplyTo)
	}
	if m.replies != nil {
		edges = append(edges, post.EdgeReplies)
	}
	if m.reacts != nil {
		edges = append(edges, post.EdgeReacts)
	}
	if m.likes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	if m.mentions != nil {
		edges = append(edges, post.EdgeMentions)
	}
	if m.assets != nil {
		edges = append(edges, post.EdgeAssets)
	}
	if m.collections != nil {
		edges = append(edges, post.EdgeCollections)
	}
	if m.link != nil {
		edges = append(edges, post.EdgeLink)
	}
	if m.content_links != nil {
		edges = append(edges, post.EdgeContentLinks)
	}
	if m.event != nil {
		edges = append(edges, post.EdgeEvent)
	}
	if m.post_reads != nil {
		edges = append(edges, post.EdgePostReads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeRoot:
		if id := m.root; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReplyTo:
		if id := m.replyTo; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.reacts))
		for id := range m.reacts {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeMentions:
		ids := make([]ent.Value, 0, len(m.mentions))
		for id := range m.mentions {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.collections))
		for id := range m.collections {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLink:
		if id := m.link; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeContentLinks:
		ids := make([]ent.Value, 0, len(m.content_links))
		for id := range m.content_links {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.event))
		for id := range m.event {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostReads:
		ids := make([]ent.Value, 0, len(m.post_reads))
		for id := range m.post_reads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedtags != nil {
		edges = append(edges, post.EdgeTags)
	}
	if m.removedposts != nil {
		edges = append(edges, post.EdgePosts)
	}
	if m.removedreplies != nil {
		edges = append(edges, post.EdgeReplies)
	}
	if m.removedreacts != nil {
		edges = append(edges, post.EdgeReacts)
	}
	if m.removedlikes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	if m.removedmentions != nil {
		edges = append(edges, post.EdgeMentions)
	}
	if m.removedassets != nil {
		edges = append(edges, post.EdgeAssets)
	}
	if m.removedcollections != nil {
		edges = append(edges, post.EdgeCollections)
	}
	if m.removedcontent_links != nil {
		edges = append(edges, post.EdgeContentLinks)
	}
	if m.removedevent != nil {
		edges = append(edges, post.EdgeEvent)
	}
	if m.removedpost_reads != nil {
		edges = append(edges, post.EdgePostReads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.removedreacts))
		for id := range m.removedreacts {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeMentions:
		ids := make([]ent.Value, 0, len(m.removedmentions))
		for id := range m.removedmentions {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.removedcollections))
		for id := range m.removedcollections {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeContentLinks:
		ids := make([]ent.Value, 0, len(m.removedcontent_links))
		for id := range m.removedcontent_links {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.removedevent))
		for id := range m.removedevent {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostReads:
		ids := make([]ent.Value, 0, len(m.removedpost_reads))
		for id := range m.removedpost_reads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedauthor {
		edges = append(edges, post.EdgeAuthor)
	}
	if m.clearedcategory {
		edges = append(edges, post.EdgeCategory)
	}
	if m.clearedtags {
		edges = append(edges, post.EdgeTags)
	}
	if m.clearedroot {
		edges = append(edges, post.EdgeRoot)
	}
	if m.clearedposts {
		edges = append(edges, post.EdgePosts)
	}
	if m.clearedreplyTo {
		edges = append(edges, post.EdgeReplyTo)
	}
	if m.clearedreplies {
		edges = append(edges, post.EdgeReplies)
	}
	if m.clearedreacts {
		edges = append(edges, post.EdgeReacts)
	}
	if m.clearedlikes {
		edges = append(edges, post.EdgeLikes)
	}
	if m.clearedmentions {
		edges = append(edges, post.EdgeMentions)
	}
	if m.clearedassets {
		edges = append(edges, post.EdgeAssets)
	}
	if m.clearedcollections {
		edges = append(edges, post.EdgeCollections)
	}
	if m.clearedlink {
		edges = append(edges, post.EdgeLink)
	}
	if m.clearedcontent_links {
		edges = append(edges, post.EdgeContentLinks)
	}
	if m.clearedevent {
		edges = append(edges, post.EdgeEvent)
	}
	if m.clearedpost_reads {
		edges = append(edges, post.EdgePostReads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeAuthor:
		return m.clearedauthor
	case post.EdgeCategory:
		return m.clearedcategory
	case post.EdgeTags:
		return m.clearedtags
	case post.EdgeRoot:
		return m.clearedroot
	case post.EdgePosts:
		return m.clearedposts
	case post.EdgeReplyTo:
		return m.clearedreplyTo
	case post.EdgeReplies:
		return m.clearedreplies
	case post.EdgeReacts:
		return m.clearedreacts
	case post.EdgeLikes:
		return m.clearedlikes
	case post.EdgeMentions:
		return m.clearedmentions
	case post.EdgeAssets:
		return m.clearedassets
	case post.EdgeCollections:
		return m.clearedcollections
	case post.EdgeLink:
		return m.clearedlink
	case post.EdgeContentLinks:
		return m.clearedcontent_links
	case post.EdgeEvent:
		return m.clearedevent
	case post.EdgePostReads:
		return m.clearedpost_reads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case post.EdgeCategory:
		m.ClearCategory()
		return nil
	case post.EdgeRoot:
		m.ClearRoot()
		return nil
	case post.EdgeReplyTo:
		m.ClearReplyTo()
		return nil
	case post.EdgeLink:
		m.ClearLink()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case post.EdgeCategory:
		m.ResetCategory()
		return nil
	case post.EdgeTags:
		m.ResetTags()
		return nil
	case post.EdgeRoot:
		m.ResetRoot()
		return nil
	case post.EdgePosts:
		m.ResetPosts()
		return nil
	case post.EdgeReplyTo:
		m.ResetReplyTo()
		return nil
	case post.EdgeReplies:
		m.ResetReplies()
		return nil
	case post.EdgeReacts:
		m.ResetReacts()
		return nil
	case post.EdgeLikes:
		m.ResetLikes()
		return nil
	case post.EdgeMentions:
		m.ResetMentions()
		return nil
	case post.EdgeAssets:
		m.ResetAssets()
		return nil
	case post.EdgeCollections:
		m.ResetCollections()
		return nil
	case post.EdgeLink:
		m.ResetLink()
		return nil
	case post.EdgeContentLinks:
		m.ResetContentLinks()
		return nil
	case post.EdgeEvent:
		m.ResetEvent()
		return nil
	case post.EdgePostReads:
		m.ResetPostReads()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// PostReadMutation represents an operation that mutates the PostRead nodes in the graph.
type PostReadMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	last_seen_at     *time.Time
	clearedFields    map[string]struct{}
	root_post        *xid.ID
	clearedroot_post bool
	account          *xid.ID
	clearedaccount   bool
	done             bool
	oldValue         func(context.Context) (*PostRead, error)
	predicates       []predicate.PostRead
}

var _ ent.Mutation = (*PostReadMutation)(nil)

// postreadOption allows management of the mutation configuration using functional options.
type postreadOption func(*PostReadMutation)

// newPostReadMutation creates new mutation for the PostRead entity.
func newPostReadMutation(c config, op Op, opts ...postreadOption) *PostReadMutation {
	m := &PostReadMutation{
		config:        c,
		op:            op,
		typ:           TypePostRead,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostReadID sets the ID field of the mutation.
func withPostReadID(id xid.ID) postreadOption {
	return func(m *PostReadMutation) {
		var (
			err   error
			once  sync.Once
			value *PostRead
		)
		m.oldValue = func(ctx context.Context) (*PostRead, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostRead.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostRead sets the old PostRead of the mutation.
func withPostRead(node *PostRead) postreadOption {
	return func(m *PostReadMutation) {
		m.oldValue = func(context.Context) (*PostRead, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostReadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostReadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostRead entities.
func (m *PostReadMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostReadMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostReadMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostRead.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRootPostID sets the "root_post_id" field.
func (m *PostReadMutation) SetRootPostID(x xid.ID) {
	m.root_post = &x
}

// RootPostID returns the value of the "root_post_id" field in the mutation.
func (m *PostReadMutation) RootPostID() (r xid.ID, exists bool) {
	v := m.root_post
	if v == nil {
		return
	}
	return *v, true
}

// OldRootPostID returns the old "root_post_id" field's value of the PostRead entity.
// If the PostRead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostReadMutation) OldRootPostID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootPostID: %w", err)
	}
	return oldValue.RootPostID, nil
}

// ResetRootPostID resets all changes to the "root_post_id" field.
func (m *PostReadMutation) ResetRootPostID() {
	m.root_post = nil
}

// SetAccountID sets the "account_id" field.
func (m *PostReadMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *PostReadMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the PostRead entity.
// If the PostRead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostReadMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *PostReadMutation) ResetAccountID() {
	m.account = nil
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *PostReadMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *PostReadMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the PostRead entity.
// If the PostRead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostReadMutation) OldLastSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *PostReadMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
}

// ClearRootPost clears the "root_post" edge to the Post entity.
func (m *PostReadMutation) ClearRootPost() {
	m.clearedroot_post = true
	m.clearedFields[postread.FieldRootPostID] = struct{}{}
}

// RootPostCleared reports if the "root_post" edge to the Post entity was cleared.
func (m *PostReadMutation) RootPostCleared() bool {
	return m.clearedroot_post
}

// RootPostIDs returns the "root_post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RootPostID instead. It exists only for internal usage by the builders.
func (m *PostReadMutation) RootPostIDs() (ids []xid.ID) {
	if id := m.root_post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRootPost resets all changes to the "root_post" edge.
func (m *PostReadMutation) ResetRootPost() {
	m.root_post = nil
	m.clearedroot_post = false
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *PostReadMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[postread.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *PostReadMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *PostReadMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *PostReadMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the PostReadMutation builder.
func (m *PostReadMutation) Where(ps ...predicate.PostRead) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostReadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostReadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostRead, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostReadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostReadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostRead).
func (m *PostReadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostReadMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.root_post != nil {
		fields = append(fields, postread.FieldRootPostID)
	}
	if m.account != nil {
		fields = append(fields, postread.FieldAccountID)
	}
	if m.last_seen_at != nil {
		fields = append(fields, postread.FieldLastSeenAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostReadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postread.FieldRootPostID:
		return m.RootPostID()
	case postread.FieldAccountID:
		return m.AccountID()
	case postread.FieldLastSeenAt:
		return m.LastSeenAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostReadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postread.FieldRootPostID:
		return m.OldRootPostID(ctx)
	case postread.FieldAccountID:
		return m.OldAccountID(ctx)
	case postread.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	}
	return nil, fmt.Errorf("unknown PostRead field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostReadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postread.FieldRootPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootPostID(v)
		return nil
	case postread.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case postread.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	}
	return fmt.Errorf("unknown PostRead field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostReadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostReadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostReadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PostRead numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostReadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostReadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostReadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PostRead nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostReadMutation) ResetField(name string) error {
	switch name {
	case postread.FieldRootPostID:
		m.ResetRootPostID()
		return nil
	case postread.FieldAccountID:
		m.ResetAccountID()
		return nil
	case postread.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	}
	return fmt.Errorf("unknown PostRead field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostReadMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.root_post != nil {
		edges = append(edges, postread.EdgeRootPost)
	}
	if m.account != nil {
		edges = append(edges, postread.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostReadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postread.EdgeRootPost:
		if id := m.root_post; id != nil {
			return []ent.Value{*id}
		}
	case postread.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostReadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostReadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostReadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroot_post {
		edges = append(edges, postread.EdgeRootPost)
	}
	if m.clearedaccount {
		edges = append(edges, postread.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostReadMutation) EdgeCleared(name string) bool {
	switch name {
	case postread.EdgeRootPost:
		return m.clearedroot_post
	case postread.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostReadMutation) ClearEdge(name string) error {
	switch name {
	case postread.EdgeRootPost:
		m.ClearRootPost()
		return nil
	case postread.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown PostRead unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostReadMutation) ResetEdge(name string) error {
	switch name {
	case postread.EdgeRootPost:
		m.ResetRootPost()
		return nil
	case postread.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown PostRead edge %s", name)
}

// PropertyMutation represents an operation that mutates the Property nodes in the graph.
type PropertyMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	value         *string
	clearedFields map[string]struct{}
	node          *xid.ID
	clearednode   bool
	schema        *xid.ID
	clearedschema bool
	done          bool
	oldValue      func(context.Context) (*Property, error)
	predicates    []predicate.Property
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows management of the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for the Property entity.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the ID field of the mutation.
func withPropertyID(id xid.ID) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Property entities.
func (m *PropertyMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Property.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PropertyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PropertyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PropertyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetNodeID sets the "node_id" field.
func (m *PropertyMutation) SetNodeID(x xid.ID) {
	m.node = &x
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *PropertyMutation) NodeID() (r xid.ID, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldNodeID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *PropertyMutation) ResetNodeID() {
	m.node = nil
}

// SetFieldID sets the "field_id" field.
func (m *PropertyMutation) SetFieldID(x xid.ID) {
	m.schema = &x
}

// FieldID returns the value of the "field_id" field in the mutation.
func (m *PropertyMutation) FieldID() (r xid.ID, exists bool) {
	v := m.schema
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldID returns the old "field_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldFieldID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldID: %w", err)
	}
	return oldValue.FieldID, nil
}

// ResetFieldID resets all changes to the "field_id" field.
func (m *PropertyMutation) ResetFieldID() {
	m.schema = nil
}

// SetValue sets the "value" field.
func (m *PropertyMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *PropertyMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *PropertyMutation) ResetValue() {
	m.value = nil
}

// ClearNode clears the "node" edge to the Node entity.
func (m *PropertyMutation) ClearNode() {
	m.clearednode = true
	m.clearedFields[property.FieldNodeID] = struct{}{}
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *PropertyMutation) NodeCleared() bool {
	return m.clearednode
}

// NodeIDs returns the "node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) NodeIDs() (ids []xid.ID) {
	if id := m.node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *PropertyMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
}

// SetSchemaID sets the "schema" edge to the PropertySchemaField entity by id.
func (m *PropertyMutation) SetSchemaID(id xid.ID) {
	m.schema = &id
}

// ClearSchema clears the "schema" edge to the PropertySchemaField entity.
func (m *PropertyMutation) ClearSchema() {
	m.clearedschema = true
	m.clearedFields[property.FieldFieldID] = struct{}{}
}

// SchemaCleared reports if the "schema" edge to the PropertySchemaField entity was cleared.
func (m *PropertyMutation) SchemaCleared() bool {
	return m.clearedschema
}

// SchemaID returns the "schema" edge ID in the mutation.
func (m *PropertyMutation) SchemaID() (id xid.ID, exists bool) {
	if m.schema != nil {
		return *m.schema, true
	}
	return
}

// SchemaIDs returns the "schema" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchemaID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) SchemaIDs() (ids []xid.ID) {
	if id := m.schema; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchema resets all changes to the "schema" edge.
func (m *PropertyMutation) ResetSchema() {
	m.schema = nil
	m.clearedschema = false
}

// Where appends a list predicates to the PropertyMutation builder.
func (m *PropertyMutation) Where(ps ...predicate.Property) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Property, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, property.FieldCreatedAt)
	}
	if m.node != nil {
		fields = append(fields, property.FieldNodeID)
	}
	if m.schema != nil {
		fields = append(fields, property.FieldFieldID)
	}
	if m.value != nil {
		fields = append(fields, property.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldCreatedAt:
		return m.CreatedAt()
	case property.FieldNodeID:
		return m.NodeID()
	case property.FieldFieldID:
		return m.FieldID()
	case property.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case property.FieldNodeID:
		return m.OldNodeID(ctx)
	case property.FieldFieldID:
		return m.OldFieldID(ctx)
	case property.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case property.FieldNodeID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case property.FieldFieldID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldID(v)
		return nil
	case property.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case property.FieldNodeID:
		m.ResetNodeID()
		return nil
	case property.FieldFieldID:
		m.ResetFieldID()
		return nil
	case property.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.node != nil {
		edges = append(edges, property.EdgeNode)
	}
	if m.schema != nil {
		edges = append(edges, property.EdgeSchema)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeNode:
		if id := m.node; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeSchema:
		if id := m.schema; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednode {
		edges = append(edges, property.EdgeNode)
	}
	if m.clearedschema {
		edges = append(edges, property.EdgeSchema)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgeNode:
		return m.clearednode
	case property.EdgeSchema:
		return m.clearedschema
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	case property.EdgeNode:
		m.ClearNode()
		return nil
	case property.EdgeSchema:
		m.ClearSchema()
		return nil
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgeNode:
		m.ResetNode()
		return nil
	case property.EdgeSchema:
		m.ResetSchema()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// PropertySchemaMutation represents an operation that mutates the PropertySchema nodes in the graph.
type PropertySchemaMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	clearedFields map[string]struct{}
	node          map[xid.ID]struct{}
	removednode   map[xid.ID]struct{}
	clearednode   bool
	fields        map[xid.ID]struct{}
	removedfields map[xid.ID]struct{}
	clearedfields bool
	done          bool
	oldValue      func(context.Context) (*PropertySchema, error)
	predicates    []predicate.PropertySchema
}

var _ ent.Mutation = (*PropertySchemaMutation)(nil)

// propertyschemaOption allows management of the mutation configuration using functional options.
type propertyschemaOption func(*PropertySchemaMutation)

// newPropertySchemaMutation creates new mutation for the PropertySchema entity.
func newPropertySchemaMutation(c config, op Op, opts ...propertyschemaOption) *PropertySchemaMutation {
	m := &PropertySchemaMutation{
		config:        c,
		op:            op,
		typ:           TypePropertySchema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertySchemaID sets the ID field of the mutation.
func withPropertySchemaID(id xid.ID) propertyschemaOption {
	return func(m *PropertySchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *PropertySchema
		)
		m.oldValue = func(ctx context.Context) (*PropertySchema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PropertySchema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPropertySchema sets the old PropertySchema of the mutation.
func withPropertySchema(node *PropertySchema) propertyschemaOption {
	return func(m *PropertySchemaMutation) {
		m.oldValue = func(context.Context) (*PropertySchema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertySchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertySchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PropertySchema entities.
func (m *PropertySchemaMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertySchemaMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertySchemaMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PropertySchema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddNodeIDs adds the "node" edge to the Node entity by ids.
func (m *PropertySchemaMutation) AddNodeIDs(ids ...xid.ID) {
	if m.node == nil {
		m.node = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.node[ids[i]] = struct{}{}
	}
}

// ClearNode clears the "node" edge to the Node entity.
func (m *PropertySchemaMutation) ClearNode() {
	m.clearednode = true
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *PropertySchemaMutation) NodeCleared() bool {
	return m.clearednode
}

// RemoveNodeIDs removes the "node" edge to the Node entity by IDs.
func (m *PropertySchemaMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednode == nil {
		m.removednode = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.node, ids[i])
		m.removednode[ids[i]] = struct{}{}
	}
}

// RemovedNode returns the removed IDs of the "node" edge to the Node entity.
func (m *PropertySchemaMutation) RemovedNodeIDs() (ids []xid.ID) {
	for id := range m.removednode {
		ids = append(ids, id)
	}
	return
}

// NodeIDs returns the "node" edge IDs in the mutation.
func (m *PropertySchemaMutation) NodeIDs() (ids []xid.ID) {
	for id := range m.node {
		ids = append(ids, id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *PropertySchemaMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
	m.removednode = nil
}

// AddFieldIDs adds the "fields" edge to the PropertySchemaField entity by ids.
func (m *PropertySchemaMutation) AddFieldIDs(ids ...xid.ID) {
	if m.fields == nil {
		m.fields = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.fields[ids[i]] = struct{}{}
	}
}

// ClearFields clears the "fields" edge to the PropertySchemaField entity.
func (m *PropertySchemaMutation) ClearFields() {
	m.clearedfields = true
}

// FieldsCleared reports if the "fields" edge to the PropertySchemaField entity was cleared.
func (m *PropertySchemaMutation) FieldsCleared() bool {
	return m.clearedfields
}

// RemoveFieldIDs removes the "fields" edge to the PropertySchemaField entity by IDs.
func (m *PropertySchemaMutation) RemoveFieldIDs(ids ...xid.ID) {
	if m.removedfields == nil {
		m.removedfields = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.fields, ids[i])
		m.removedfields[ids[i]] = struct{}{}
	}
}

// RemovedFields returns the removed IDs of the "fields" edge to the PropertySchemaField entity.
func (m *PropertySchemaMutation) RemovedFieldsIDs() (ids []xid.ID) {
	for id := range m.removedfields {
		ids = append(ids, id)
	}
	return
}

// FieldsIDs returns the "fields" edge IDs in the mutation.
func (m *PropertySchemaMutation) FieldsIDs() (ids []xid.ID) {
	for id := range m.fields {
		ids = append(ids, id)
	}
	return
}

// ResetFields resets all changes to the "fields" edge.
func (m *PropertySchemaMutation) ResetFields() {
	m.fields = nil
	m.clearedfields = false
	m.removedfields = nil
}

// Where appends a list predicates to the PropertySchemaMutation builder.
func (m *PropertySchemaMutation) Where(ps ...predicate.PropertySchema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertySchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertySchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PropertySchema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertySchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertySchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PropertySchema).
func (m *PropertySchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertySchemaMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertySchemaMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertySchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown PropertySchema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertySchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PropertySchema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertySchemaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertySchemaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertySchemaMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown PropertySchema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertySchemaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertySchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertySchemaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PropertySchema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertySchemaMutation) ResetField(name string) error {
	return fmt.Errorf("unknown PropertySchema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertySchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.node != nil {
		edges = append(edges, propertyschema.EdgeNode)
	}
	if m.fields != nil {
		edges = append(edges, propertyschema.EdgeFields)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertySchemaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case propertyschema.EdgeNode:
		ids := make([]ent.Value, 0, len(m.node))
		for id := range m.node {
			ids = append(ids, id)
		}
		return ids
	case propertyschema.EdgeFields:
		ids := make([]ent.Value, 0, len(m.fields))
		for id := range m.fields {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertySchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednode != nil {
		edges = append(edges, propertyschema.EdgeNode)
	}
	if m.removedfields != nil {
		edges = append(edges, propertyschema.EdgeFields)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertySchemaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case propertyschema.EdgeNode:
		ids := make([]ent.Value, 0, len(m.removednode))
		for id := range m.removednode {
			ids = append(ids, id)
		}
		return ids
	case propertyschema.EdgeFields:
		ids := make([]ent.Value, 0, len(m.removedfields))
		for id := range m.removedfields {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertySchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednode {
		edges = append(edges, propertyschema.EdgeNode)
	}
	if m.clearedfields {
		edges = append(edges, propertyschema.EdgeFields)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertySchemaMutation) EdgeCleared(name string) bool {
	switch name {
	case propertyschema.EdgeNode:
		return m.clearednode
	case propertyschema.EdgeFields:
		return m.clearedfields
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertySchemaMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PropertySchema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertySchemaMutation) ResetEdge(name string) error {
	switch name {
	case propertyschema.EdgeNode:
		m.ResetNode()
		return nil
	case propertyschema.EdgeFields:
		m.ResetFields()
		return nil
	}
	return fmt.Errorf("unknown PropertySchema edge %s", name)
}

// PropertySchemaFieldMutation represents an operation that mutates the PropertySchemaField nodes in the graph.
type PropertySchemaFieldMutation struct {
	config
	op                Op
	typ               string
	id                *xid.ID
	name              *string
	_type             *string
	sort              *string
	clearedFields     map[string]struct{}
	schema            *xid.ID
	clearedschema     bool
	properties        map[xid.ID]struct{}
	removedproperties map[xid.ID]struct{}
	clearedproperties bool
	done              bool
	oldValue          func(context.Context) (*PropertySchemaField, error)
	predicates        []predicate.PropertySchemaField
}

var _ ent.Mutation = (*PropertySchemaFieldMutation)(nil)

// propertyschemafieldOption allows management of the mutation configuration using functional options.
type propertyschemafieldOption func(*PropertySchemaFieldMutation)

// newPropertySchemaFieldMutation creates new mutation for the PropertySchemaField entity.
func newPropertySchemaFieldMutation(c config, op Op, opts ...propertyschemafieldOption) *PropertySchemaFieldMutation {
	m := &PropertySchemaFieldMutation{
		config:        c,
		op:            op,
		typ:           TypePropertySchemaField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertySchemaFieldID sets the ID field of the mutation.
func withPropertySchemaFieldID(id xid.ID) propertyschemafieldOption {
	return func(m *PropertySchemaFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *PropertySchemaField
		)
		m.oldValue = func(ctx context.Context) (*PropertySchemaField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PropertySchemaField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPropertySchemaField sets the old PropertySchemaField of the mutation.
func withPropertySchemaField(node *PropertySchemaField) propertyschemafieldOption {
	return func(m *PropertySchemaFieldMutation) {
		m.oldValue = func(context.Context) (*PropertySchemaField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertySchemaFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertySchemaFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PropertySchemaField entities.
func (m *PropertySchemaFieldMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertySchemaFieldMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertySchemaFieldMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PropertySchemaField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PropertySchemaFieldMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PropertySchemaFieldMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PropertySchemaField entity.
// If the PropertySchemaField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertySchemaFieldMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PropertySchemaFieldMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *PropertySchemaFieldMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PropertySchemaFieldMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PropertySchemaField entity.
// If the PropertySchemaField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertySchemaFieldMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PropertySchemaFieldMutation) ResetType() {
	m._type = nil
}

// SetSort sets the "sort" field.
func (m *PropertySchemaFieldMutation) SetSort(s string) {
	m.sort = &s
}

// Sort returns the value of the "sort" field in the mutation.
func (m *PropertySchemaFieldMutation) Sort() (r string, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the PropertySchemaField entity.
// If the PropertySchemaField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertySchemaFieldMutation) OldSort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// ResetSort resets all changes to the "sort" field.
func (m *PropertySchemaFieldMutation) ResetSort() {
	m.sort = nil
}

// SetSchemaID sets the "schema_id" field.
func (m *PropertySchemaFieldMutation) SetSchemaID(x xid.ID) {
	m.schema = &x
}

// SchemaID returns the value of the "schema_id" field in the mutation.
func (m *PropertySchemaFieldMutation) SchemaID() (r xid.ID, exists bool) {
	v := m.schema
	if v == nil {
		return
	}
	return *v, true
}

// OldSchemaID returns the old "schema_id" field's value of the PropertySchemaField entity.
// If the PropertySchemaField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertySchemaFieldMutation) OldSchemaID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchemaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchemaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchemaID: %w", err)
	}
	return oldValue.SchemaID, nil
}

// ResetSchemaID resets all changes to the "schema_id" field.
func (m *PropertySchemaFieldMutation) ResetSchemaID() {
	m.schema = nil
}

// ClearSchema clears the "schema" edge to the PropertySchema entity.
func (m *PropertySchemaFieldMutation) ClearSchema() {
	m.clearedschema = true
	m.clearedFields[propertyschemafield.FieldSchemaID] = struct{}{}
}

// SchemaCleared reports if the "schema" edge to the PropertySchema entity was cleared.
func (m *PropertySchemaFieldMutation) SchemaCleared() bool {
	return m.clearedschema
}

// SchemaIDs returns the "schema" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchemaID instead. It exists only for internal usage by the builders.
func (m *PropertySchemaFieldMutation) SchemaIDs() (ids []xid.ID) {
	if id := m.schema; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchema resets all changes to the "schema" edge.
func (m *PropertySchemaFieldMutation) ResetSchema() {
	m.schema = nil
	m.clearedschema = false
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *PropertySchemaFieldMutation) AddPropertyIDs(ids ...xid.ID) {
	if m.properties == nil {
		m.properties = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *PropertySchemaFieldMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *PropertySchemaFieldMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *PropertySchemaFieldMutation) RemovePropertyIDs(ids ...xid.ID) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *PropertySchemaFieldMutation) RemovedPropertiesIDs() (ids []xid.ID) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *PropertySchemaFieldMutation) PropertiesIDs() (ids []xid.ID) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *PropertySchemaFieldMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// Where appends a list predicates to the PropertySchemaFieldMutation builder.
func (m *PropertySchemaFieldMutation) Where(ps ...predicate.PropertySchemaField) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertySchemaFieldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertySchemaFieldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PropertySchemaField, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertySchemaFieldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertySchemaFieldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PropertySchemaField).
func (m *PropertySchemaFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertySchemaFieldMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, propertyschemafield.FieldName)
	}
	if m._type != nil {
		fields = append(fields, propertyschemafield.FieldType)
	}
	if m.sort != nil {
		fields = append(fields, propertyschemafield.FieldSort)
	}
	if m.schema != nil {
		fields = append(fields, propertyschemafield.FieldSchemaID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertySchemaFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case propertyschemafield.FieldName:
		return m.Name()
	case propertyschemafield.FieldType:
		return m.GetType()
	case propertyschemafield.FieldSort:
		return m.Sort()
	case propertyschemafield.FieldSchemaID:
		return m.SchemaID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertySchemaFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case propertyschemafield.FieldName:
		return m.OldName(ctx)
	case propertyschemafield.FieldType:
		return m.OldType(ctx)
	case propertyschemafield.FieldSort:
		return m.OldSort(ctx)
	case propertyschemafield.FieldSchemaID:
		return m.OldSchemaID(ctx)
	}
	return nil, fmt.Errorf("unknown PropertySchemaField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertySchemaFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case propertyschemafield.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case propertyschemafield.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case propertyschemafield.FieldSort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case propertyschemafield.FieldSchemaID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchemaID(v)
		return nil
	}
	return fmt.Errorf("unknown PropertySchemaField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertySchemaFieldMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertySchemaFieldMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertySchemaFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PropertySchemaField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertySchemaFieldMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertySchemaFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertySchemaFieldMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PropertySchemaField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertySchemaFieldMutation) ResetField(name string) error {
	switch name {
	case propertyschemafield.FieldName:
		m.ResetName()
		return nil
	case propertyschemafield.FieldType:
		m.ResetType()
		return nil
	case propertyschemafield.FieldSort:
		m.ResetSort()
		return nil
	case propertyschemafield.FieldSchemaID:
		m.ResetSchemaID()
		return nil
	}
	return fmt.Errorf("unknown PropertySchemaField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertySchemaFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.schema != nil {
		edges = append(edges, propertyschemafield.EdgeSchema)
	}
	if m.properties != nil {
		edges = append(edges, propertyschemafield.EdgeProperties)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertySchemaFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case propertyschemafield.EdgeSchema:
		if id := m.schema; id != nil {
			return []ent.Value{*id}
		}
	case propertyschemafield.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertySchemaFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproperties != nil {
		edges = append(edges, propertyschemafield.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertySchemaFieldMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case propertyschemafield.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertySchemaFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedschema {
		edges = append(edges, propertyschemafield.EdgeSchema)
	}
	if m.clearedproperties {
		edges = append(edges, propertyschemafield.EdgeProperties)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertySchemaFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case propertyschemafield.EdgeSchema:
		return m.clearedschema
	case propertyschemafield.EdgeProperties:
		return m.clearedproperties
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertySchemaFieldMutation) ClearEdge(name string) error {
	switch name {
	case propertyschemafield.EdgeSchema:
		m.ClearSchema()
		return nil
	}
	return fmt.Errorf("unknown PropertySchemaField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertySchemaFieldMutation) ResetEdge(name string) error {
	switch name {
	case propertyschemafield.EdgeSchema:
		m.ResetSchema()
		return nil
	case propertyschemafield.EdgeProperties:
		m.ResetProperties()
		return nil
	}
	return fmt.Errorf("unknown PropertySchemaField edge %s", name)
}

// QuestionMutation represents an operation that mutates the Question nodes in the graph.
type QuestionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *xid.ID
	created_at             *time.Time
	indexed_at             *time.Time
	slug                   *string
	query                  *string
	result                 *string
	metadata               *map[string]interface{}
	clearedFields          map[string]struct{}
	author                 *xid.ID
	clearedauthor          bool
	parent                 *xid.ID
	clearedparent          bool
	parent_question        map[xid.ID]struct{}
	removedparent_question map[xid.ID]struct{}
	clearedparent_question bool
	done                   bool
	oldValue               func(context.Context) (*Question, error)
	predicates             []predicate.Question
}

var _ ent.Mutation = (*QuestionMutation)(nil)

// questionOption allows management of the mutation configuration using functional options.
type questionOption func(*QuestionMutation)

// newQuestionMutation creates new mutation for the Question entity.
func newQuestionMutation(c config, op Op, opts ...questionOption) *QuestionMutation {
	m := &QuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuestionID sets the ID field of the mutation.
func withQuestionID(id xid.ID) questionOption {
	return func(m *QuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *Question
		)
		m.oldValue = func(ctx context.Context) (*Question, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Question.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuestion sets the old Question of the mutation.
func withQuestion(node *Question) questionOption {
	return func(m *QuestionMutation) {
		m.oldValue = func(context.Context) (*Question, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Question entities.
func (m *QuestionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuestionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuestionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Question.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *QuestionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *QuestionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *QuestionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetIndexedAt sets the "indexed_at" field.
func (m *QuestionMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *QuestionMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *QuestionMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[question.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *QuestionMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[question.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *QuestionMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, question.FieldIndexedAt)
}

// SetSlug sets the "slug" field.
func (m *QuestionMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *QuestionMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *QuestionMutation) ResetSlug() {
	m.slug = nil
}

// SetQuery sets the "query" field.
func (m *QuestionMutation) SetQuery(s string) {
	m.query = &s
}

// Query returns the value of the "query" field in the mutation.
func (m *QuestionMutation) Query() (r string, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ResetQuery resets all changes to the "query" field.
func (m *QuestionMutation) ResetQuery() {
	m.query = nil
}

// SetResult sets the "result" field.
func (m *QuestionMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *QuestionMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *QuestionMutation) ResetResult() {
	m.result = nil
}

// SetMetadata sets the "metadata" field.
func (m *QuestionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *QuestionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *QuestionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[question.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *QuestionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[question.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *QuestionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, question.FieldMetadata)
}

// SetAccountID sets the "account_id" field.
func (m *QuestionMutation) SetAccountID(x xid.ID) {
	m.author = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *QuestionMutation) AccountID() (r xid.ID, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *QuestionMutation) ClearAccountID() {
	m.author = nil
	m.clearedFields[question.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *QuestionMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[question.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *QuestionMutation) ResetAccountID() {
	m.author = nil
	delete(m.clearedFields, question.FieldAccountID)
}

// SetParentQuestionID sets the "parent_question_id" field.
func (m *QuestionMutation) SetParentQuestionID(x xid.ID) {
	m.parent = &x
}

// ParentQuestionID returns the value of the "parent_question_id" field in the mutation.
func (m *QuestionMutation) ParentQuestionID() (r xid.ID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentQuestionID returns the old "parent_question_id" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldParentQuestionID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentQuestionID: %w", err)
	}
	return oldValue.ParentQuestionID, nil
}

// ClearParentQuestionID clears the value of the "parent_question_id" field.
func (m *QuestionMutation) ClearParentQuestionID() {
	m.parent = nil
	m.clearedFields[question.FieldParentQuestionID] = struct{}{}
}

// ParentQuestionIDCleared returns if the "parent_question_id" field was cleared in this mutation.
func (m *QuestionMutation) ParentQuestionIDCleared() bool {
	_, ok := m.clearedFields[question.FieldParentQuestionID]
	return ok
}

// ResetParentQuestionID resets all changes to the "parent_question_id" field.
func (m *QuestionMutation) ResetParentQuestionID() {
	m.parent = nil
	delete(m.clearedFields, question.FieldParentQuestionID)
}

// SetAuthorID sets the "author" edge to the Account entity by id.
func (m *QuestionMutation) SetAuthorID(id xid.ID) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the Account entity.
func (m *QuestionMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[question.FieldAccountID] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the Account entity was cleared.
func (m *QuestionMutation) AuthorCleared() bool {
	return m.AccountIDCleared() || m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *QuestionMutation) AuthorID() (id xid.ID, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *QuestionMutation) AuthorIDs() (ids []xid.ID) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *QuestionMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetParentID sets the "parent" edge to the Question entity by id.
func (m *QuestionMutation) SetParentID(id xid.ID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Question entity.
func (m *QuestionMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[question.FieldParentQuestionID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Question entity was cleared.
func (m *QuestionMutation) ParentCleared() bool {
	return m.ParentQuestionIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *QuestionMutation) ParentID() (id xid.ID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *QuestionMutation) ParentIDs() (ids []xid.ID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *QuestionMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddParentQuestionIDs adds the "parent_question" edge to the Question entity by ids.
func (m *QuestionMutation) AddParentQuestionIDs(ids ...xid.ID) {
	if m.parent_question == nil {
		m.parent_question = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.parent_question[ids[i]] = struct{}{}
	}
}

// ClearParentQuestion clears the "parent_question" edge to the Question entity.
func (m *QuestionMutation) ClearParentQuestion() {
	m.clearedparent_question = true
}

// ParentQuestionCleared reports if the "parent_question" edge to the Question entity was cleared.
func (m *QuestionMutation) ParentQuestionCleared() bool {
	return m.clearedparent_question
}

// RemoveParentQuestionIDs removes the "parent_question" edge to the Question entity by IDs.
func (m *QuestionMutation) RemoveParentQuestionIDs(ids ...xid.ID) {
	if m.removedparent_question == nil {
		m.removedparent_question = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.parent_question, ids[i])
		m.removedparent_question[ids[i]] = struct{}{}
	}
}

// RemovedParentQuestion returns the removed IDs of the "parent_question" edge to the Question entity.
func (m *QuestionMutation) RemovedParentQuestionIDs() (ids []xid.ID) {
	for id := range m.removedparent_question {
		ids = append(ids, id)
	}
	return
}

// ParentQuestionIDs returns the "parent_question" edge IDs in the mutation.
func (m *QuestionMutation) ParentQuestionIDs() (ids []xid.ID) {
	for id := range m.parent_question {
		ids = append(ids, id)
	}
	return
}

// ResetParentQuestion resets all changes to the "parent_question" edge.
func (m *QuestionMutation) ResetParentQuestion() {
	m.parent_question = nil
	m.clearedparent_question = false
	m.removedparent_question = nil
}

// Where appends a list predicates to the QuestionMutation builder.
func (m *QuestionMutation) Where(ps ...predicate.Question) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Question, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Question).
func (m *QuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuestionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, question.FieldCreatedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, question.FieldIndexedAt)
	}
	if m.slug != nil {
		fields = append(fields, question.FieldSlug)
	}
	if m.query != nil {
		fields = append(fields, question.FieldQuery)
	}
	if m.result != nil {
		fields = append(fields, question.FieldResult)
	}
	if m.metadata != nil {
		fields = append(fields, question.FieldMetadata)
	}
	if m.author != nil {
		fields = append(fields, question.FieldAccountID)
	}
	if m.parent != nil {
		fields = append(fields, question.FieldParentQuestionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case question.FieldCreatedAt:
		return m.CreatedAt()
	case question.FieldIndexedAt:
		return m.IndexedAt()
	case question.FieldSlug:
		return m.Slug()
	case question.FieldQuery:
		return m.Query()
	case question.FieldResult:
		return m.Result()
	case question.FieldMetadata:
		return m.Metadata()
	case question.FieldAccountID:
		return m.AccountID()
	case question.FieldParentQuestionID:
		return m.ParentQuestionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case question.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case question.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case question.FieldSlug:
		return m.OldSlug(ctx)
	case question.FieldQuery:
		return m.OldQuery(ctx)
	case question.FieldResult:
		return m.OldResult(ctx)
	case question.FieldMetadata:
		return m.OldMetadata(ctx)
	case question.FieldAccountID:
		return m.OldAccountID(ctx)
	case question.FieldParentQuestionID:
		return m.OldParentQuestionID(ctx)
	}
	return nil, fmt.Errorf("unknown Question field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case question.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case question.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case question.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case question.FieldQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	case question.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case question.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case question.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case question.FieldParentQuestionID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentQuestionID(v)
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuestionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuestionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Question numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(question.FieldIndexedAt) {
		fields = append(fields, question.FieldIndexedAt)
	}
	if m.FieldCleared(question.FieldMetadata) {
		fields = append(fields, question.FieldMetadata)
	}
	if m.FieldCleared(question.FieldAccountID) {
		fields = append(fields, question.FieldAccountID)
	}
	if m.FieldCleared(question.FieldParentQuestionID) {
		fields = append(fields, question.FieldParentQuestionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuestionMutation) ClearField(name string) error {
	switch name {
	case question.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case question.FieldMetadata:
		m.ClearMetadata()
		return nil
	case question.FieldAccountID:
		m.ClearAccountID()
		return nil
	case question.FieldParentQuestionID:
		m.ClearParentQuestionID()
		return nil
	}
	return fmt.Errorf("unknown Question nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuestionMutation) ResetField(name string) error {
	switch name {
	case question.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case question.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case question.FieldSlug:
		m.ResetSlug()
		return nil
	case question.FieldQuery:
		m.ResetQuery()
		return nil
	case question.FieldResult:
		m.ResetResult()
		return nil
	case question.FieldMetadata:
		m.ResetMetadata()
		return nil
	case question.FieldAccountID:
		m.ResetAccountID()
		return nil
	case question.FieldParentQuestionID:
		m.ResetParentQuestionID()
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.author != nil {
		edges = append(edges, question.EdgeAuthor)
	}
	if m.parent != nil {
		edges = append(edges, question.EdgeParent)
	}
	if m.parent_question != nil {
		edges = append(edges, question.EdgeParentQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case question.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case question.EdgeParentQuestion:
		ids := make([]ent.Value, 0, len(m.parent_question))
		for id := range m.parent_question {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedparent_question != nil {
		edges = append(edges, question.EdgeParentQuestion)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeParentQuestion:
		ids := make([]ent.Value, 0, len(m.removedparent_question))
		for id := range m.removedparent_question {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedauthor {
		edges = append(edges, question.EdgeAuthor)
	}
	if m.clearedparent {
		edges = append(edges, question.EdgeParent)
	}
	if m.clearedparent_question {
		edges = append(edges, question.EdgeParentQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case question.EdgeAuthor:
		return m.clearedauthor
	case question.EdgeParent:
		return m.clearedparent
	case question.EdgeParentQuestion:
		return m.clearedparent_question
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuestionMutation) ClearEdge(name string) error {
	switch name {
	case question.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case question.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Question unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuestionMutation) ResetEdge(name string) error {
	switch name {
	case question.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case question.EdgeParent:
		m.ResetParent()
		return nil
	case question.EdgeParentQuestion:
		m.ResetParentQuestion()
		return nil
	}
	return fmt.Errorf("unknown Question edge %s", name)
}

// ReactMutation represents an operation that mutates the React nodes in the graph.
type ReactMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	emoji          *string
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	_Post          *xid.ID
	cleared_Post   bool
	done           bool
	oldValue       func(context.Context) (*React, error)
	predicates     []predicate.React
}

var _ ent.Mutation = (*ReactMutation)(nil)

// reactOption allows management of the mutation configuration using functional options.
type reactOption func(*ReactMutation)

// newReactMutation creates new mutation for the React entity.
func newReactMutation(c config, op Op, opts ...reactOption) *ReactMutation {
	m := &ReactMutation{
		config:        c,
		op:            op,
		typ:           TypeReact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReactID sets the ID field of the mutation.
func withReactID(id xid.ID) reactOption {
	return func(m *ReactMutation) {
		var (
			err   error
			once  sync.Once
			value *React
		)
		m.oldValue = func(ctx context.Context) (*React, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().React.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReact sets the old React of the mutation.
func withReact(node *React) reactOption {
	return func(m *ReactMutation) {
		m.oldValue = func(context.Context) (*React, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of React entities.
func (m *ReactMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReactMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReactMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().React.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountID sets the "account_id" field.
func (m *ReactMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *ReactMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *ReactMutation) ResetAccountID() {
	m.account = nil
}

// SetPostID sets the "post_id" field.
func (m *ReactMutation) SetPostID(x xid.ID) {
	m._Post = &x
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *ReactMutation) PostID() (r xid.ID, exists bool) {
	v := m._Post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldPostID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *ReactMutation) ResetPostID() {
	m._Post = nil
}

// SetEmoji sets the "emoji" field.
func (m *ReactMutation) SetEmoji(s string) {
	m.emoji = &s
}

// Emoji returns the value of the "emoji" field in the mutation.
func (m *ReactMutation) Emoji() (r string, exists bool) {
	v := m.emoji
	if v == nil {
		return
	}
	return *v, true
}

// OldEmoji returns the old "emoji" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldEmoji(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmoji is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmoji requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmoji: %w", err)
	}
	return oldValue.Emoji, nil
}

// ResetEmoji resets all changes to the "emoji" field.
func (m *ReactMutation) ResetEmoji() {
	m.emoji = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *ReactMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[react.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *ReactMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *ReactMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *ReactMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearPost clears the "Post" edge to the Post entity.
func (m *ReactMutation) ClearPost() {
	m.cleared_Post = true
	m.clearedFields[react.FieldPostID] = struct{}{}
}

// PostCleared reports if the "Post" edge to the Post entity was cleared.
func (m *ReactMutation) PostCleared() bool {
	return m.cleared_Post
}

// PostIDs returns the "Post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *ReactMutation) PostIDs() (ids []xid.ID) {
	if id := m._Post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "Post" edge.
func (m *ReactMutation) ResetPost() {
	m._Post = nil
	m.cleared_Post = false
}

// Where appends a list predicates to the ReactMutation builder.
func (m *ReactMutation) Where(ps ...predicate.React) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.React, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (React).
func (m *ReactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReactMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, react.FieldCreatedAt)
	}
	if m.account != nil {
		fields = append(fields, react.FieldAccountID)
	}
	if m._Post != nil {
		fields = append(fields, react.FieldPostID)
	}
	if m.emoji != nil {
		fields = append(fields, react.FieldEmoji)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case react.FieldCreatedAt:
		return m.CreatedAt()
	case react.FieldAccountID:
		return m.AccountID()
	case react.FieldPostID:
		return m.PostID()
	case react.FieldEmoji:
		return m.Emoji()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case react.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case react.FieldAccountID:
		return m.OldAccountID(ctx)
	case react.FieldPostID:
		return m.OldPostID(ctx)
	case react.FieldEmoji:
		return m.OldEmoji(ctx)
	}
	return nil, fmt.Errorf("unknown React field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case react.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case react.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case react.FieldPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case react.FieldEmoji:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmoji(v)
		return nil
	}
	return fmt.Errorf("unknown React field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown React numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown React nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReactMutation) ResetField(name string) error {
	switch name {
	case react.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case react.FieldAccountID:
		m.ResetAccountID()
		return nil
	case react.FieldPostID:
		m.ResetPostID()
		return nil
	case react.FieldEmoji:
		m.ResetEmoji()
		return nil
	}
	return fmt.Errorf("unknown React field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReactMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, react.EdgeAccount)
	}
	if m._Post != nil {
		edges = append(edges, react.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case react.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case react.EdgePost:
		if id := m._Post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, react.EdgeAccount)
	}
	if m.cleared_Post {
		edges = append(edges, react.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReactMutation) EdgeCleared(name string) bool {
	switch name {
	case react.EdgeAccount:
		return m.clearedaccount
	case react.EdgePost:
		return m.cleared_Post
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReactMutation) ClearEdge(name string) error {
	switch name {
	case react.EdgeAccount:
		m.ClearAccount()
		return nil
	case react.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown React unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReactMutation) ResetEdge(name string) error {
	switch name {
	case react.EdgeAccount:
		m.ResetAccount()
		return nil
	case react.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown React edge %s", name)
}

// ReportMutation represents an operation that mutates the Report nodes in the graph.
type ReportMutation struct {
	config
	op                 Op
	typ                string
	id                 *xid.ID
	created_at         *time.Time
	updated_at         *time.Time
	target_id          *xid.ID
	target_kind        *string
	comment            *string
	reason             *string
	status             *string
	clearedFields      map[string]struct{}
	reported_by        *xid.ID
	clearedreported_by bool
	handled_by         *xid.ID
	clearedhandled_by  bool
	done               bool
	oldValue           func(context.Context) (*Report, error)
	predicates         []predicate.Report
}

var _ ent.Mutation = (*ReportMutation)(nil)

// reportOption allows management of the mutation configuration using functional options.
type reportOption func(*ReportMutation)

// newReportMutation creates new mutation for the Report entity.
func newReportMutation(c config, op Op, opts ...reportOption) *ReportMutation {
	m := &ReportMutation{
		config:        c,
		op:            op,
		typ:           TypeReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportID sets the ID field of the mutation.
func withReportID(id xid.ID) reportOption {
	return func(m *ReportMutation) {
		var (
			err   error
			once  sync.Once
			value *Report
		)
		m.oldValue = func(ctx context.Context) (*Report, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Report.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReport sets the old Report of the mutation.
func withReport(node *Report) reportOption {
	return func(m *ReportMutation) {
		m.oldValue = func(context.Context) (*Report, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Report entities.
func (m *ReportMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Report.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTargetID sets the "target_id" field.
func (m *ReportMutation) SetTargetID(x xid.ID) {
	m.target_id = &x
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *ReportMutation) TargetID() (r xid.ID, exists bool) {
	v := m.target_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldTargetID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *ReportMutation) ResetTargetID() {
	m.target_id = nil
}

// SetTargetKind sets the "target_kind" field.
func (m *ReportMutation) SetTargetKind(s string) {
	m.target_kind = &s
}

// TargetKind returns the value of the "target_kind" field in the mutation.
func (m *ReportMutation) TargetKind() (r string, exists bool) {
	v := m.target_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetKind returns the old "target_kind" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldTargetKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetKind: %w", err)
	}
	return oldValue.TargetKind, nil
}

// ResetTargetKind resets all changes to the "target_kind" field.
func (m *ReportMutation) ResetTargetKind() {
	m.target_kind = nil
}

// SetReportedByID sets the "reported_by_id" field.
func (m *ReportMutation) SetReportedByID(x xid.ID) {
	m.reported_by = &x
}

// ReportedByID returns the value of the "reported_by_id" field in the mutation.
func (m *ReportMutation) ReportedByID() (r xid.ID, exists bool) {
	v := m.reported_by
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedByID returns the old "reported_by_id" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldReportedByID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedByID: %w", err)
	}
	return oldValue.ReportedByID, nil
}

// ClearReportedByID clears the value of the "reported_by_id" field.
func (m *ReportMutation) ClearReportedByID() {
	m.reported_by = nil
	m.clearedFields[report.FieldReportedByID] = struct{}{}
}

// ReportedByIDCleared returns if the "reported_by_id" field was cleared in this mutation.
func (m *ReportMutation) ReportedByIDCleared() bool {
	_, ok := m.clearedFields[report.FieldReportedByID]
	return ok
}

// ResetReportedByID resets all changes to the "reported_by_id" field.
func (m *ReportMutation) ResetReportedByID() {
	m.reported_by = nil
	delete(m.clearedFields, report.FieldReportedByID)
}

// SetHandledByID sets the "handled_by_id" field.
func (m *ReportMutation) SetHandledByID(x xid.ID) {
	m.handled_by = &x
}

// HandledByID returns the value of the "handled_by_id" field in the mutation.
func (m *ReportMutation) HandledByID() (r xid.ID, exists bool) {
	v := m.handled_by
	if v == nil {
		return
	}
	return *v, true
}

// OldHandledByID returns the old "handled_by_id" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldHandledByID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandledByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandledByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandledByID: %w", err)
	}
	return oldValue.HandledByID, nil
}

// ClearHandledByID clears the value of the "handled_by_id" field.
func (m *ReportMutation) ClearHandledByID() {
	m.handled_by = nil
	m.clearedFields[report.FieldHandledByID] = struct{}{}
}

// HandledByIDCleared returns if the "handled_by_id" field was cleared in this mutation.
func (m *ReportMutation) HandledByIDCleared() bool {
	_, ok := m.clearedFields[report.FieldHandledByID]
	return ok
}

// ResetHandledByID resets all changes to the "handled_by_id" field.
func (m *ReportMutation) ResetHandledByID() {
	m.handled_by = nil
	delete(m.clearedFields, report.FieldHandledByID)
}

// SetComment sets the "comment" field.
func (m *ReportMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ReportMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *ReportMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[report.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *ReportMutation) CommentCleared() bool {
	_, ok := m.clearedFields[report.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *ReportMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, report.FieldComment)
}

// SetReason sets the "reason" field.
func (m *ReportMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *ReportMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *ReportMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[report.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *ReportMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[report.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *ReportMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, report.FieldReason)
}

// SetStatus sets the "status" field.
func (m *ReportMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ReportMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReportMutation) ResetStatus() {
	m.status = nil
}

// ClearReportedBy clears the "reported_by" edge to the Account entity.
func (m *ReportMutation) ClearReportedBy() {
	m.clearedreported_by = true
	m.clearedFields[report.FieldReportedByID] = struct{}{}
}

// ReportedByCleared reports if the "reported_by" edge to the Account entity was cleared.
func (m *ReportMutation) ReportedByCleared() bool {
	return m.ReportedByIDCleared() || m.clearedreported_by
}

// ReportedByIDs returns the "reported_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReportedByID instead. It exists only for internal usage by the builders.
func (m *ReportMutation) ReportedByIDs() (ids []xid.ID) {
	if id := m.reported_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReportedBy resets all changes to the "reported_by" edge.
func (m *ReportMutation) ResetReportedBy() {
	m.reported_by = nil
	m.clearedreported_by = false
}

// ClearHandledBy clears the "handled_by" edge to the Account entity.
func (m *ReportMutation) ClearHandledBy() {
	m.clearedhandled_by = true
	m.clearedFields[report.FieldHandledByID] = struct{}{}
}

// HandledByCleared reports if the "handled_by" edge to the Account entity was cleared.
func (m *ReportMutation) HandledByCleared() bool {
	return m.HandledByIDCleared() || m.clearedhandled_by
}

// HandledByIDs returns the "handled_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HandledByID instead. It exists only for internal usage by the builders.
func (m *ReportMutation) HandledByIDs() (ids []xid.ID) {
	if id := m.handled_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHandledBy resets all changes to the "handled_by" edge.
func (m *ReportMutation) ResetHandledBy() {
	m.handled_by = nil
	m.clearedhandled_by = false
}

// Where appends a list predicates to the ReportMutation builder.
func (m *ReportMutation) Where(ps ...predicate.Report) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Report, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Report).
func (m *ReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, report.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, report.FieldUpdatedAt)
	}
	if m.target_id != nil {
		fields = append(fields, report.FieldTargetID)
	}
	if m.target_kind != nil {
		fields = append(fields, report.FieldTargetKind)
	}
	if m.reported_by != nil {
		fields = append(fields, report.FieldReportedByID)
	}
	if m.handled_by != nil {
		fields = append(fields, report.FieldHandledByID)
	}
	if m.comment != nil {
		fields = append(fields, report.FieldComment)
	}
	if m.reason != nil {
		fields = append(fields, report.FieldReason)
	}
	if m.status != nil {
		fields = append(fields, report.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case report.FieldCreatedAt:
		return m.CreatedAt()
	case report.FieldUpdatedAt:
		return m.UpdatedAt()
	case report.FieldTargetID:
		return m.TargetID()
	case report.FieldTargetKind:
		return m.TargetKind()
	case report.FieldReportedByID:
		return m.ReportedByID()
	case report.FieldHandledByID:
		return m.HandledByID()
	case report.FieldComment:
		return m.Comment()
	case report.FieldReason:
		return m.Reason()
	case report.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case report.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case report.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case report.FieldTargetID:
		return m.OldTargetID(ctx)
	case report.FieldTargetKind:
		return m.OldTargetKind(ctx)
	case report.FieldReportedByID:
		return m.OldReportedByID(ctx)
	case report.FieldHandledByID:
		return m.OldHandledByID(ctx)
	case report.FieldComment:
		return m.OldComment(ctx)
	case report.FieldReason:
		return m.OldReason(ctx)
	case report.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Report field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case report.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case report.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case report.FieldTargetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case report.FieldTargetKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetKind(v)
		return nil
	case report.FieldReportedByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedByID(v)
		return nil
	case report.FieldHandledByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandledByID(v)
		return nil
	case report.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case report.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case report.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Report numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(report.FieldReportedByID) {
		fields = append(fields, report.FieldReportedByID)
	}
	if m.FieldCleared(report.FieldHandledByID) {
		fields = append(fields, report.FieldHandledByID)
	}
	if m.FieldCleared(report.FieldComment) {
		fields = append(fields, report.FieldComment)
	}
	if m.FieldCleared(report.FieldReason) {
		fields = append(fields, report.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportMutation) ClearField(name string) error {
	switch name {
	case report.FieldReportedByID:
		m.ClearReportedByID()
		return nil
	case report.FieldHandledByID:
		m.ClearHandledByID()
		return nil
	case report.FieldComment:
		m.ClearComment()
		return nil
	case report.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown Report nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportMutation) ResetField(name string) error {
	switch name {
	case report.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case report.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case report.FieldTargetID:
		m.ResetTargetID()
		return nil
	case report.FieldTargetKind:
		m.ResetTargetKind()
		return nil
	case report.FieldReportedByID:
		m.ResetReportedByID()
		return nil
	case report.FieldHandledByID:
		m.ResetHandledByID()
		return nil
	case report.FieldComment:
		m.ResetComment()
		return nil
	case report.FieldReason:
		m.ResetReason()
		return nil
	case report.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.reported_by != nil {
		edges = append(edges, report.EdgeReportedBy)
	}
	if m.handled_by != nil {
		edges = append(edges, report.EdgeHandledBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case report.EdgeReportedBy:
		if id := m.reported_by; id != nil {
			return []ent.Value{*id}
		}
	case report.EdgeHandledBy:
		if id := m.handled_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedreported_by {
		edges = append(edges, report.EdgeReportedBy)
	}
	if m.clearedhandled_by {
		edges = append(edges, report.EdgeHandledBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportMutation) EdgeCleared(name string) bool {
	switch name {
	case report.EdgeReportedBy:
		return m.clearedreported_by
	case report.EdgeHandledBy:
		return m.clearedhandled_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportMutation) ClearEdge(name string) error {
	switch name {
	case report.EdgeReportedBy:
		m.ClearReportedBy()
		return nil
	case report.EdgeHandledBy:
		m.ClearHandledBy()
		return nil
	}
	return fmt.Errorf("unknown Report unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportMutation) ResetEdge(name string) error {
	switch name {
	case report.EdgeReportedBy:
		m.ResetReportedBy()
		return nil
	case report.EdgeHandledBy:
		m.ResetHandledBy()
		return nil
	}
	return fmt.Errorf("unknown Report edge %s", name)
}

// RobotMutation represents an operation that mutates the Robot nodes in the graph.
type RobotMutation struct {
	config
	op              Op
	typ             string
	id              *xid.ID
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	playbook        *string
	tools           *[]string
	appendtools     []string
	metadata        *map[string]interface{}
	clearedFields   map[string]struct{}
	author          *xid.ID
	clearedauthor   bool
	messages        map[xid.ID]struct{}
	removedmessages map[xid.ID]struct{}
	clearedmessages bool
	done            bool
	oldValue        func(context.Context) (*Robot, error)
	predicates      []predicate.Robot
}

var _ ent.Mutation = (*RobotMutation)(nil)

// robotOption allows management of the mutation configuration using functional options.
type robotOption func(*RobotMutation)

// newRobotMutation creates new mutation for the Robot entity.
func newRobotMutation(c config, op Op, opts ...robotOption) *RobotMutation {
	m := &RobotMutation{
		config:        c,
		op:            op,
		typ:           TypeRobot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRobotID sets the ID field of the mutation.
func withRobotID(id xid.ID) robotOption {
	return func(m *RobotMutation) {
		var (
			err   error
			once  sync.Once
			value *Robot
		)
		m.oldValue = func(ctx context.Context) (*Robot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Robot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRobot sets the old Robot of the mutation.
func withRobot(node *Robot) robotOption {
	return func(m *RobotMutation) {
		m.oldValue = func(context.Context) (*Robot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RobotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RobotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Robot entities.
func (m *RobotMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RobotMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RobotMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Robot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RobotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RobotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Robot entity.
// If the Robot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RobotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RobotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RobotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Robot entity.
// If the Robot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RobotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RobotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RobotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Robot entity.
// If the Robot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RobotMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RobotMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RobotMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Robot entity.
// If the Robot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RobotMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[robot.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RobotMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[robot.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RobotMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, robot.FieldDescription)
}

// SetPlaybook sets the "playbook" field.
func (m *RobotMutation) SetPlaybook(s string) {
	m.playbook = &s
}

// Playbook returns the value of the "playbook" field in the mutation.
func (m *RobotMutation) Playbook() (r string, exists bool) {
	v := m.playbook
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaybook returns the old "playbook" field's value of the Robot entity.
// If the Robot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotMutation) OldPlaybook(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaybook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaybook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaybook: %w", err)
	}
	return oldValue.Playbook, nil
}

// ResetPlaybook resets all changes to the "playbook" field.
func (m *RobotMutation) ResetPlaybook() {
	m.playbook = nil
}

// SetTools sets the "tools" field.
func (m *RobotMutation) SetTools(s []string) {
	m.tools = &s
	m.appendtools = nil
}

// Tools returns the value of the "tools" field in the mutation.
func (m *RobotMutation) Tools() (r []string, exists bool) {
	v := m.tools
	if v == nil {
		return
	}
	return *v, true
}

// OldTools returns the old "tools" field's value of the Robot entity.
// If the Robot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotMutation) OldTools(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTools is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTools requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTools: %w", err)
	}
	return oldValue.Tools, nil
}

// AppendTools adds s to the "tools" field.
func (m *RobotMutation) AppendTools(s []string) {
	m.appendtools = append(m.appendtools, s...)
}

// AppendedTools returns the list of values that were appended to the "tools" field in this mutation.
func (m *RobotMutation) AppendedTools() ([]string, bool) {
	if len(m.appendtools) == 0 {
		return nil, false
	}
	return m.appendtools, true
}

// ClearTools clears the value of the "tools" field.
func (m *RobotMutation) ClearTools() {
	m.tools = nil
	m.appendtools = nil
	m.clearedFields[robot.FieldTools] = struct{}{}
}

// ToolsCleared returns if the "tools" field was cleared in this mutation.
func (m *RobotMutation) ToolsCleared() bool {
	_, ok := m.clearedFields[robot.FieldTools]
	return ok
}

// ResetTools resets all changes to the "tools" field.
func (m *RobotMutation) ResetTools() {
	m.tools = nil
	m.appendtools = nil
	delete(m.clearedFields, robot.FieldTools)
}

// SetMetadata sets the "metadata" field.
func (m *RobotMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *RobotMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Robot entity.
// If the Robot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *RobotMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[robot.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *RobotMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[robot.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *RobotMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, robot.FieldMetadata)
}

// SetAuthorID sets the "author_id" field.
func (m *RobotMutation) SetAuthorID(x xid.ID) {
	m.author = &x
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *RobotMutation) AuthorID() (r xid.ID, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the Robot entity.
// If the Robot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotMutation) OldAuthorID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *RobotMutation) ResetAuthorID() {
	m.author = nil
}

// ClearAuthor clears the "author" edge to the Account entity.
func (m *RobotMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[robot.FieldAuthorID] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the Account entity was cleared.
func (m *RobotMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *RobotMutation) AuthorIDs() (ids []xid.ID) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *RobotMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// AddMessageIDs adds the "messages" edge to the RobotSessionMessage entity by ids.
func (m *RobotMutation) AddMessageIDs(ids ...xid.ID) {
	if m.messages == nil {
		m.messages = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the RobotSessionMessage entity.
func (m *RobotMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the RobotSessionMessage entity was cleared.
func (m *RobotMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the RobotSessionMessage entity by IDs.
func (m *RobotMutation) RemoveMessageIDs(ids ...xid.ID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the RobotSessionMessage entity.
func (m *RobotMutation) RemovedMessagesIDs() (ids []xid.ID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *RobotMutation) MessagesIDs() (ids []xid.ID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *RobotMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// Where appends a list predicates to the RobotMutation builder.
func (m *RobotMutation) Where(ps ...predicate.Robot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RobotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RobotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Robot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RobotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RobotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Robot).
func (m *RobotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RobotMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, robot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, robot.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, robot.FieldName)
	}
	if m.description != nil {
		fields = append(fields, robot.FieldDescription)
	}
	if m.playbook != nil {
		fields = append(fields, robot.FieldPlaybook)
	}
	if m.tools != nil {
		fields = append(fields, robot.FieldTools)
	}
	if m.metadata != nil {
		fields = append(fields, robot.FieldMetadata)
	}
	if m.author != nil {
		fields = append(fields, robot.FieldAuthorID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RobotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case robot.FieldCreatedAt:
		return m.CreatedAt()
	case robot.FieldUpdatedAt:
		return m.UpdatedAt()
	case robot.FieldName:
		return m.Name()
	case robot.FieldDescription:
		return m.Description()
	case robot.FieldPlaybook:
		return m.Playbook()
	case robot.FieldTools:
		return m.Tools()
	case robot.FieldMetadata:
		return m.Metadata()
	case robot.FieldAuthorID:
		return m.AuthorID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RobotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case robot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case robot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case robot.FieldName:
		return m.OldName(ctx)
	case robot.FieldDescription:
		return m.OldDescription(ctx)
	case robot.FieldPlaybook:
		return m.OldPlaybook(ctx)
	case robot.FieldTools:
		return m.OldTools(ctx)
	case robot.FieldMetadata:
		return m.OldMetadata(ctx)
	case robot.FieldAuthorID:
		return m.OldAuthorID(ctx)
	}
	return nil, fmt.Errorf("unknown Robot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RobotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case robot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case robot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case robot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case robot.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case robot.FieldPlaybook:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaybook(v)
		return nil
	case robot.FieldTools:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTools(v)
		return nil
	case robot.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case robot.FieldAuthorID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	}
	return fmt.Errorf("unknown Robot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RobotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RobotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RobotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Robot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RobotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(robot.FieldDescription) {
		fields = append(fields, robot.FieldDescription)
	}
	if m.FieldCleared(robot.FieldTools) {
		fields = append(fields, robot.FieldTools)
	}
	if m.FieldCleared(robot.FieldMetadata) {
		fields = append(fields, robot.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RobotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RobotMutation) ClearField(name string) error {
	switch name {
	case robot.FieldDescription:
		m.ClearDescription()
		return nil
	case robot.FieldTools:
		m.ClearTools()
		return nil
	case robot.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Robot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RobotMutation) ResetField(name string) error {
	switch name {
	case robot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case robot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case robot.FieldName:
		m.ResetName()
		return nil
	case robot.FieldDescription:
		m.ResetDescription()
		return nil
	case robot.FieldPlaybook:
		m.ResetPlaybook()
		return nil
	case robot.FieldTools:
		m.ResetTools()
		return nil
	case robot.FieldMetadata:
		m.ResetMetadata()
		return nil
	case robot.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	}
	return fmt.Errorf("unknown Robot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RobotMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.author != nil {
		edges = append(edges, robot.EdgeAuthor)
	}
	if m.messages != nil {
		edges = append(edges, robot.EdgeMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RobotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case robot.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case robot.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RobotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessages != nil {
		edges = append(edges, robot.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RobotMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case robot.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RobotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedauthor {
		edges = append(edges, robot.EdgeAuthor)
	}
	if m.clearedmessages {
		edges = append(edges, robot.EdgeMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RobotMutation) EdgeCleared(name string) bool {
	switch name {
	case robot.EdgeAuthor:
		return m.clearedauthor
	case robot.EdgeMessages:
		return m.clearedmessages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RobotMutation) ClearEdge(name string) error {
	switch name {
	case robot.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Robot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RobotMutation) ResetEdge(name string) error {
	switch name {
	case robot.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case robot.EdgeMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown Robot edge %s", name)
}

// RobotSessionMutation represents an operation that mutates the RobotSession nodes in the graph.
type RobotSessionMutation struct {
	config
	op              Op
	typ             string
	id              *xid.ID
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	state           *map[string]interface{}
	clearedFields   map[string]struct{}
	user            *xid.ID
	cleareduser     bool
	messages        map[xid.ID]struct{}
	removedmessages map[xid.ID]struct{}
	clearedmessages bool
	done            bool
	oldValue        func(context.Context) (*RobotSession, error)
	predicates      []predicate.RobotSession
}

var _ ent.Mutation = (*RobotSessionMutation)(nil)

// robotsessionOption allows management of the mutation configuration using functional options.
type robotsessionOption func(*RobotSessionMutation)

// newRobotSessionMutation creates new mutation for the RobotSession entity.
func newRobotSessionMutation(c config, op Op, opts ...robotsessionOption) *RobotSessionMutation {
	m := &RobotSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeRobotSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRobotSessionID sets the ID field of the mutation.
func withRobotSessionID(id xid.ID) robotsessionOption {
	return func(m *RobotSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *RobotSession
		)
		m.oldValue = func(ctx context.Context) (*RobotSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RobotSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRobotSession sets the old RobotSession of the mutation.
func withRobotSession(node *RobotSession) robotsessionOption {
	return func(m *RobotSessionMutation) {
		m.oldValue = func(context.Context) (*RobotSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RobotSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RobotSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RobotSession entities.
func (m *RobotSessionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RobotSessionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RobotSessionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RobotSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RobotSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RobotSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RobotSession entity.
// If the RobotSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RobotSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RobotSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RobotSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RobotSession entity.
// If the RobotSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RobotSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RobotSessionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RobotSessionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RobotSession entity.
// If the RobotSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotSessionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RobotSessionMutation) ResetName() {
	m.name = nil
}

// SetAccountID sets the "account_id" field.
func (m *RobotSessionMutation) SetAccountID(x xid.ID) {
	m.user = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *RobotSessionMutation) AccountID() (r xid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the RobotSession entity.
// If the RobotSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotSessionMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *RobotSessionMutation) ResetAccountID() {
	m.user = nil
}

// SetState sets the "state" field.
func (m *RobotSessionMutation) SetState(value map[string]interface{}) {
	m.state = &value
}

// State returns the value of the "state" field in the mutation.
func (m *RobotSessionMutation) State() (r map[string]interface{}, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the RobotSession entity.
// If the RobotSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotSessionMutation) OldState(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *RobotSessionMutation) ClearState() {
	m.state = nil
	m.clearedFields[robotsession.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *RobotSessionMutation) StateCleared() bool {
	_, ok := m.clearedFields[robotsession.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *RobotSessionMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, robotsession.FieldState)
}

// SetUserID sets the "user" edge to the Account entity by id.
func (m *RobotSessionMutation) SetUserID(id xid.ID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the Account entity.
func (m *RobotSessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[robotsession.FieldAccountID] = struct{}{}
}

// UserCleared reports if the "user" edge to the Account entity was cleared.
func (m *RobotSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *RobotSessionMutation) UserID() (id xid.ID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RobotSessionMutation) UserIDs() (ids []xid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RobotSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMessageIDs adds the "messages" edge to the RobotSessionMessage entity by ids.
func (m *RobotSessionMutation) AddMessageIDs(ids ...xid.ID) {
	if m.messages == nil {
		m.messages = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the RobotSessionMessage entity.
func (m *RobotSessionMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the RobotSessionMessage entity was cleared.
func (m *RobotSessionMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the RobotSessionMessage entity by IDs.
func (m *RobotSessionMutation) RemoveMessageIDs(ids ...xid.ID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the RobotSessionMessage entity.
func (m *RobotSessionMutation) RemovedMessagesIDs() (ids []xid.ID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *RobotSessionMutation) MessagesIDs() (ids []xid.ID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *RobotSessionMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// Where appends a list predicates to the RobotSessionMutation builder.
func (m *RobotSessionMutation) Where(ps ...predicate.RobotSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RobotSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RobotSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RobotSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RobotSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RobotSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RobotSession).
func (m *RobotSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RobotSessionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, robotsession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, robotsession.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, robotsession.FieldName)
	}
	if m.user != nil {
		fields = append(fields, robotsession.FieldAccountID)
	}
	if m.state != nil {
		fields = append(fields, robotsession.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RobotSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case robotsession.FieldCreatedAt:
		return m.CreatedAt()
	case robotsession.FieldUpdatedAt:
		return m.UpdatedAt()
	case robotsession.FieldName:
		return m.Name()
	case robotsession.FieldAccountID:
		return m.AccountID()
	case robotsession.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RobotSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case robotsession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case robotsession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case robotsession.FieldName:
		return m.OldName(ctx)
	case robotsession.FieldAccountID:
		return m.OldAccountID(ctx)
	case robotsession.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown RobotSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RobotSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case robotsession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case robotsession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case robotsession.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case robotsession.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case robotsession.FieldState:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown RobotSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RobotSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RobotSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RobotSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RobotSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RobotSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(robotsession.FieldState) {
		fields = append(fields, robotsession.FieldState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RobotSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RobotSessionMutation) ClearField(name string) error {
	switch name {
	case robotsession.FieldState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown RobotSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RobotSessionMutation) ResetField(name string) error {
	switch name {
	case robotsession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case robotsession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case robotsession.FieldName:
		m.ResetName()
		return nil
	case robotsession.FieldAccountID:
		m.ResetAccountID()
		return nil
	case robotsession.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown RobotSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RobotSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, robotsession.EdgeUser)
	}
	if m.messages != nil {
		edges = append(edges, robotsession.EdgeMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RobotSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case robotsession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case robotsession.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RobotSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessages != nil {
		edges = append(edges, robotsession.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RobotSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case robotsession.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RobotSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, robotsession.EdgeUser)
	}
	if m.clearedmessages {
		edges = append(edges, robotsession.EdgeMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RobotSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case robotsession.EdgeUser:
		return m.cleareduser
	case robotsession.EdgeMessages:
		return m.clearedmessages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RobotSessionMutation) ClearEdge(name string) error {
	switch name {
	case robotsession.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown RobotSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RobotSessionMutation) ResetEdge(name string) error {
	switch name {
	case robotsession.EdgeUser:
		m.ResetUser()
		return nil
	case robotsession.EdgeMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown RobotSession edge %s", name)
}

// RobotSessionMessageMutation represents an operation that mutates the RobotSessionMessage nodes in the graph.
type RobotSessionMessageMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	invocation_id  *string
	event_data     *map[string]interface{}
	clearedFields  map[string]struct{}
	session        *xid.ID
	clearedsession bool
	robot          *xid.ID
	clearedrobot   bool
	author         *xid.ID
	clearedauthor  bool
	done           bool
	oldValue       func(context.Context) (*RobotSessionMessage, error)
	predicates     []predicate.RobotSessionMessage
}

var _ ent.Mutation = (*RobotSessionMessageMutation)(nil)

// robotsessionmessageOption allows management of the mutation configuration using functional options.
type robotsessionmessageOption func(*RobotSessionMessageMutation)

// newRobotSessionMessageMutation creates new mutation for the RobotSessionMessage entity.
func newRobotSessionMessageMutation(c config, op Op, opts ...robotsessionmessageOption) *RobotSessionMessageMutation {
	m := &RobotSessionMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeRobotSessionMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRobotSessionMessageID sets the ID field of the mutation.
func withRobotSessionMessageID(id xid.ID) robotsessionmessageOption {
	return func(m *RobotSessionMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *RobotSessionMessage
		)
		m.oldValue = func(ctx context.Context) (*RobotSessionMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RobotSessionMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRobotSessionMessage sets the old RobotSessionMessage of the mutation.
func withRobotSessionMessage(node *RobotSessionMessage) robotsessionmessageOption {
	return func(m *RobotSessionMessageMutation) {
		m.oldValue = func(context.Context) (*RobotSessionMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RobotSessionMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RobotSessionMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RobotSessionMessage entities.
func (m *RobotSessionMessageMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RobotSessionMessageMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RobotSessionMessageMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RobotSessionMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RobotSessionMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RobotSessionMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RobotSessionMessage entity.
// If the RobotSessionMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotSessionMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RobotSessionMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetSessionID sets the "session_id" field.
func (m *RobotSessionMessageMutation) SetSessionID(x xid.ID) {
	m.session = &x
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *RobotSessionMessageMutation) SessionID() (r xid.ID, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the RobotSessionMessage entity.
// If the RobotSessionMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotSessionMessageMutation) OldSessionID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *RobotSessionMessageMutation) ResetSessionID() {
	m.session = nil
}

// SetInvocationID sets the "invocation_id" field.
func (m *RobotSessionMessageMutation) SetInvocationID(s string) {
	m.invocation_id = &s
}

// InvocationID returns the value of the "invocation_id" field in the mutation.
func (m *RobotSessionMessageMutation) InvocationID() (r string, exists bool) {
	v := m.invocation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvocationID returns the old "invocation_id" field's value of the RobotSessionMessage entity.
// If the RobotSessionMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotSessionMessageMutation) OldInvocationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvocationID: %w", err)
	}
	return oldValue.InvocationID, nil
}

// ResetInvocationID resets all changes to the "invocation_id" field.
func (m *RobotSessionMessageMutation) ResetInvocationID() {
	m.invocation_id = nil
}

// SetRobotID sets the "robot_id" field.
func (m *RobotSessionMessageMutation) SetRobotID(x xid.ID) {
	m.robot = &x
}

// RobotID returns the value of the "robot_id" field in the mutation.
func (m *RobotSessionMessageMutation) RobotID() (r xid.ID, exists bool) {
	v := m.robot
	if v == nil {
		return
	}
	return *v, true
}

// OldRobotID returns the old "robot_id" field's value of the RobotSessionMessage entity.
// If the RobotSessionMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotSessionMessageMutation) OldRobotID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRobotID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRobotID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRobotID: %w", err)
	}
	return oldValue.RobotID, nil
}

// ClearRobotID clears the value of the "robot_id" field.
func (m *RobotSessionMessageMutation) ClearRobotID() {
	m.robot = nil
	m.clearedFields[robotsessionmessage.FieldRobotID] = struct{}{}
}

// RobotIDCleared returns if the "robot_id" field was cleared in this mutation.
func (m *RobotSessionMessageMutation) RobotIDCleared() bool {
	_, ok := m.clearedFields[robotsessionmessage.FieldRobotID]
	return ok
}

// ResetRobotID resets all changes to the "robot_id" field.
func (m *RobotSessionMessageMutation) ResetRobotID() {
	m.robot = nil
	delete(m.clearedFields, robotsessionmessage.FieldRobotID)
}

// SetAccountID sets the "account_id" field.
func (m *RobotSessionMessageMutation) SetAccountID(x xid.ID) {
	m.author = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *RobotSessionMessageMutation) AccountID() (r xid.ID, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the RobotSessionMessage entity.
// If the RobotSessionMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotSessionMessageMutation) OldAccountID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *RobotSessionMessageMutation) ClearAccountID() {
	m.author = nil
	m.clearedFields[robotsessionmessage.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *RobotSessionMessageMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[robotsessionmessage.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *RobotSessionMessageMutation) ResetAccountID() {
	m.author = nil
	delete(m.clearedFields, robotsessionmessage.FieldAccountID)
}

// SetEventData sets the "event_data" field.
func (m *RobotSessionMessageMutation) SetEventData(value map[string]interface{}) {
	m.event_data = &value
}

// EventData returns the value of the "event_data" field in the mutation.
func (m *RobotSessionMessageMutation) EventData() (r map[string]interface{}, exists bool) {
	v := m.event_data
	if v == nil {
		return
	}
	return *v, true
}

// OldEventData returns the old "event_data" field's value of the RobotSessionMessage entity.
// If the RobotSessionMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RobotSessionMessageMutation) OldEventData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventData: %w", err)
	}
	return oldValue.EventData, nil
}

// ResetEventData resets all changes to the "event_data" field.
func (m *RobotSessionMessageMutation) ResetEventData() {
	m.event_data = nil
}

// ClearSession clears the "session" edge to the RobotSession entity.
func (m *RobotSessionMessageMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[robotsessionmessage.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the RobotSession entity was cleared.
func (m *RobotSessionMessageMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *RobotSessionMessageMutation) SessionIDs() (ids []xid.ID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *RobotSessionMessageMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// ClearRobot clears the "robot" edge to the Robot entity.
func (m *RobotSessionMessageMutation) ClearRobot() {
	m.clearedrobot = true
	m.clearedFields[robotsessionmessage.FieldRobotID] = struct{}{}
}

// RobotCleared reports if the "robot" edge to the Robot entity was cleared.
func (m *RobotSessionMessageMutation) RobotCleared() bool {
	return m.RobotIDCleared() || m.clearedrobot
}

// RobotIDs returns the "robot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RobotID instead. It exists only for internal usage by the builders.
func (m *RobotSessionMessageMutation) RobotIDs() (ids []xid.ID) {
	if id := m.robot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRobot resets all changes to the "robot" edge.
func (m *RobotSessionMessageMutation) ResetRobot() {
	m.robot = nil
	m.clearedrobot = false
}

// SetAuthorID sets the "author" edge to the Account entity by id.
func (m *RobotSessionMessageMutation) SetAuthorID(id xid.ID) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the Account entity.
func (m *RobotSessionMessageMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[robotsessionmessage.FieldAccountID] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the Account entity was cleared.
func (m *RobotSessionMessageMutation) AuthorCleared() bool {
	return m.AccountIDCleared() || m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *RobotSessionMessageMutation) AuthorID() (id xid.ID, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *RobotSessionMessageMutation) AuthorIDs() (ids []xid.ID) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *RobotSessionMessageMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// Where appends a list predicates to the RobotSessionMessageMutation builder.
func (m *RobotSessionMessageMutation) Where(ps ...predicate.RobotSessionMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RobotSessionMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RobotSessionMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RobotSessionMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RobotSessionMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RobotSessionMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RobotSessionMessage).
func (m *RobotSessionMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RobotSessionMessageMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, robotsessionmessage.FieldCreatedAt)
	}
	if m.session != nil {
		fields = append(fields, robotsessionmessage.FieldSessionID)
	}
	if m.invocation_id != nil {
		fields = append(fields, robotsessionmessage.FieldInvocationID)
	}
	if m.robot != nil {
		fields = append(fields, robotsessionmessage.FieldRobotID)
	}
	if m.author != nil {
		fields = append(fields, robotsessionmessage.FieldAccountID)
	}
	if m.event_data != nil {
		fields = append(fields, robotsessionmessage.FieldEventData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RobotSessionMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case robotsessionmessage.FieldCreatedAt:
		return m.CreatedAt()
	case robotsessionmessage.FieldSessionID:
		return m.SessionID()
	case robotsessionmessage.FieldInvocationID:
		return m.InvocationID()
	case robotsessionmessage.FieldRobotID:
		return m.RobotID()
	case robotsessionmessage.FieldAccountID:
		return m.AccountID()
	case robotsessionmessage.FieldEventData:
		return m.EventData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RobotSessionMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case robotsessionmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case robotsessionmessage.FieldSessionID:
		return m.OldSessionID(ctx)
	case robotsessionmessage.FieldInvocationID:
		return m.OldInvocationID(ctx)
	case robotsessionmessage.FieldRobotID:
		return m.OldRobotID(ctx)
	case robotsessionmessage.FieldAccountID:
		return m.OldAccountID(ctx)
	case robotsessionmessage.FieldEventData:
		return m.OldEventData(ctx)
	}
	return nil, fmt.Errorf("unknown RobotSessionMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RobotSessionMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case robotsessionmessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case robotsessionmessage.FieldSessionID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case robotsessionmessage.FieldInvocationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvocationID(v)
		return nil
	case robotsessionmessage.FieldRobotID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRobotID(v)
		return nil
	case robotsessionmessage.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case robotsessionmessage.FieldEventData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventData(v)
		return nil
	}
	return fmt.Errorf("unknown RobotSessionMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RobotSessionMessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RobotSessionMessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RobotSessionMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RobotSessionMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RobotSessionMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(robotsessionmessage.FieldRobotID) {
		fields = append(fields, robotsessionmessage.FieldRobotID)
	}
	if m.FieldCleared(robotsessionmessage.FieldAccountID) {
		fields = append(fields, robotsessionmessage.FieldAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RobotSessionMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RobotSessionMessageMutation) ClearField(name string) error {
	switch name {
	case robotsessionmessage.FieldRobotID:
		m.ClearRobotID()
		return nil
	case robotsessionmessage.FieldAccountID:
		m.ClearAccountID()
		return nil
	}
	return fmt.Errorf("unknown RobotSessionMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RobotSessionMessageMutation) ResetField(name string) error {
	switch name {
	case robotsessionmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case robotsessionmessage.FieldSessionID:
		m.ResetSessionID()
		return nil
	case robotsessionmessage.FieldInvocationID:
		m.ResetInvocationID()
		return nil
	case robotsessionmessage.FieldRobotID:
		m.ResetRobotID()
		return nil
	case robotsessionmessage.FieldAccountID:
		m.ResetAccountID()
		return nil
	case robotsessionmessage.FieldEventData:
		m.ResetEventData()
		return nil
	}
	return fmt.Errorf("unknown RobotSessionMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RobotSessionMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.session != nil {
		edges = append(edges, robotsessionmessage.EdgeSession)
	}
	if m.robot != nil {
		edges = append(edges, robotsessionmessage.EdgeRobot)
	}
	if m.author != nil {
		edges = append(edges, robotsessionmessage.EdgeAuthor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RobotSessionMessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case robotsessionmessage.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case robotsessionmessage.EdgeRobot:
		if id := m.robot; id != nil {
			return []ent.Value{*id}
		}
	case robotsessionmessage.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RobotSessionMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RobotSessionMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RobotSessionMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsession {
		edges = append(edges, robotsessionmessage.EdgeSession)
	}
	if m.clearedrobot {
		edges = append(edges, robotsessionmessage.EdgeRobot)
	}
	if m.clearedauthor {
		edges = append(edges, robotsessionmessage.EdgeAuthor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RobotSessionMessageMutation) EdgeCleared(name string) bool {
	switch name {
	case robotsessionmessage.EdgeSession:
		return m.clearedsession
	case robotsessionmessage.EdgeRobot:
		return m.clearedrobot
	case robotsessionmessage.EdgeAuthor:
		return m.clearedauthor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RobotSessionMessageMutation) ClearEdge(name string) error {
	switch name {
	case robotsessionmessage.EdgeSession:
		m.ClearSession()
		return nil
	case robotsessionmessage.EdgeRobot:
		m.ClearRobot()
		return nil
	case robotsessionmessage.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown RobotSessionMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RobotSessionMessageMutation) ResetEdge(name string) error {
	switch name {
	case robotsessionmessage.EdgeSession:
		m.ResetSession()
		return nil
	case robotsessionmessage.EdgeRobot:
		m.ResetRobot()
		return nil
	case robotsessionmessage.EdgeAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown RobotSessionMessage edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *xid.ID
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	colour               *string
	permissions          *[]string
	appendpermissions    []string
	sort_key             *float64
	addsort_key          *float64
	clearedFields        map[string]struct{}
	accounts             map[xid.ID]struct{}
	removedaccounts      map[xid.ID]struct{}
	clearedaccounts      bool
	account_roles        map[xid.ID]struct{}
	removedaccount_roles map[xid.ID]struct{}
	clearedaccount_roles bool
	done                 bool
	oldValue             func(context.Context) (*Role, error)
	predicates           []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id xid.ID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetColour sets the "colour" field.
func (m *RoleMutation) SetColour(s string) {
	m.colour = &s
}

// Colour returns the value of the "colour" field in the mutation.
func (m *RoleMutation) Colour() (r string, exists bool) {
	v := m.colour
	if v == nil {
		return
	}
	return *v, true
}

// OldColour returns the old "colour" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldColour(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColour: %w", err)
	}
	return oldValue.Colour, nil
}

// ResetColour resets all changes to the "colour" field.
func (m *RoleMutation) ResetColour() {
	m.colour = nil
}

// SetPermissions sets the "permissions" field.
func (m *RoleMutation) SetPermissions(s []string) {
	m.permissions = &s
	m.appendpermissions = nil
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *RoleMutation) Permissions() (r []string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldPermissions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// AppendPermissions adds s to the "permissions" field.
func (m *RoleMutation) AppendPermissions(s []string) {
	m.appendpermissions = append(m.appendpermissions, s...)
}

// AppendedPermissions returns the list of values that were appended to the "permissions" field in this mutation.
func (m *RoleMutation) AppendedPermissions() ([]string, bool) {
	if len(m.appendpermissions) == 0 {
		return nil, false
	}
	return m.appendpermissions, true
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
}

// SetSortKey sets the "sort_key" field.
func (m *RoleMutation) SetSortKey(f float64) {
	m.sort_key = &f
	m.addsort_key = nil
}

// SortKey returns the value of the "sort_key" field in the mutation.
func (m *RoleMutation) SortKey() (r float64, exists bool) {
	v := m.sort_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSortKey returns the old "sort_key" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldSortKey(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortKey: %w", err)
	}
	return oldValue.SortKey, nil
}

// AddSortKey adds f to the "sort_key" field.
func (m *RoleMutation) AddSortKey(f float64) {
	if m.addsort_key != nil {
		*m.addsort_key += f
	} else {
		m.addsort_key = &f
	}
}

// AddedSortKey returns the value that was added to the "sort_key" field in this mutation.
func (m *RoleMutation) AddedSortKey() (r float64, exists bool) {
	v := m.addsort_key
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortKey resets all changes to the "sort_key" field.
func (m *RoleMutation) ResetSortKey() {
	m.sort_key = nil
	m.addsort_key = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *RoleMutation) AddAccountIDs(ids ...xid.ID) {
	if m.accounts == nil {
		m.accounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *RoleMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *RoleMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *RoleMutation) RemoveAccountIDs(ids ...xid.ID) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *RoleMutation) RemovedAccountsIDs() (ids []xid.ID) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *RoleMutation) AccountsIDs() (ids []xid.ID) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *RoleMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddAccountRoleIDs adds the "account_roles" edge to the AccountRoles entity by ids.
func (m *RoleMutation) AddAccountRoleIDs(ids ...xid.ID) {
	if m.account_roles == nil {
		m.account_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.account_roles[ids[i]] = struct{}{}
	}
}

// ClearAccountRoles clears the "account_roles" edge to the AccountRoles entity.
func (m *RoleMutation) ClearAccountRoles() {
	m.clearedaccount_roles = true
}

// AccountRolesCleared reports if the "account_roles" edge to the AccountRoles entity was cleared.
func (m *RoleMutation) AccountRolesCleared() bool {
	return m.clearedaccount_roles
}

// RemoveAccountRoleIDs removes the "account_roles" edge to the AccountRoles entity by IDs.
func (m *RoleMutation) RemoveAccountRoleIDs(ids ...xid.ID) {
	if m.removedaccount_roles == nil {
		m.removedaccount_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.account_roles, ids[i])
		m.removedaccount_roles[ids[i]] = struct{}{}
	}
}

// RemovedAccountRoles returns the removed IDs of the "account_roles" edge to the AccountRoles entity.
func (m *RoleMutation) RemovedAccountRolesIDs() (ids []xid.ID) {
	for id := range m.removedaccount_roles {
		ids = append(ids, id)
	}
	return
}

// AccountRolesIDs returns the "account_roles" edge IDs in the mutation.
func (m *RoleMutation) AccountRolesIDs() (ids []xid.ID) {
	for id := range m.account_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAccountRoles resets all changes to the "account_roles" edge.
func (m *RoleMutation) ResetAccountRoles() {
	m.account_roles = nil
	m.clearedaccount_roles = false
	m.removedaccount_roles = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.colour != nil {
		fields = append(fields, role.FieldColour)
	}
	if m.permissions != nil {
		fields = append(fields, role.FieldPermissions)
	}
	if m.sort_key != nil {
		fields = append(fields, role.FieldSortKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldColour:
		return m.Colour()
	case role.FieldPermissions:
		return m.Permissions()
	case role.FieldSortKey:
		return m.SortKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldColour:
		return m.OldColour(ctx)
	case role.FieldPermissions:
		return m.OldPermissions(ctx)
	case role.FieldSortKey:
		return m.OldSortKey(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldColour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColour(v)
		return nil
	case role.FieldPermissions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case role.FieldSortKey:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortKey(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addsort_key != nil {
		fields = append(fields, role.FieldSortKey)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldSortKey:
		return m.AddedSortKey()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldSortKey:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortKey(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldColour:
		m.ResetColour()
		return nil
	case role.FieldPermissions:
		m.ResetPermissions()
		return nil
	case role.FieldSortKey:
		m.ResetSortKey()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.accounts != nil {
		edges = append(edges, role.EdgeAccounts)
	}
	if m.account_roles != nil {
		edges = append(edges, role.EdgeAccountRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAccountRoles:
		ids := make([]ent.Value, 0, len(m.account_roles))
		for id := range m.account_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaccounts != nil {
		edges = append(edges, role.EdgeAccounts)
	}
	if m.removedaccount_roles != nil {
		edges = append(edges, role.EdgeAccountRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAccountRoles:
		ids := make([]ent.Value, 0, len(m.removedaccount_roles))
		for id := range m.removedaccount_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccounts {
		edges = append(edges, role.EdgeAccounts)
	}
	if m.clearedaccount_roles {
		edges = append(edges, role.EdgeAccountRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeAccounts:
		return m.clearedaccounts
	case role.EdgeAccountRoles:
		return m.clearedaccount_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case role.EdgeAccountRoles:
		m.ResetAccountRoles()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	expires_at     *time.Time
	revoked_at     *time.Time
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	done           bool
	oldValue       func(context.Context) (*Session, error)
	predicates     []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id xid.ID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountID sets the "account_id" field.
func (m *SessionMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *SessionMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *SessionMutation) ResetAccountID() {
	m.account = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *SessionMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *SessionMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *SessionMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[session.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *SessionMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *SessionMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, session.FieldRevokedAt)
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *SessionMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[session.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *SessionMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *SessionMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.account != nil {
		fields = append(fields, session.FieldAccountID)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, session.FieldRevokedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldAccountID:
		return m.AccountID()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldRevokedAt:
		return m.RevokedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldAccountID:
		return m.OldAccountID(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldRevokedAt) {
		fields = append(fields, session.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldAccountID:
		m.ResetAccountID()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.account != nil {
		edges = append(edges, session.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccount {
		edges = append(edges, session.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	value         *string
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id string) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldValue:
		return m.Value()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op              Op
	typ             string
	id              *xid.ID
	created_at      *time.Time
	name            *string
	clearedFields   map[string]struct{}
	posts           map[xid.ID]struct{}
	removedposts    map[xid.ID]struct{}
	clearedposts    bool
	nodes           map[xid.ID]struct{}
	removednodes    map[xid.ID]struct{}
	clearednodes    bool
	accounts        map[xid.ID]struct{}
	removedaccounts map[xid.ID]struct{}
	clearedaccounts bool
	done            bool
	oldValue        func(context.Context) (*Tag, error)
	predicates      []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id xid.ID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *TagMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *TagMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *TagMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *TagMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *TagMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *TagMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *TagMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *TagMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *TagMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *TagMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *TagMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *TagMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *TagMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *TagMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *TagMutation) AddAccountIDs(ids ...xid.ID) {
	if m.accounts == nil {
		m.accounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *TagMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *TagMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *TagMutation) RemoveAccountIDs(ids ...xid.ID) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *TagMutation) RemovedAccountsIDs() (ids []xid.ID) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *TagMutation) AccountsIDs() (ids []xid.ID) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *TagMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.posts != nil {
		edges = append(edges, tag.EdgePosts)
	}
	if m.nodes != nil {
		edges = append(edges, tag.EdgeNodes)
	}
	if m.accounts != nil {
		edges = append(edges, tag.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedposts != nil {
		edges = append(edges, tag.EdgePosts)
	}
	if m.removednodes != nil {
		edges = append(edges, tag.EdgeNodes)
	}
	if m.removedaccounts != nil {
		edges = append(edges, tag.EdgeAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedposts {
		edges = append(edges, tag.EdgePosts)
	}
	if m.clearednodes {
		edges = append(edges, tag.EdgeNodes)
	}
	if m.clearedaccounts {
		edges = append(edges, tag.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgePosts:
		return m.clearedposts
	case tag.EdgeNodes:
		return m.clearednodes
	case tag.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgePosts:
		m.ResetPosts()
		return nil
	case tag.EdgeNodes:
		m.ResetNodes()
		return nil
	case tag.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}
