// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Southclaws/storyden/internal/ent/account"
	"github.com/Southclaws/storyden/internal/ent/accountfollow"
	"github.com/Southclaws/storyden/internal/ent/accountroles"
	"github.com/Southclaws/storyden/internal/ent/asset"
	"github.com/Southclaws/storyden/internal/ent/authentication"
	"github.com/Southclaws/storyden/internal/ent/category"
	"github.com/Southclaws/storyden/internal/ent/collection"
	"github.com/Southclaws/storyden/internal/ent/collectionnode"
	"github.com/Southclaws/storyden/internal/ent/collectionpost"
	"github.com/Southclaws/storyden/internal/ent/email"
	"github.com/Southclaws/storyden/internal/ent/event"
	"github.com/Southclaws/storyden/internal/ent/eventparticipant"
	"github.com/Southclaws/storyden/internal/ent/invitation"
	"github.com/Southclaws/storyden/internal/ent/likepost"
	"github.com/Southclaws/storyden/internal/ent/link"
	"github.com/Southclaws/storyden/internal/ent/mentionprofile"
	"github.com/Southclaws/storyden/internal/ent/node"
	"github.com/Southclaws/storyden/internal/ent/notification"
	"github.com/Southclaws/storyden/internal/ent/post"
	"github.com/Southclaws/storyden/internal/ent/predicate"
	"github.com/Southclaws/storyden/internal/ent/question"
	"github.com/Southclaws/storyden/internal/ent/react"
	"github.com/Southclaws/storyden/internal/ent/role"
	"github.com/Southclaws/storyden/internal/ent/schema"
	"github.com/Southclaws/storyden/internal/ent/setting"
	"github.com/Southclaws/storyden/internal/ent/tag"
	"github.com/Southclaws/storyden/internal/ent/tagnode"
	"github.com/Southclaws/storyden/internal/ent/tagpost"
	"github.com/rs/xid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount          = "Account"
	TypeAccountFollow    = "AccountFollow"
	TypeAccountRoles     = "AccountRoles"
	TypeAsset            = "Asset"
	TypeAuthentication   = "Authentication"
	TypeCategory         = "Category"
	TypeCollection       = "Collection"
	TypeCollectionNode   = "CollectionNode"
	TypeCollectionPost   = "CollectionPost"
	TypeEmail            = "Email"
	TypeEvent            = "Event"
	TypeEventParticipant = "EventParticipant"
	TypeInvitation       = "Invitation"
	TypeLikePost         = "LikePost"
	TypeLink             = "Link"
	TypeMentionProfile   = "MentionProfile"
	TypeNode             = "Node"
	TypeNotification     = "Notification"
	TypePost             = "Post"
	TypeQuestion         = "Question"
	TypeReact            = "React"
	TypeRole             = "Role"
	TypeSetting          = "Setting"
	TypeTag              = "Tag"
	TypeTagNode          = "TagNode"
	TypeTagPost          = "TagPost"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                             Op
	typ                            string
	id                             *xid.ID
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	indexed_at                     *time.Time
	handle                         *string
	name                           *string
	bio                            *string
	admin                          *bool
	links                          *[]schema.ExternalLink
	appendlinks                    []schema.ExternalLink
	metadata                       *map[string]interface{}
	clearedFields                  map[string]struct{}
	emails                         map[xid.ID]struct{}
	removedemails                  map[xid.ID]struct{}
	clearedemails                  bool
	notifications                  map[xid.ID]struct{}
	removednotifications           map[xid.ID]struct{}
	clearednotifications           bool
	triggered_notifications        map[xid.ID]struct{}
	removedtriggered_notifications map[xid.ID]struct{}
	clearedtriggered_notifications bool
	following                      map[xid.ID]struct{}
	removedfollowing               map[xid.ID]struct{}
	clearedfollowing               bool
	followed_by                    map[xid.ID]struct{}
	removedfollowed_by             map[xid.ID]struct{}
	clearedfollowed_by             bool
	invitations                    map[xid.ID]struct{}
	removedinvitations             map[xid.ID]struct{}
	clearedinvitations             bool
	invited_by                     *xid.ID
	clearedinvited_by              bool
	posts                          map[xid.ID]struct{}
	removedposts                   map[xid.ID]struct{}
	clearedposts                   bool
	questions                      map[xid.ID]struct{}
	removedquestions               map[xid.ID]struct{}
	clearedquestions               bool
	reacts                         map[xid.ID]struct{}
	removedreacts                  map[xid.ID]struct{}
	clearedreacts                  bool
	likes                          map[xid.ID]struct{}
	removedlikes                   map[xid.ID]struct{}
	clearedlikes                   bool
	mentions                       map[xid.ID]struct{}
	removedmentions                map[xid.ID]struct{}
	clearedmentions                bool
	roles                          map[xid.ID]struct{}
	removedroles                   map[xid.ID]struct{}
	clearedroles                   bool
	authentication                 map[xid.ID]struct{}
	removedauthentication          map[xid.ID]struct{}
	clearedauthentication          bool
	tags                           map[xid.ID]struct{}
	removedtags                    map[xid.ID]struct{}
	clearedtags                    bool
	collections                    map[xid.ID]struct{}
	removedcollections             map[xid.ID]struct{}
	clearedcollections             bool
	nodes                          map[xid.ID]struct{}
	removednodes                   map[xid.ID]struct{}
	clearednodes                   bool
	assets                         map[xid.ID]struct{}
	removedassets                  map[xid.ID]struct{}
	clearedassets                  bool
	events                         map[xid.ID]struct{}
	removedevents                  map[xid.ID]struct{}
	clearedevents                  bool
	account_roles                  map[xid.ID]struct{}
	removedaccount_roles           map[xid.ID]struct{}
	clearedaccount_roles           bool
	done                           bool
	oldValue                       func(context.Context) (*Account, error)
	predicates                     []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id xid.ID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[account.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, account.FieldDeletedAt)
}

// SetIndexedAt sets the "indexed_at" field.
func (m *AccountMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *AccountMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *AccountMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[account.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *AccountMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *AccountMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, account.FieldIndexedAt)
}

// SetHandle sets the "handle" field.
func (m *AccountMutation) SetHandle(s string) {
	m.handle = &s
}

// Handle returns the value of the "handle" field in the mutation.
func (m *AccountMutation) Handle() (r string, exists bool) {
	v := m.handle
	if v == nil {
		return
	}
	return *v, true
}

// OldHandle returns the old "handle" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldHandle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandle: %w", err)
	}
	return oldValue.Handle, nil
}

// ResetHandle resets all changes to the "handle" field.
func (m *AccountMutation) ResetHandle() {
	m.handle = nil
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetBio sets the "bio" field.
func (m *AccountMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *AccountMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *AccountMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[account.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *AccountMutation) BioCleared() bool {
	_, ok := m.clearedFields[account.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *AccountMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, account.FieldBio)
}

// SetAdmin sets the "admin" field.
func (m *AccountMutation) SetAdmin(b bool) {
	m.admin = &b
}

// Admin returns the value of the "admin" field in the mutation.
func (m *AccountMutation) Admin() (r bool, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "admin" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "admin" field.
func (m *AccountMutation) ResetAdmin() {
	m.admin = nil
}

// SetLinks sets the "links" field.
func (m *AccountMutation) SetLinks(sl []schema.ExternalLink) {
	m.links = &sl
	m.appendlinks = nil
}

// Links returns the value of the "links" field in the mutation.
func (m *AccountMutation) Links() (r []schema.ExternalLink, exists bool) {
	v := m.links
	if v == nil {
		return
	}
	return *v, true
}

// OldLinks returns the old "links" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldLinks(ctx context.Context) (v []schema.ExternalLink, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinks: %w", err)
	}
	return oldValue.Links, nil
}

// AppendLinks adds sl to the "links" field.
func (m *AccountMutation) AppendLinks(sl []schema.ExternalLink) {
	m.appendlinks = append(m.appendlinks, sl...)
}

// AppendedLinks returns the list of values that were appended to the "links" field in this mutation.
func (m *AccountMutation) AppendedLinks() ([]schema.ExternalLink, bool) {
	if len(m.appendlinks) == 0 {
		return nil, false
	}
	return m.appendlinks, true
}

// ClearLinks clears the value of the "links" field.
func (m *AccountMutation) ClearLinks() {
	m.links = nil
	m.appendlinks = nil
	m.clearedFields[account.FieldLinks] = struct{}{}
}

// LinksCleared returns if the "links" field was cleared in this mutation.
func (m *AccountMutation) LinksCleared() bool {
	_, ok := m.clearedFields[account.FieldLinks]
	return ok
}

// ResetLinks resets all changes to the "links" field.
func (m *AccountMutation) ResetLinks() {
	m.links = nil
	m.appendlinks = nil
	delete(m.clearedFields, account.FieldLinks)
}

// SetMetadata sets the "metadata" field.
func (m *AccountMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AccountMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AccountMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[account.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AccountMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[account.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AccountMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, account.FieldMetadata)
}

// SetInvitedByID sets the "invited_by_id" field.
func (m *AccountMutation) SetInvitedByID(x xid.ID) {
	m.invited_by = &x
}

// InvitedByID returns the value of the "invited_by_id" field in the mutation.
func (m *AccountMutation) InvitedByID() (r xid.ID, exists bool) {
	v := m.invited_by
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitedByID returns the old "invited_by_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldInvitedByID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitedByID: %w", err)
	}
	return oldValue.InvitedByID, nil
}

// ClearInvitedByID clears the value of the "invited_by_id" field.
func (m *AccountMutation) ClearInvitedByID() {
	m.invited_by = nil
	m.clearedFields[account.FieldInvitedByID] = struct{}{}
}

// InvitedByIDCleared returns if the "invited_by_id" field was cleared in this mutation.
func (m *AccountMutation) InvitedByIDCleared() bool {
	_, ok := m.clearedFields[account.FieldInvitedByID]
	return ok
}

// ResetInvitedByID resets all changes to the "invited_by_id" field.
func (m *AccountMutation) ResetInvitedByID() {
	m.invited_by = nil
	delete(m.clearedFields, account.FieldInvitedByID)
}

// AddEmailIDs adds the "emails" edge to the Email entity by ids.
func (m *AccountMutation) AddEmailIDs(ids ...xid.ID) {
	if m.emails == nil {
		m.emails = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.emails[ids[i]] = struct{}{}
	}
}

// ClearEmails clears the "emails" edge to the Email entity.
func (m *AccountMutation) ClearEmails() {
	m.clearedemails = true
}

// EmailsCleared reports if the "emails" edge to the Email entity was cleared.
func (m *AccountMutation) EmailsCleared() bool {
	return m.clearedemails
}

// RemoveEmailIDs removes the "emails" edge to the Email entity by IDs.
func (m *AccountMutation) RemoveEmailIDs(ids ...xid.ID) {
	if m.removedemails == nil {
		m.removedemails = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.emails, ids[i])
		m.removedemails[ids[i]] = struct{}{}
	}
}

// RemovedEmails returns the removed IDs of the "emails" edge to the Email entity.
func (m *AccountMutation) RemovedEmailsIDs() (ids []xid.ID) {
	for id := range m.removedemails {
		ids = append(ids, id)
	}
	return
}

// EmailsIDs returns the "emails" edge IDs in the mutation.
func (m *AccountMutation) EmailsIDs() (ids []xid.ID) {
	for id := range m.emails {
		ids = append(ids, id)
	}
	return
}

// ResetEmails resets all changes to the "emails" edge.
func (m *AccountMutation) ResetEmails() {
	m.emails = nil
	m.clearedemails = false
	m.removedemails = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *AccountMutation) AddNotificationIDs(ids ...xid.ID) {
	if m.notifications == nil {
		m.notifications = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *AccountMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *AccountMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *AccountMutation) RemoveNotificationIDs(ids ...xid.ID) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *AccountMutation) RemovedNotificationsIDs() (ids []xid.ID) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *AccountMutation) NotificationsIDs() (ids []xid.ID) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *AccountMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddTriggeredNotificationIDs adds the "triggered_notifications" edge to the Notification entity by ids.
func (m *AccountMutation) AddTriggeredNotificationIDs(ids ...xid.ID) {
	if m.triggered_notifications == nil {
		m.triggered_notifications = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.triggered_notifications[ids[i]] = struct{}{}
	}
}

// ClearTriggeredNotifications clears the "triggered_notifications" edge to the Notification entity.
func (m *AccountMutation) ClearTriggeredNotifications() {
	m.clearedtriggered_notifications = true
}

// TriggeredNotificationsCleared reports if the "triggered_notifications" edge to the Notification entity was cleared.
func (m *AccountMutation) TriggeredNotificationsCleared() bool {
	return m.clearedtriggered_notifications
}

// RemoveTriggeredNotificationIDs removes the "triggered_notifications" edge to the Notification entity by IDs.
func (m *AccountMutation) RemoveTriggeredNotificationIDs(ids ...xid.ID) {
	if m.removedtriggered_notifications == nil {
		m.removedtriggered_notifications = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.triggered_notifications, ids[i])
		m.removedtriggered_notifications[ids[i]] = struct{}{}
	}
}

// RemovedTriggeredNotifications returns the removed IDs of the "triggered_notifications" edge to the Notification entity.
func (m *AccountMutation) RemovedTriggeredNotificationsIDs() (ids []xid.ID) {
	for id := range m.removedtriggered_notifications {
		ids = append(ids, id)
	}
	return
}

// TriggeredNotificationsIDs returns the "triggered_notifications" edge IDs in the mutation.
func (m *AccountMutation) TriggeredNotificationsIDs() (ids []xid.ID) {
	for id := range m.triggered_notifications {
		ids = append(ids, id)
	}
	return
}

// ResetTriggeredNotifications resets all changes to the "triggered_notifications" edge.
func (m *AccountMutation) ResetTriggeredNotifications() {
	m.triggered_notifications = nil
	m.clearedtriggered_notifications = false
	m.removedtriggered_notifications = nil
}

// AddFollowingIDs adds the "following" edge to the AccountFollow entity by ids.
func (m *AccountMutation) AddFollowingIDs(ids ...xid.ID) {
	if m.following == nil {
		m.following = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.following[ids[i]] = struct{}{}
	}
}

// ClearFollowing clears the "following" edge to the AccountFollow entity.
func (m *AccountMutation) ClearFollowing() {
	m.clearedfollowing = true
}

// FollowingCleared reports if the "following" edge to the AccountFollow entity was cleared.
func (m *AccountMutation) FollowingCleared() bool {
	return m.clearedfollowing
}

// RemoveFollowingIDs removes the "following" edge to the AccountFollow entity by IDs.
func (m *AccountMutation) RemoveFollowingIDs(ids ...xid.ID) {
	if m.removedfollowing == nil {
		m.removedfollowing = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.following, ids[i])
		m.removedfollowing[ids[i]] = struct{}{}
	}
}

// RemovedFollowing returns the removed IDs of the "following" edge to the AccountFollow entity.
func (m *AccountMutation) RemovedFollowingIDs() (ids []xid.ID) {
	for id := range m.removedfollowing {
		ids = append(ids, id)
	}
	return
}

// FollowingIDs returns the "following" edge IDs in the mutation.
func (m *AccountMutation) FollowingIDs() (ids []xid.ID) {
	for id := range m.following {
		ids = append(ids, id)
	}
	return
}

// ResetFollowing resets all changes to the "following" edge.
func (m *AccountMutation) ResetFollowing() {
	m.following = nil
	m.clearedfollowing = false
	m.removedfollowing = nil
}

// AddFollowedByIDs adds the "followed_by" edge to the AccountFollow entity by ids.
func (m *AccountMutation) AddFollowedByIDs(ids ...xid.ID) {
	if m.followed_by == nil {
		m.followed_by = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.followed_by[ids[i]] = struct{}{}
	}
}

// ClearFollowedBy clears the "followed_by" edge to the AccountFollow entity.
func (m *AccountMutation) ClearFollowedBy() {
	m.clearedfollowed_by = true
}

// FollowedByCleared reports if the "followed_by" edge to the AccountFollow entity was cleared.
func (m *AccountMutation) FollowedByCleared() bool {
	return m.clearedfollowed_by
}

// RemoveFollowedByIDs removes the "followed_by" edge to the AccountFollow entity by IDs.
func (m *AccountMutation) RemoveFollowedByIDs(ids ...xid.ID) {
	if m.removedfollowed_by == nil {
		m.removedfollowed_by = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.followed_by, ids[i])
		m.removedfollowed_by[ids[i]] = struct{}{}
	}
}

// RemovedFollowedBy returns the removed IDs of the "followed_by" edge to the AccountFollow entity.
func (m *AccountMutation) RemovedFollowedByIDs() (ids []xid.ID) {
	for id := range m.removedfollowed_by {
		ids = append(ids, id)
	}
	return
}

// FollowedByIDs returns the "followed_by" edge IDs in the mutation.
func (m *AccountMutation) FollowedByIDs() (ids []xid.ID) {
	for id := range m.followed_by {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedBy resets all changes to the "followed_by" edge.
func (m *AccountMutation) ResetFollowedBy() {
	m.followed_by = nil
	m.clearedfollowed_by = false
	m.removedfollowed_by = nil
}

// AddInvitationIDs adds the "invitations" edge to the Invitation entity by ids.
func (m *AccountMutation) AddInvitationIDs(ids ...xid.ID) {
	if m.invitations == nil {
		m.invitations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.invitations[ids[i]] = struct{}{}
	}
}

// ClearInvitations clears the "invitations" edge to the Invitation entity.
func (m *AccountMutation) ClearInvitations() {
	m.clearedinvitations = true
}

// InvitationsCleared reports if the "invitations" edge to the Invitation entity was cleared.
func (m *AccountMutation) InvitationsCleared() bool {
	return m.clearedinvitations
}

// RemoveInvitationIDs removes the "invitations" edge to the Invitation entity by IDs.
func (m *AccountMutation) RemoveInvitationIDs(ids ...xid.ID) {
	if m.removedinvitations == nil {
		m.removedinvitations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.invitations, ids[i])
		m.removedinvitations[ids[i]] = struct{}{}
	}
}

// RemovedInvitations returns the removed IDs of the "invitations" edge to the Invitation entity.
func (m *AccountMutation) RemovedInvitationsIDs() (ids []xid.ID) {
	for id := range m.removedinvitations {
		ids = append(ids, id)
	}
	return
}

// InvitationsIDs returns the "invitations" edge IDs in the mutation.
func (m *AccountMutation) InvitationsIDs() (ids []xid.ID) {
	for id := range m.invitations {
		ids = append(ids, id)
	}
	return
}

// ResetInvitations resets all changes to the "invitations" edge.
func (m *AccountMutation) ResetInvitations() {
	m.invitations = nil
	m.clearedinvitations = false
	m.removedinvitations = nil
}

// ClearInvitedBy clears the "invited_by" edge to the Invitation entity.
func (m *AccountMutation) ClearInvitedBy() {
	m.clearedinvited_by = true
	m.clearedFields[account.FieldInvitedByID] = struct{}{}
}

// InvitedByCleared reports if the "invited_by" edge to the Invitation entity was cleared.
func (m *AccountMutation) InvitedByCleared() bool {
	return m.InvitedByIDCleared() || m.clearedinvited_by
}

// InvitedByIDs returns the "invited_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvitedByID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) InvitedByIDs() (ids []xid.ID) {
	if id := m.invited_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitedBy resets all changes to the "invited_by" edge.
func (m *AccountMutation) ResetInvitedBy() {
	m.invited_by = nil
	m.clearedinvited_by = false
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *AccountMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *AccountMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *AccountMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *AccountMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *AccountMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *AccountMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *AccountMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddQuestionIDs adds the "questions" edge to the Question entity by ids.
func (m *AccountMutation) AddQuestionIDs(ids ...xid.ID) {
	if m.questions == nil {
		m.questions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// ClearQuestions clears the "questions" edge to the Question entity.
func (m *AccountMutation) ClearQuestions() {
	m.clearedquestions = true
}

// QuestionsCleared reports if the "questions" edge to the Question entity was cleared.
func (m *AccountMutation) QuestionsCleared() bool {
	return m.clearedquestions
}

// RemoveQuestionIDs removes the "questions" edge to the Question entity by IDs.
func (m *AccountMutation) RemoveQuestionIDs(ids ...xid.ID) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.questions, ids[i])
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed IDs of the "questions" edge to the Question entity.
func (m *AccountMutation) RemovedQuestionsIDs() (ids []xid.ID) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the "questions" edge IDs in the mutation.
func (m *AccountMutation) QuestionsIDs() (ids []xid.ID) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions resets all changes to the "questions" edge.
func (m *AccountMutation) ResetQuestions() {
	m.questions = nil
	m.clearedquestions = false
	m.removedquestions = nil
}

// AddReactIDs adds the "reacts" edge to the React entity by ids.
func (m *AccountMutation) AddReactIDs(ids ...xid.ID) {
	if m.reacts == nil {
		m.reacts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.reacts[ids[i]] = struct{}{}
	}
}

// ClearReacts clears the "reacts" edge to the React entity.
func (m *AccountMutation) ClearReacts() {
	m.clearedreacts = true
}

// ReactsCleared reports if the "reacts" edge to the React entity was cleared.
func (m *AccountMutation) ReactsCleared() bool {
	return m.clearedreacts
}

// RemoveReactIDs removes the "reacts" edge to the React entity by IDs.
func (m *AccountMutation) RemoveReactIDs(ids ...xid.ID) {
	if m.removedreacts == nil {
		m.removedreacts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.reacts, ids[i])
		m.removedreacts[ids[i]] = struct{}{}
	}
}

// RemovedReacts returns the removed IDs of the "reacts" edge to the React entity.
func (m *AccountMutation) RemovedReactsIDs() (ids []xid.ID) {
	for id := range m.removedreacts {
		ids = append(ids, id)
	}
	return
}

// ReactsIDs returns the "reacts" edge IDs in the mutation.
func (m *AccountMutation) ReactsIDs() (ids []xid.ID) {
	for id := range m.reacts {
		ids = append(ids, id)
	}
	return
}

// ResetReacts resets all changes to the "reacts" edge.
func (m *AccountMutation) ResetReacts() {
	m.reacts = nil
	m.clearedreacts = false
	m.removedreacts = nil
}

// AddLikeIDs adds the "likes" edge to the LikePost entity by ids.
func (m *AccountMutation) AddLikeIDs(ids ...xid.ID) {
	if m.likes == nil {
		m.likes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the LikePost entity.
func (m *AccountMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the LikePost entity was cleared.
func (m *AccountMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the LikePost entity by IDs.
func (m *AccountMutation) RemoveLikeIDs(ids ...xid.ID) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the LikePost entity.
func (m *AccountMutation) RemovedLikesIDs() (ids []xid.ID) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *AccountMutation) LikesIDs() (ids []xid.ID) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *AccountMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// AddMentionIDs adds the "mentions" edge to the MentionProfile entity by ids.
func (m *AccountMutation) AddMentionIDs(ids ...xid.ID) {
	if m.mentions == nil {
		m.mentions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.mentions[ids[i]] = struct{}{}
	}
}

// ClearMentions clears the "mentions" edge to the MentionProfile entity.
func (m *AccountMutation) ClearMentions() {
	m.clearedmentions = true
}

// MentionsCleared reports if the "mentions" edge to the MentionProfile entity was cleared.
func (m *AccountMutation) MentionsCleared() bool {
	return m.clearedmentions
}

// RemoveMentionIDs removes the "mentions" edge to the MentionProfile entity by IDs.
func (m *AccountMutation) RemoveMentionIDs(ids ...xid.ID) {
	if m.removedmentions == nil {
		m.removedmentions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.mentions, ids[i])
		m.removedmentions[ids[i]] = struct{}{}
	}
}

// RemovedMentions returns the removed IDs of the "mentions" edge to the MentionProfile entity.
func (m *AccountMutation) RemovedMentionsIDs() (ids []xid.ID) {
	for id := range m.removedmentions {
		ids = append(ids, id)
	}
	return
}

// MentionsIDs returns the "mentions" edge IDs in the mutation.
func (m *AccountMutation) MentionsIDs() (ids []xid.ID) {
	for id := range m.mentions {
		ids = append(ids, id)
	}
	return
}

// ResetMentions resets all changes to the "mentions" edge.
func (m *AccountMutation) ResetMentions() {
	m.mentions = nil
	m.clearedmentions = false
	m.removedmentions = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *AccountMutation) AddRoleIDs(ids ...xid.ID) {
	if m.roles == nil {
		m.roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *AccountMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *AccountMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *AccountMutation) RemoveRoleIDs(ids ...xid.ID) {
	if m.removedroles == nil {
		m.removedroles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *AccountMutation) RemovedRolesIDs() (ids []xid.ID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AccountMutation) RolesIDs() (ids []xid.ID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AccountMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddAuthenticationIDs adds the "authentication" edge to the Authentication entity by ids.
func (m *AccountMutation) AddAuthenticationIDs(ids ...xid.ID) {
	if m.authentication == nil {
		m.authentication = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.authentication[ids[i]] = struct{}{}
	}
}

// ClearAuthentication clears the "authentication" edge to the Authentication entity.
func (m *AccountMutation) ClearAuthentication() {
	m.clearedauthentication = true
}

// AuthenticationCleared reports if the "authentication" edge to the Authentication entity was cleared.
func (m *AccountMutation) AuthenticationCleared() bool {
	return m.clearedauthentication
}

// RemoveAuthenticationIDs removes the "authentication" edge to the Authentication entity by IDs.
func (m *AccountMutation) RemoveAuthenticationIDs(ids ...xid.ID) {
	if m.removedauthentication == nil {
		m.removedauthentication = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.authentication, ids[i])
		m.removedauthentication[ids[i]] = struct{}{}
	}
}

// RemovedAuthentication returns the removed IDs of the "authentication" edge to the Authentication entity.
func (m *AccountMutation) RemovedAuthenticationIDs() (ids []xid.ID) {
	for id := range m.removedauthentication {
		ids = append(ids, id)
	}
	return
}

// AuthenticationIDs returns the "authentication" edge IDs in the mutation.
func (m *AccountMutation) AuthenticationIDs() (ids []xid.ID) {
	for id := range m.authentication {
		ids = append(ids, id)
	}
	return
}

// ResetAuthentication resets all changes to the "authentication" edge.
func (m *AccountMutation) ResetAuthentication() {
	m.authentication = nil
	m.clearedauthentication = false
	m.removedauthentication = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *AccountMutation) AddTagIDs(ids ...xid.ID) {
	if m.tags == nil {
		m.tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *AccountMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *AccountMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *AccountMutation) RemoveTagIDs(ids ...xid.ID) {
	if m.removedtags == nil {
		m.removedtags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *AccountMutation) RemovedTagsIDs() (ids []xid.ID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *AccountMutation) TagsIDs() (ids []xid.ID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *AccountMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddCollectionIDs adds the "collections" edge to the Collection entity by ids.
func (m *AccountMutation) AddCollectionIDs(ids ...xid.ID) {
	if m.collections == nil {
		m.collections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.collections[ids[i]] = struct{}{}
	}
}

// ClearCollections clears the "collections" edge to the Collection entity.
func (m *AccountMutation) ClearCollections() {
	m.clearedcollections = true
}

// CollectionsCleared reports if the "collections" edge to the Collection entity was cleared.
func (m *AccountMutation) CollectionsCleared() bool {
	return m.clearedcollections
}

// RemoveCollectionIDs removes the "collections" edge to the Collection entity by IDs.
func (m *AccountMutation) RemoveCollectionIDs(ids ...xid.ID) {
	if m.removedcollections == nil {
		m.removedcollections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.collections, ids[i])
		m.removedcollections[ids[i]] = struct{}{}
	}
}

// RemovedCollections returns the removed IDs of the "collections" edge to the Collection entity.
func (m *AccountMutation) RemovedCollectionsIDs() (ids []xid.ID) {
	for id := range m.removedcollections {
		ids = append(ids, id)
	}
	return
}

// CollectionsIDs returns the "collections" edge IDs in the mutation.
func (m *AccountMutation) CollectionsIDs() (ids []xid.ID) {
	for id := range m.collections {
		ids = append(ids, id)
	}
	return
}

// ResetCollections resets all changes to the "collections" edge.
func (m *AccountMutation) ResetCollections() {
	m.collections = nil
	m.clearedcollections = false
	m.removedcollections = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *AccountMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *AccountMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *AccountMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *AccountMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *AccountMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *AccountMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *AccountMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *AccountMutation) AddAssetIDs(ids ...xid.ID) {
	if m.assets == nil {
		m.assets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *AccountMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *AccountMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *AccountMutation) RemoveAssetIDs(ids ...xid.ID) {
	if m.removedassets == nil {
		m.removedassets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *AccountMutation) RemovedAssetsIDs() (ids []xid.ID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *AccountMutation) AssetsIDs() (ids []xid.ID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *AccountMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// AddEventIDs adds the "events" edge to the EventParticipant entity by ids.
func (m *AccountMutation) AddEventIDs(ids ...xid.ID) {
	if m.events == nil {
		m.events = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the EventParticipant entity.
func (m *AccountMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the EventParticipant entity was cleared.
func (m *AccountMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the EventParticipant entity by IDs.
func (m *AccountMutation) RemoveEventIDs(ids ...xid.ID) {
	if m.removedevents == nil {
		m.removedevents = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the EventParticipant entity.
func (m *AccountMutation) RemovedEventsIDs() (ids []xid.ID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *AccountMutation) EventsIDs() (ids []xid.ID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *AccountMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddAccountRoleIDs adds the "account_roles" edge to the AccountRoles entity by ids.
func (m *AccountMutation) AddAccountRoleIDs(ids ...xid.ID) {
	if m.account_roles == nil {
		m.account_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.account_roles[ids[i]] = struct{}{}
	}
}

// ClearAccountRoles clears the "account_roles" edge to the AccountRoles entity.
func (m *AccountMutation) ClearAccountRoles() {
	m.clearedaccount_roles = true
}

// AccountRolesCleared reports if the "account_roles" edge to the AccountRoles entity was cleared.
func (m *AccountMutation) AccountRolesCleared() bool {
	return m.clearedaccount_roles
}

// RemoveAccountRoleIDs removes the "account_roles" edge to the AccountRoles entity by IDs.
func (m *AccountMutation) RemoveAccountRoleIDs(ids ...xid.ID) {
	if m.removedaccount_roles == nil {
		m.removedaccount_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.account_roles, ids[i])
		m.removedaccount_roles[ids[i]] = struct{}{}
	}
}

// RemovedAccountRoles returns the removed IDs of the "account_roles" edge to the AccountRoles entity.
func (m *AccountMutation) RemovedAccountRolesIDs() (ids []xid.ID) {
	for id := range m.removedaccount_roles {
		ids = append(ids, id)
	}
	return
}

// AccountRolesIDs returns the "account_roles" edge IDs in the mutation.
func (m *AccountMutation) AccountRolesIDs() (ids []xid.ID) {
	for id := range m.account_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAccountRoles resets all changes to the "account_roles" edge.
func (m *AccountMutation) ResetAccountRoles() {
	m.account_roles = nil
	m.clearedaccount_roles = false
	m.removedaccount_roles = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, account.FieldIndexedAt)
	}
	if m.handle != nil {
		fields = append(fields, account.FieldHandle)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.bio != nil {
		fields = append(fields, account.FieldBio)
	}
	if m.admin != nil {
		fields = append(fields, account.FieldAdmin)
	}
	if m.links != nil {
		fields = append(fields, account.FieldLinks)
	}
	if m.metadata != nil {
		fields = append(fields, account.FieldMetadata)
	}
	if m.invited_by != nil {
		fields = append(fields, account.FieldInvitedByID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldDeletedAt:
		return m.DeletedAt()
	case account.FieldIndexedAt:
		return m.IndexedAt()
	case account.FieldHandle:
		return m.Handle()
	case account.FieldName:
		return m.Name()
	case account.FieldBio:
		return m.Bio()
	case account.FieldAdmin:
		return m.Admin()
	case account.FieldLinks:
		return m.Links()
	case account.FieldMetadata:
		return m.Metadata()
	case account.FieldInvitedByID:
		return m.InvitedByID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case account.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case account.FieldHandle:
		return m.OldHandle(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldBio:
		return m.OldBio(ctx)
	case account.FieldAdmin:
		return m.OldAdmin(ctx)
	case account.FieldLinks:
		return m.OldLinks(ctx)
	case account.FieldMetadata:
		return m.OldMetadata(ctx)
	case account.FieldInvitedByID:
		return m.OldInvitedByID(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case account.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case account.FieldHandle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandle(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case account.FieldAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	case account.FieldLinks:
		v, ok := value.([]schema.ExternalLink)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinks(v)
		return nil
	case account.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case account.FieldInvitedByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitedByID(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldDeletedAt) {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.FieldCleared(account.FieldIndexedAt) {
		fields = append(fields, account.FieldIndexedAt)
	}
	if m.FieldCleared(account.FieldBio) {
		fields = append(fields, account.FieldBio)
	}
	if m.FieldCleared(account.FieldLinks) {
		fields = append(fields, account.FieldLinks)
	}
	if m.FieldCleared(account.FieldMetadata) {
		fields = append(fields, account.FieldMetadata)
	}
	if m.FieldCleared(account.FieldInvitedByID) {
		fields = append(fields, account.FieldInvitedByID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case account.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case account.FieldBio:
		m.ClearBio()
		return nil
	case account.FieldLinks:
		m.ClearLinks()
		return nil
	case account.FieldMetadata:
		m.ClearMetadata()
		return nil
	case account.FieldInvitedByID:
		m.ClearInvitedByID()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case account.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case account.FieldHandle:
		m.ResetHandle()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldBio:
		m.ResetBio()
		return nil
	case account.FieldAdmin:
		m.ResetAdmin()
		return nil
	case account.FieldLinks:
		m.ResetLinks()
		return nil
	case account.FieldMetadata:
		m.ResetMetadata()
		return nil
	case account.FieldInvitedByID:
		m.ResetInvitedByID()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 20)
	if m.emails != nil {
		edges = append(edges, account.EdgeEmails)
	}
	if m.notifications != nil {
		edges = append(edges, account.EdgeNotifications)
	}
	if m.triggered_notifications != nil {
		edges = append(edges, account.EdgeTriggeredNotifications)
	}
	if m.following != nil {
		edges = append(edges, account.EdgeFollowing)
	}
	if m.followed_by != nil {
		edges = append(edges, account.EdgeFollowedBy)
	}
	if m.invitations != nil {
		edges = append(edges, account.EdgeInvitations)
	}
	if m.invited_by != nil {
		edges = append(edges, account.EdgeInvitedBy)
	}
	if m.posts != nil {
		edges = append(edges, account.EdgePosts)
	}
	if m.questions != nil {
		edges = append(edges, account.EdgeQuestions)
	}
	if m.reacts != nil {
		edges = append(edges, account.EdgeReacts)
	}
	if m.likes != nil {
		edges = append(edges, account.EdgeLikes)
	}
	if m.mentions != nil {
		edges = append(edges, account.EdgeMentions)
	}
	if m.roles != nil {
		edges = append(edges, account.EdgeRoles)
	}
	if m.authentication != nil {
		edges = append(edges, account.EdgeAuthentication)
	}
	if m.tags != nil {
		edges = append(edges, account.EdgeTags)
	}
	if m.collections != nil {
		edges = append(edges, account.EdgeCollections)
	}
	if m.nodes != nil {
		edges = append(edges, account.EdgeNodes)
	}
	if m.assets != nil {
		edges = append(edges, account.EdgeAssets)
	}
	if m.events != nil {
		edges = append(edges, account.EdgeEvents)
	}
	if m.account_roles != nil {
		edges = append(edges, account.EdgeAccountRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeEmails:
		ids := make([]ent.Value, 0, len(m.emails))
		for id := range m.emails {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTriggeredNotifications:
		ids := make([]ent.Value, 0, len(m.triggered_notifications))
		for id := range m.triggered_notifications {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.following))
		for id := range m.following {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeFollowedBy:
		ids := make([]ent.Value, 0, len(m.followed_by))
		for id := range m.followed_by {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.invitations))
		for id := range m.invitations {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInvitedBy:
		if id := m.invited_by; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.reacts))
		for id := range m.reacts {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeMentions:
		ids := make([]ent.Value, 0, len(m.mentions))
		for id := range m.mentions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAuthentication:
		ids := make([]ent.Value, 0, len(m.authentication))
		for id := range m.authentication {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.collections))
		for id := range m.collections {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAccountRoles:
		ids := make([]ent.Value, 0, len(m.account_roles))
		for id := range m.account_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 20)
	if m.removedemails != nil {
		edges = append(edges, account.EdgeEmails)
	}
	if m.removednotifications != nil {
		edges = append(edges, account.EdgeNotifications)
	}
	if m.removedtriggered_notifications != nil {
		edges = append(edges, account.EdgeTriggeredNotifications)
	}
	if m.removedfollowing != nil {
		edges = append(edges, account.EdgeFollowing)
	}
	if m.removedfollowed_by != nil {
		edges = append(edges, account.EdgeFollowedBy)
	}
	if m.removedinvitations != nil {
		edges = append(edges, account.EdgeInvitations)
	}
	if m.removedposts != nil {
		edges = append(edges, account.EdgePosts)
	}
	if m.removedquestions != nil {
		edges = append(edges, account.EdgeQuestions)
	}
	if m.removedreacts != nil {
		edges = append(edges, account.EdgeReacts)
	}
	if m.removedlikes != nil {
		edges = append(edges, account.EdgeLikes)
	}
	if m.removedmentions != nil {
		edges = append(edges, account.EdgeMentions)
	}
	if m.removedroles != nil {
		edges = append(edges, account.EdgeRoles)
	}
	if m.removedauthentication != nil {
		edges = append(edges, account.EdgeAuthentication)
	}
	if m.removedtags != nil {
		edges = append(edges, account.EdgeTags)
	}
	if m.removedcollections != nil {
		edges = append(edges, account.EdgeCollections)
	}
	if m.removednodes != nil {
		edges = append(edges, account.EdgeNodes)
	}
	if m.removedassets != nil {
		edges = append(edges, account.EdgeAssets)
	}
	if m.removedevents != nil {
		edges = append(edges, account.EdgeEvents)
	}
	if m.removedaccount_roles != nil {
		edges = append(edges, account.EdgeAccountRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeEmails:
		ids := make([]ent.Value, 0, len(m.removedemails))
		for id := range m.removedemails {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTriggeredNotifications:
		ids := make([]ent.Value, 0, len(m.removedtriggered_notifications))
		for id := range m.removedtriggered_notifications {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.removedfollowing))
		for id := range m.removedfollowing {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeFollowedBy:
		ids := make([]ent.Value, 0, len(m.removedfollowed_by))
		for id := range m.removedfollowed_by {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.removedinvitations))
		for id := range m.removedinvitations {
			ids = append(ids, id)
		}
		return ids
	case account.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.removedreacts))
		for id := range m.removedreacts {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeMentions:
		ids := make([]ent.Value, 0, len(m.removedmentions))
		for id := range m.removedmentions {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAuthentication:
		ids := make([]ent.Value, 0, len(m.removedauthentication))
		for id := range m.removedauthentication {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.removedcollections))
		for id := range m.removedcollections {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAccountRoles:
		ids := make([]ent.Value, 0, len(m.removedaccount_roles))
		for id := range m.removedaccount_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 20)
	if m.clearedemails {
		edges = append(edges, account.EdgeEmails)
	}
	if m.clearednotifications {
		edges = append(edges, account.EdgeNotifications)
	}
	if m.clearedtriggered_notifications {
		edges = append(edges, account.EdgeTriggeredNotifications)
	}
	if m.clearedfollowing {
		edges = append(edges, account.EdgeFollowing)
	}
	if m.clearedfollowed_by {
		edges = append(edges, account.EdgeFollowedBy)
	}
	if m.clearedinvitations {
		edges = append(edges, account.EdgeInvitations)
	}
	if m.clearedinvited_by {
		edges = append(edges, account.EdgeInvitedBy)
	}
	if m.clearedposts {
		edges = append(edges, account.EdgePosts)
	}
	if m.clearedquestions {
		edges = append(edges, account.EdgeQuestions)
	}
	if m.clearedreacts {
		edges = append(edges, account.EdgeReacts)
	}
	if m.clearedlikes {
		edges = append(edges, account.EdgeLikes)
	}
	if m.clearedmentions {
		edges = append(edges, account.EdgeMentions)
	}
	if m.clearedroles {
		edges = append(edges, account.EdgeRoles)
	}
	if m.clearedauthentication {
		edges = append(edges, account.EdgeAuthentication)
	}
	if m.clearedtags {
		edges = append(edges, account.EdgeTags)
	}
	if m.clearedcollections {
		edges = append(edges, account.EdgeCollections)
	}
	if m.clearednodes {
		edges = append(edges, account.EdgeNodes)
	}
	if m.clearedassets {
		edges = append(edges, account.EdgeAssets)
	}
	if m.clearedevents {
		edges = append(edges, account.EdgeEvents)
	}
	if m.clearedaccount_roles {
		edges = append(edges, account.EdgeAccountRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeEmails:
		return m.clearedemails
	case account.EdgeNotifications:
		return m.clearednotifications
	case account.EdgeTriggeredNotifications:
		return m.clearedtriggered_notifications
	case account.EdgeFollowing:
		return m.clearedfollowing
	case account.EdgeFollowedBy:
		return m.clearedfollowed_by
	case account.EdgeInvitations:
		return m.clearedinvitations
	case account.EdgeInvitedBy:
		return m.clearedinvited_by
	case account.EdgePosts:
		return m.clearedposts
	case account.EdgeQuestions:
		return m.clearedquestions
	case account.EdgeReacts:
		return m.clearedreacts
	case account.EdgeLikes:
		return m.clearedlikes
	case account.EdgeMentions:
		return m.clearedmentions
	case account.EdgeRoles:
		return m.clearedroles
	case account.EdgeAuthentication:
		return m.clearedauthentication
	case account.EdgeTags:
		return m.clearedtags
	case account.EdgeCollections:
		return m.clearedcollections
	case account.EdgeNodes:
		return m.clearednodes
	case account.EdgeAssets:
		return m.clearedassets
	case account.EdgeEvents:
		return m.clearedevents
	case account.EdgeAccountRoles:
		return m.clearedaccount_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeInvitedBy:
		m.ClearInvitedBy()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeEmails:
		m.ResetEmails()
		return nil
	case account.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case account.EdgeTriggeredNotifications:
		m.ResetTriggeredNotifications()
		return nil
	case account.EdgeFollowing:
		m.ResetFollowing()
		return nil
	case account.EdgeFollowedBy:
		m.ResetFollowedBy()
		return nil
	case account.EdgeInvitations:
		m.ResetInvitations()
		return nil
	case account.EdgeInvitedBy:
		m.ResetInvitedBy()
		return nil
	case account.EdgePosts:
		m.ResetPosts()
		return nil
	case account.EdgeQuestions:
		m.ResetQuestions()
		return nil
	case account.EdgeReacts:
		m.ResetReacts()
		return nil
	case account.EdgeLikes:
		m.ResetLikes()
		return nil
	case account.EdgeMentions:
		m.ResetMentions()
		return nil
	case account.EdgeRoles:
		m.ResetRoles()
		return nil
	case account.EdgeAuthentication:
		m.ResetAuthentication()
		return nil
	case account.EdgeTags:
		m.ResetTags()
		return nil
	case account.EdgeCollections:
		m.ResetCollections()
		return nil
	case account.EdgeNodes:
		m.ResetNodes()
		return nil
	case account.EdgeAssets:
		m.ResetAssets()
		return nil
	case account.EdgeEvents:
		m.ResetEvents()
		return nil
	case account.EdgeAccountRoles:
		m.ResetAccountRoles()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AccountFollowMutation represents an operation that mutates the AccountFollow nodes in the graph.
type AccountFollowMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	clearedFields    map[string]struct{}
	follower         *xid.ID
	clearedfollower  bool
	following        *xid.ID
	clearedfollowing bool
	done             bool
	oldValue         func(context.Context) (*AccountFollow, error)
	predicates       []predicate.AccountFollow
}

var _ ent.Mutation = (*AccountFollowMutation)(nil)

// accountfollowOption allows management of the mutation configuration using functional options.
type accountfollowOption func(*AccountFollowMutation)

// newAccountFollowMutation creates new mutation for the AccountFollow entity.
func newAccountFollowMutation(c config, op Op, opts ...accountfollowOption) *AccountFollowMutation {
	m := &AccountFollowMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountFollow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountFollowID sets the ID field of the mutation.
func withAccountFollowID(id xid.ID) accountfollowOption {
	return func(m *AccountFollowMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountFollow
		)
		m.oldValue = func(ctx context.Context) (*AccountFollow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountFollow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountFollow sets the old AccountFollow of the mutation.
func withAccountFollow(node *AccountFollow) accountfollowOption {
	return func(m *AccountFollowMutation) {
		m.oldValue = func(context.Context) (*AccountFollow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountFollowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountFollowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountFollow entities.
func (m *AccountFollowMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountFollowMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountFollowMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountFollow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountFollowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountFollowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountFollow entity.
// If the AccountFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFollowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountFollowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFollowerAccountID sets the "follower_account_id" field.
func (m *AccountFollowMutation) SetFollowerAccountID(x xid.ID) {
	m.follower = &x
}

// FollowerAccountID returns the value of the "follower_account_id" field in the mutation.
func (m *AccountFollowMutation) FollowerAccountID() (r xid.ID, exists bool) {
	v := m.follower
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowerAccountID returns the old "follower_account_id" field's value of the AccountFollow entity.
// If the AccountFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFollowMutation) OldFollowerAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowerAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowerAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowerAccountID: %w", err)
	}
	return oldValue.FollowerAccountID, nil
}

// ResetFollowerAccountID resets all changes to the "follower_account_id" field.
func (m *AccountFollowMutation) ResetFollowerAccountID() {
	m.follower = nil
}

// SetFollowingAccountID sets the "following_account_id" field.
func (m *AccountFollowMutation) SetFollowingAccountID(x xid.ID) {
	m.following = &x
}

// FollowingAccountID returns the value of the "following_account_id" field in the mutation.
func (m *AccountFollowMutation) FollowingAccountID() (r xid.ID, exists bool) {
	v := m.following
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowingAccountID returns the old "following_account_id" field's value of the AccountFollow entity.
// If the AccountFollow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFollowMutation) OldFollowingAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowingAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowingAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowingAccountID: %w", err)
	}
	return oldValue.FollowingAccountID, nil
}

// ResetFollowingAccountID resets all changes to the "following_account_id" field.
func (m *AccountFollowMutation) ResetFollowingAccountID() {
	m.following = nil
}

// SetFollowerID sets the "follower" edge to the Account entity by id.
func (m *AccountFollowMutation) SetFollowerID(id xid.ID) {
	m.follower = &id
}

// ClearFollower clears the "follower" edge to the Account entity.
func (m *AccountFollowMutation) ClearFollower() {
	m.clearedfollower = true
	m.clearedFields[accountfollow.FieldFollowerAccountID] = struct{}{}
}

// FollowerCleared reports if the "follower" edge to the Account entity was cleared.
func (m *AccountFollowMutation) FollowerCleared() bool {
	return m.clearedfollower
}

// FollowerID returns the "follower" edge ID in the mutation.
func (m *AccountFollowMutation) FollowerID() (id xid.ID, exists bool) {
	if m.follower != nil {
		return *m.follower, true
	}
	return
}

// FollowerIDs returns the "follower" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowerID instead. It exists only for internal usage by the builders.
func (m *AccountFollowMutation) FollowerIDs() (ids []xid.ID) {
	if id := m.follower; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollower resets all changes to the "follower" edge.
func (m *AccountFollowMutation) ResetFollower() {
	m.follower = nil
	m.clearedfollower = false
}

// SetFollowingID sets the "following" edge to the Account entity by id.
func (m *AccountFollowMutation) SetFollowingID(id xid.ID) {
	m.following = &id
}

// ClearFollowing clears the "following" edge to the Account entity.
func (m *AccountFollowMutation) ClearFollowing() {
	m.clearedfollowing = true
	m.clearedFields[accountfollow.FieldFollowingAccountID] = struct{}{}
}

// FollowingCleared reports if the "following" edge to the Account entity was cleared.
func (m *AccountFollowMutation) FollowingCleared() bool {
	return m.clearedfollowing
}

// FollowingID returns the "following" edge ID in the mutation.
func (m *AccountFollowMutation) FollowingID() (id xid.ID, exists bool) {
	if m.following != nil {
		return *m.following, true
	}
	return
}

// FollowingIDs returns the "following" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowingID instead. It exists only for internal usage by the builders.
func (m *AccountFollowMutation) FollowingIDs() (ids []xid.ID) {
	if id := m.following; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollowing resets all changes to the "following" edge.
func (m *AccountFollowMutation) ResetFollowing() {
	m.following = nil
	m.clearedfollowing = false
}

// Where appends a list predicates to the AccountFollowMutation builder.
func (m *AccountFollowMutation) Where(ps ...predicate.AccountFollow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountFollowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountFollowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountFollow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountFollowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountFollowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountFollow).
func (m *AccountFollowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountFollowMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, accountfollow.FieldCreatedAt)
	}
	if m.follower != nil {
		fields = append(fields, accountfollow.FieldFollowerAccountID)
	}
	if m.following != nil {
		fields = append(fields, accountfollow.FieldFollowingAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountFollowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountfollow.FieldCreatedAt:
		return m.CreatedAt()
	case accountfollow.FieldFollowerAccountID:
		return m.FollowerAccountID()
	case accountfollow.FieldFollowingAccountID:
		return m.FollowingAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountFollowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountfollow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountfollow.FieldFollowerAccountID:
		return m.OldFollowerAccountID(ctx)
	case accountfollow.FieldFollowingAccountID:
		return m.OldFollowingAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown AccountFollow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountFollowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountfollow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountfollow.FieldFollowerAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowerAccountID(v)
		return nil
	case accountfollow.FieldFollowingAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowingAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown AccountFollow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountFollowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountFollowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountFollowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccountFollow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountFollowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountFollowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountFollowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountFollow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountFollowMutation) ResetField(name string) error {
	switch name {
	case accountfollow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountfollow.FieldFollowerAccountID:
		m.ResetFollowerAccountID()
		return nil
	case accountfollow.FieldFollowingAccountID:
		m.ResetFollowingAccountID()
		return nil
	}
	return fmt.Errorf("unknown AccountFollow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountFollowMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.follower != nil {
		edges = append(edges, accountfollow.EdgeFollower)
	}
	if m.following != nil {
		edges = append(edges, accountfollow.EdgeFollowing)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountFollowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountfollow.EdgeFollower:
		if id := m.follower; id != nil {
			return []ent.Value{*id}
		}
	case accountfollow.EdgeFollowing:
		if id := m.following; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountFollowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountFollowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountFollowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfollower {
		edges = append(edges, accountfollow.EdgeFollower)
	}
	if m.clearedfollowing {
		edges = append(edges, accountfollow.EdgeFollowing)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountFollowMutation) EdgeCleared(name string) bool {
	switch name {
	case accountfollow.EdgeFollower:
		return m.clearedfollower
	case accountfollow.EdgeFollowing:
		return m.clearedfollowing
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountFollowMutation) ClearEdge(name string) error {
	switch name {
	case accountfollow.EdgeFollower:
		m.ClearFollower()
		return nil
	case accountfollow.EdgeFollowing:
		m.ClearFollowing()
		return nil
	}
	return fmt.Errorf("unknown AccountFollow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountFollowMutation) ResetEdge(name string) error {
	switch name {
	case accountfollow.EdgeFollower:
		m.ResetFollower()
		return nil
	case accountfollow.EdgeFollowing:
		m.ResetFollowing()
		return nil
	}
	return fmt.Errorf("unknown AccountFollow edge %s", name)
}

// AccountRolesMutation represents an operation that mutates the AccountRoles nodes in the graph.
type AccountRolesMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	badge          *bool
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	role           *xid.ID
	clearedrole    bool
	done           bool
	oldValue       func(context.Context) (*AccountRoles, error)
	predicates     []predicate.AccountRoles
}

var _ ent.Mutation = (*AccountRolesMutation)(nil)

// accountrolesOption allows management of the mutation configuration using functional options.
type accountrolesOption func(*AccountRolesMutation)

// newAccountRolesMutation creates new mutation for the AccountRoles entity.
func newAccountRolesMutation(c config, op Op, opts ...accountrolesOption) *AccountRolesMutation {
	m := &AccountRolesMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountRoles,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountRolesID sets the ID field of the mutation.
func withAccountRolesID(id xid.ID) accountrolesOption {
	return func(m *AccountRolesMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountRoles
		)
		m.oldValue = func(ctx context.Context) (*AccountRoles, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountRoles.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountRoles sets the old AccountRoles of the mutation.
func withAccountRoles(node *AccountRoles) accountrolesOption {
	return func(m *AccountRolesMutation) {
		m.oldValue = func(context.Context) (*AccountRoles, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountRolesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountRolesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountRoles entities.
func (m *AccountRolesMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountRolesMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountRolesMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountRoles.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountRolesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountRolesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountRoles entity.
// If the AccountRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountRolesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountRolesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountID sets the "account_id" field.
func (m *AccountRolesMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AccountRolesMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the AccountRoles entity.
// If the AccountRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountRolesMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AccountRolesMutation) ResetAccountID() {
	m.account = nil
}

// SetRoleID sets the "role_id" field.
func (m *AccountRolesMutation) SetRoleID(x xid.ID) {
	m.role = &x
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AccountRolesMutation) RoleID() (r xid.ID, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the AccountRoles entity.
// If the AccountRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountRolesMutation) OldRoleID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AccountRolesMutation) ResetRoleID() {
	m.role = nil
}

// SetBadge sets the "badge" field.
func (m *AccountRolesMutation) SetBadge(b bool) {
	m.badge = &b
}

// Badge returns the value of the "badge" field in the mutation.
func (m *AccountRolesMutation) Badge() (r bool, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the AccountRoles entity.
// If the AccountRoles object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountRolesMutation) OldBadge(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *AccountRolesMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[accountroles.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *AccountRolesMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[accountroles.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *AccountRolesMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, accountroles.FieldBadge)
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *AccountRolesMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[accountroles.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *AccountRolesMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *AccountRolesMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *AccountRolesMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *AccountRolesMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[accountroles.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *AccountRolesMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *AccountRolesMutation) RoleIDs() (ids []xid.ID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *AccountRolesMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the AccountRolesMutation builder.
func (m *AccountRolesMutation) Where(ps ...predicate.AccountRoles) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountRolesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountRolesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountRoles, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountRolesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountRolesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountRoles).
func (m *AccountRolesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountRolesMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, accountroles.FieldCreatedAt)
	}
	if m.account != nil {
		fields = append(fields, accountroles.FieldAccountID)
	}
	if m.role != nil {
		fields = append(fields, accountroles.FieldRoleID)
	}
	if m.badge != nil {
		fields = append(fields, accountroles.FieldBadge)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountRolesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountroles.FieldCreatedAt:
		return m.CreatedAt()
	case accountroles.FieldAccountID:
		return m.AccountID()
	case accountroles.FieldRoleID:
		return m.RoleID()
	case accountroles.FieldBadge:
		return m.Badge()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountRolesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountroles.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountroles.FieldAccountID:
		return m.OldAccountID(ctx)
	case accountroles.FieldRoleID:
		return m.OldRoleID(ctx)
	case accountroles.FieldBadge:
		return m.OldBadge(ctx)
	}
	return nil, fmt.Errorf("unknown AccountRoles field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountRolesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountroles.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountroles.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case accountroles.FieldRoleID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case accountroles.FieldBadge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	}
	return fmt.Errorf("unknown AccountRoles field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountRolesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountRolesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountRolesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccountRoles numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountRolesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountroles.FieldBadge) {
		fields = append(fields, accountroles.FieldBadge)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountRolesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountRolesMutation) ClearField(name string) error {
	switch name {
	case accountroles.FieldBadge:
		m.ClearBadge()
		return nil
	}
	return fmt.Errorf("unknown AccountRoles nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountRolesMutation) ResetField(name string) error {
	switch name {
	case accountroles.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountroles.FieldAccountID:
		m.ResetAccountID()
		return nil
	case accountroles.FieldRoleID:
		m.ResetRoleID()
		return nil
	case accountroles.FieldBadge:
		m.ResetBadge()
		return nil
	}
	return fmt.Errorf("unknown AccountRoles field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountRolesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, accountroles.EdgeAccount)
	}
	if m.role != nil {
		edges = append(edges, accountroles.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountRolesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountroles.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case accountroles.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountRolesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountRolesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountRolesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, accountroles.EdgeAccount)
	}
	if m.clearedrole {
		edges = append(edges, accountroles.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountRolesMutation) EdgeCleared(name string) bool {
	switch name {
	case accountroles.EdgeAccount:
		return m.clearedaccount
	case accountroles.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountRolesMutation) ClearEdge(name string) error {
	switch name {
	case accountroles.EdgeAccount:
		m.ClearAccount()
		return nil
	case accountroles.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown AccountRoles unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountRolesMutation) ResetEdge(name string) error {
	switch name {
	case accountroles.EdgeAccount:
		m.ResetAccount()
		return nil
	case accountroles.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown AccountRoles edge %s", name)
}

// AssetMutation represents an operation that mutates the Asset nodes in the graph.
type AssetMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	filename      *string
	size          *int
	addsize       *int
	mime_type     *string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	posts         map[xid.ID]struct{}
	removedposts  map[xid.ID]struct{}
	clearedposts  bool
	nodes         map[xid.ID]struct{}
	removednodes  map[xid.ID]struct{}
	clearednodes  bool
	links         map[xid.ID]struct{}
	removedlinks  map[xid.ID]struct{}
	clearedlinks  bool
	owner         *xid.ID
	clearedowner  bool
	parent        *xid.ID
	clearedparent bool
	assets        map[xid.ID]struct{}
	removedassets map[xid.ID]struct{}
	clearedassets bool
	event         map[xid.ID]struct{}
	removedevent  map[xid.ID]struct{}
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*Asset, error)
	predicates    []predicate.Asset
}

var _ ent.Mutation = (*AssetMutation)(nil)

// assetOption allows management of the mutation configuration using functional options.
type assetOption func(*AssetMutation)

// newAssetMutation creates new mutation for the Asset entity.
func newAssetMutation(c config, op Op, opts ...assetOption) *AssetMutation {
	m := &AssetMutation{
		config:        c,
		op:            op,
		typ:           TypeAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetID sets the ID field of the mutation.
func withAssetID(id xid.ID) assetOption {
	return func(m *AssetMutation) {
		var (
			err   error
			once  sync.Once
			value *Asset
		)
		m.oldValue = func(ctx context.Context) (*Asset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Asset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsset sets the old Asset of the mutation.
func withAsset(node *Asset) assetOption {
	return func(m *AssetMutation) {
		m.oldValue = func(context.Context) (*Asset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Asset entities.
func (m *AssetMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Asset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFilename sets the "filename" field.
func (m *AssetMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *AssetMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *AssetMutation) ResetFilename() {
	m.filename = nil
}

// SetSize sets the "size" field.
func (m *AssetMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *AssetMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *AssetMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *AssetMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *AssetMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetMimeType sets the "mime_type" field.
func (m *AssetMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *AssetMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *AssetMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetMetadata sets the "metadata" field.
func (m *AssetMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AssetMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AssetMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[asset.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AssetMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[asset.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AssetMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, asset.FieldMetadata)
}

// SetAccountID sets the "account_id" field.
func (m *AssetMutation) SetAccountID(x xid.ID) {
	m.owner = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AssetMutation) AccountID() (r xid.ID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AssetMutation) ResetAccountID() {
	m.owner = nil
}

// SetParentAssetID sets the "parent_asset_id" field.
func (m *AssetMutation) SetParentAssetID(x xid.ID) {
	m.parent = &x
}

// ParentAssetID returns the value of the "parent_asset_id" field in the mutation.
func (m *AssetMutation) ParentAssetID() (r xid.ID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentAssetID returns the old "parent_asset_id" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldParentAssetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentAssetID: %w", err)
	}
	return oldValue.ParentAssetID, nil
}

// ClearParentAssetID clears the value of the "parent_asset_id" field.
func (m *AssetMutation) ClearParentAssetID() {
	m.parent = nil
	m.clearedFields[asset.FieldParentAssetID] = struct{}{}
}

// ParentAssetIDCleared returns if the "parent_asset_id" field was cleared in this mutation.
func (m *AssetMutation) ParentAssetIDCleared() bool {
	_, ok := m.clearedFields[asset.FieldParentAssetID]
	return ok
}

// ResetParentAssetID resets all changes to the "parent_asset_id" field.
func (m *AssetMutation) ResetParentAssetID() {
	m.parent = nil
	delete(m.clearedFields, asset.FieldParentAssetID)
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *AssetMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *AssetMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *AssetMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *AssetMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *AssetMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *AssetMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *AssetMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *AssetMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *AssetMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *AssetMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *AssetMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *AssetMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *AssetMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *AssetMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddLinkIDs adds the "links" edge to the Link entity by ids.
func (m *AssetMutation) AddLinkIDs(ids ...xid.ID) {
	if m.links == nil {
		m.links = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the "links" edge to the Link entity.
func (m *AssetMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared reports if the "links" edge to the Link entity was cleared.
func (m *AssetMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the "links" edge to the Link entity by IDs.
func (m *AssetMutation) RemoveLinkIDs(ids ...xid.ID) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.links, ids[i])
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed IDs of the "links" edge to the Link entity.
func (m *AssetMutation) RemovedLinksIDs() (ids []xid.ID) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the "links" edge IDs in the mutation.
func (m *AssetMutation) LinksIDs() (ids []xid.ID) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks resets all changes to the "links" edge.
func (m *AssetMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *AssetMutation) SetOwnerID(id xid.ID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *AssetMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[asset.FieldAccountID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *AssetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AssetMutation) OwnerID() (id xid.ID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) OwnerIDs() (ids []xid.ID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AssetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetParentID sets the "parent" edge to the Asset entity by id.
func (m *AssetMutation) SetParentID(id xid.ID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Asset entity.
func (m *AssetMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[asset.FieldParentAssetID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Asset entity was cleared.
func (m *AssetMutation) ParentCleared() bool {
	return m.ParentAssetIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *AssetMutation) ParentID() (id xid.ID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) ParentIDs() (ids []xid.ID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *AssetMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *AssetMutation) AddAssetIDs(ids ...xid.ID) {
	if m.assets == nil {
		m.assets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *AssetMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *AssetMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *AssetMutation) RemoveAssetIDs(ids ...xid.ID) {
	if m.removedassets == nil {
		m.removedassets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *AssetMutation) RemovedAssetsIDs() (ids []xid.ID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *AssetMutation) AssetsIDs() (ids []xid.ID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *AssetMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// AddEventIDs adds the "event" edge to the Event entity by ids.
func (m *AssetMutation) AddEventIDs(ids ...xid.ID) {
	if m.event == nil {
		m.event = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.event[ids[i]] = struct{}{}
	}
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *AssetMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *AssetMutation) EventCleared() bool {
	return m.clearedevent
}

// RemoveEventIDs removes the "event" edge to the Event entity by IDs.
func (m *AssetMutation) RemoveEventIDs(ids ...xid.ID) {
	if m.removedevent == nil {
		m.removedevent = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.event, ids[i])
		m.removedevent[ids[i]] = struct{}{}
	}
}

// RemovedEvent returns the removed IDs of the "event" edge to the Event entity.
func (m *AssetMutation) RemovedEventIDs() (ids []xid.ID) {
	for id := range m.removedevent {
		ids = append(ids, id)
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
func (m *AssetMutation) EventIDs() (ids []xid.ID) {
	for id := range m.event {
		ids = append(ids, id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *AssetMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
	m.removedevent = nil
}

// Where appends a list predicates to the AssetMutation builder.
func (m *AssetMutation) Where(ps ...predicate.Asset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Asset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Asset).
func (m *AssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, asset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, asset.FieldUpdatedAt)
	}
	if m.filename != nil {
		fields = append(fields, asset.FieldFilename)
	}
	if m.size != nil {
		fields = append(fields, asset.FieldSize)
	}
	if m.mime_type != nil {
		fields = append(fields, asset.FieldMimeType)
	}
	if m.metadata != nil {
		fields = append(fields, asset.FieldMetadata)
	}
	if m.owner != nil {
		fields = append(fields, asset.FieldAccountID)
	}
	if m.parent != nil {
		fields = append(fields, asset.FieldParentAssetID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldCreatedAt:
		return m.CreatedAt()
	case asset.FieldUpdatedAt:
		return m.UpdatedAt()
	case asset.FieldFilename:
		return m.Filename()
	case asset.FieldSize:
		return m.Size()
	case asset.FieldMimeType:
		return m.MimeType()
	case asset.FieldMetadata:
		return m.Metadata()
	case asset.FieldAccountID:
		return m.AccountID()
	case asset.FieldParentAssetID:
		return m.ParentAssetID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case asset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case asset.FieldFilename:
		return m.OldFilename(ctx)
	case asset.FieldSize:
		return m.OldSize(ctx)
	case asset.FieldMimeType:
		return m.OldMimeType(ctx)
	case asset.FieldMetadata:
		return m.OldMetadata(ctx)
	case asset.FieldAccountID:
		return m.OldAccountID(ctx)
	case asset.FieldParentAssetID:
		return m.OldParentAssetID(ctx)
	}
	return nil, fmt.Errorf("unknown Asset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case asset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case asset.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case asset.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case asset.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case asset.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case asset.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case asset.FieldParentAssetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentAssetID(v)
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, asset.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asset.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Asset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asset.FieldMetadata) {
		fields = append(fields, asset.FieldMetadata)
	}
	if m.FieldCleared(asset.FieldParentAssetID) {
		fields = append(fields, asset.FieldParentAssetID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetMutation) ClearField(name string) error {
	switch name {
	case asset.FieldMetadata:
		m.ClearMetadata()
		return nil
	case asset.FieldParentAssetID:
		m.ClearParentAssetID()
		return nil
	}
	return fmt.Errorf("unknown Asset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetMutation) ResetField(name string) error {
	switch name {
	case asset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case asset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case asset.FieldFilename:
		m.ResetFilename()
		return nil
	case asset.FieldSize:
		m.ResetSize()
		return nil
	case asset.FieldMimeType:
		m.ResetMimeType()
		return nil
	case asset.FieldMetadata:
		m.ResetMetadata()
		return nil
	case asset.FieldAccountID:
		m.ResetAccountID()
		return nil
	case asset.FieldParentAssetID:
		m.ResetParentAssetID()
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.posts != nil {
		edges = append(edges, asset.EdgePosts)
	}
	if m.nodes != nil {
		edges = append(edges, asset.EdgeNodes)
	}
	if m.links != nil {
		edges = append(edges, asset.EdgeLinks)
	}
	if m.owner != nil {
		edges = append(edges, asset.EdgeOwner)
	}
	if m.parent != nil {
		edges = append(edges, asset.EdgeParent)
	}
	if m.assets != nil {
		edges = append(edges, asset.EdgeAssets)
	}
	if m.event != nil {
		edges = append(edges, asset.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.event))
		for id := range m.event {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedposts != nil {
		edges = append(edges, asset.EdgePosts)
	}
	if m.removednodes != nil {
		edges = append(edges, asset.EdgeNodes)
	}
	if m.removedlinks != nil {
		edges = append(edges, asset.EdgeLinks)
	}
	if m.removedassets != nil {
		edges = append(edges, asset.EdgeAssets)
	}
	if m.removedevent != nil {
		edges = append(edges, asset.EdgeEvent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.removedevent))
		for id := range m.removedevent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedposts {
		edges = append(edges, asset.EdgePosts)
	}
	if m.clearednodes {
		edges = append(edges, asset.EdgeNodes)
	}
	if m.clearedlinks {
		edges = append(edges, asset.EdgeLinks)
	}
	if m.clearedowner {
		edges = append(edges, asset.EdgeOwner)
	}
	if m.clearedparent {
		edges = append(edges, asset.EdgeParent)
	}
	if m.clearedassets {
		edges = append(edges, asset.EdgeAssets)
	}
	if m.clearedevent {
		edges = append(edges, asset.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetMutation) EdgeCleared(name string) bool {
	switch name {
	case asset.EdgePosts:
		return m.clearedposts
	case asset.EdgeNodes:
		return m.clearednodes
	case asset.EdgeLinks:
		return m.clearedlinks
	case asset.EdgeOwner:
		return m.clearedowner
	case asset.EdgeParent:
		return m.clearedparent
	case asset.EdgeAssets:
		return m.clearedassets
	case asset.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetMutation) ClearEdge(name string) error {
	switch name {
	case asset.EdgeOwner:
		m.ClearOwner()
		return nil
	case asset.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Asset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetMutation) ResetEdge(name string) error {
	switch name {
	case asset.EdgePosts:
		m.ResetPosts()
		return nil
	case asset.EdgeNodes:
		m.ResetNodes()
		return nil
	case asset.EdgeLinks:
		m.ResetLinks()
		return nil
	case asset.EdgeOwner:
		m.ResetOwner()
		return nil
	case asset.EdgeParent:
		m.ResetParent()
		return nil
	case asset.EdgeAssets:
		m.ResetAssets()
		return nil
	case asset.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown Asset edge %s", name)
}

// AuthenticationMutation represents an operation that mutates the Authentication nodes in the graph.
type AuthenticationMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	service        *string
	token_type     *string
	identifier     *string
	token          *string
	name           *string
	metadata       *map[string]interface{}
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	done           bool
	oldValue       func(context.Context) (*Authentication, error)
	predicates     []predicate.Authentication
}

var _ ent.Mutation = (*AuthenticationMutation)(nil)

// authenticationOption allows management of the mutation configuration using functional options.
type authenticationOption func(*AuthenticationMutation)

// newAuthenticationMutation creates new mutation for the Authentication entity.
func newAuthenticationMutation(c config, op Op, opts ...authenticationOption) *AuthenticationMutation {
	m := &AuthenticationMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthentication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthenticationID sets the ID field of the mutation.
func withAuthenticationID(id xid.ID) authenticationOption {
	return func(m *AuthenticationMutation) {
		var (
			err   error
			once  sync.Once
			value *Authentication
		)
		m.oldValue = func(ctx context.Context) (*Authentication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Authentication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthentication sets the old Authentication of the mutation.
func withAuthentication(node *Authentication) authenticationOption {
	return func(m *AuthenticationMutation) {
		m.oldValue = func(context.Context) (*Authentication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthenticationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthenticationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Authentication entities.
func (m *AuthenticationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthenticationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthenticationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Authentication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthenticationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthenticationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthenticationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetService sets the "service" field.
func (m *AuthenticationMutation) SetService(s string) {
	m.service = &s
}

// Service returns the value of the "service" field in the mutation.
func (m *AuthenticationMutation) Service() (r string, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldService returns the old "service" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldService(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldService: %w", err)
	}
	return oldValue.Service, nil
}

// ResetService resets all changes to the "service" field.
func (m *AuthenticationMutation) ResetService() {
	m.service = nil
}

// SetTokenType sets the "token_type" field.
func (m *AuthenticationMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *AuthenticationMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *AuthenticationMutation) ResetTokenType() {
	m.token_type = nil
}

// SetIdentifier sets the "identifier" field.
func (m *AuthenticationMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *AuthenticationMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *AuthenticationMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetToken sets the "token" field.
func (m *AuthenticationMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AuthenticationMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AuthenticationMutation) ResetToken() {
	m.token = nil
}

// SetName sets the "name" field.
func (m *AuthenticationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AuthenticationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AuthenticationMutation) ClearName() {
	m.name = nil
	m.clearedFields[authentication.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AuthenticationMutation) NameCleared() bool {
	_, ok := m.clearedFields[authentication.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AuthenticationMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, authentication.FieldName)
}

// SetMetadata sets the "metadata" field.
func (m *AuthenticationMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuthenticationMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuthenticationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[authentication.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuthenticationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[authentication.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuthenticationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, authentication.FieldMetadata)
}

// SetAccountAuthentication sets the "account_authentication" field.
func (m *AuthenticationMutation) SetAccountAuthentication(x xid.ID) {
	m.account = &x
}

// AccountAuthentication returns the value of the "account_authentication" field in the mutation.
func (m *AuthenticationMutation) AccountAuthentication() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountAuthentication returns the old "account_authentication" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldAccountAuthentication(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountAuthentication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountAuthentication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountAuthentication: %w", err)
	}
	return oldValue.AccountAuthentication, nil
}

// ResetAccountAuthentication resets all changes to the "account_authentication" field.
func (m *AuthenticationMutation) ResetAccountAuthentication() {
	m.account = nil
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *AuthenticationMutation) SetAccountID(id xid.ID) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *AuthenticationMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[authentication.FieldAccountAuthentication] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *AuthenticationMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *AuthenticationMutation) AccountID() (id xid.ID, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *AuthenticationMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *AuthenticationMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the AuthenticationMutation builder.
func (m *AuthenticationMutation) Where(ps ...predicate.Authentication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthenticationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthenticationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Authentication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthenticationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthenticationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Authentication).
func (m *AuthenticationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthenticationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, authentication.FieldCreatedAt)
	}
	if m.service != nil {
		fields = append(fields, authentication.FieldService)
	}
	if m.token_type != nil {
		fields = append(fields, authentication.FieldTokenType)
	}
	if m.identifier != nil {
		fields = append(fields, authentication.FieldIdentifier)
	}
	if m.token != nil {
		fields = append(fields, authentication.FieldToken)
	}
	if m.name != nil {
		fields = append(fields, authentication.FieldName)
	}
	if m.metadata != nil {
		fields = append(fields, authentication.FieldMetadata)
	}
	if m.account != nil {
		fields = append(fields, authentication.FieldAccountAuthentication)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthenticationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authentication.FieldCreatedAt:
		return m.CreatedAt()
	case authentication.FieldService:
		return m.Service()
	case authentication.FieldTokenType:
		return m.TokenType()
	case authentication.FieldIdentifier:
		return m.Identifier()
	case authentication.FieldToken:
		return m.Token()
	case authentication.FieldName:
		return m.Name()
	case authentication.FieldMetadata:
		return m.Metadata()
	case authentication.FieldAccountAuthentication:
		return m.AccountAuthentication()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthenticationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authentication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authentication.FieldService:
		return m.OldService(ctx)
	case authentication.FieldTokenType:
		return m.OldTokenType(ctx)
	case authentication.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case authentication.FieldToken:
		return m.OldToken(ctx)
	case authentication.FieldName:
		return m.OldName(ctx)
	case authentication.FieldMetadata:
		return m.OldMetadata(ctx)
	case authentication.FieldAccountAuthentication:
		return m.OldAccountAuthentication(ctx)
	}
	return nil, fmt.Errorf("unknown Authentication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthenticationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authentication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authentication.FieldService:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetService(v)
		return nil
	case authentication.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case authentication.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case authentication.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case authentication.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case authentication.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case authentication.FieldAccountAuthentication:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountAuthentication(v)
		return nil
	}
	return fmt.Errorf("unknown Authentication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthenticationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthenticationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthenticationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Authentication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthenticationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authentication.FieldName) {
		fields = append(fields, authentication.FieldName)
	}
	if m.FieldCleared(authentication.FieldMetadata) {
		fields = append(fields, authentication.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthenticationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthenticationMutation) ClearField(name string) error {
	switch name {
	case authentication.FieldName:
		m.ClearName()
		return nil
	case authentication.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Authentication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthenticationMutation) ResetField(name string) error {
	switch name {
	case authentication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authentication.FieldService:
		m.ResetService()
		return nil
	case authentication.FieldTokenType:
		m.ResetTokenType()
		return nil
	case authentication.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case authentication.FieldToken:
		m.ResetToken()
		return nil
	case authentication.FieldName:
		m.ResetName()
		return nil
	case authentication.FieldMetadata:
		m.ResetMetadata()
		return nil
	case authentication.FieldAccountAuthentication:
		m.ResetAccountAuthentication()
		return nil
	}
	return fmt.Errorf("unknown Authentication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthenticationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.account != nil {
		edges = append(edges, authentication.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthenticationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authentication.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthenticationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthenticationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthenticationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccount {
		edges = append(edges, authentication.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthenticationMutation) EdgeCleared(name string) bool {
	switch name {
	case authentication.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthenticationMutation) ClearEdge(name string) error {
	switch name {
	case authentication.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Authentication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthenticationMutation) ResetEdge(name string) error {
	switch name {
	case authentication.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown Authentication edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	slug          *string
	description   *string
	colour        *string
	sort          *int
	addsort       *int
	admin         *bool
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	posts         map[xid.ID]struct{}
	removedposts  map[xid.ID]struct{}
	clearedposts  bool
	done          bool
	oldValue      func(context.Context) (*Category, error)
	predicates    []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id xid.ID) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
}

// SetColour sets the "colour" field.
func (m *CategoryMutation) SetColour(s string) {
	m.colour = &s
}

// Colour returns the value of the "colour" field in the mutation.
func (m *CategoryMutation) Colour() (r string, exists bool) {
	v := m.colour
	if v == nil {
		return
	}
	return *v, true
}

// OldColour returns the old "colour" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldColour(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColour: %w", err)
	}
	return oldValue.Colour, nil
}

// ResetColour resets all changes to the "colour" field.
func (m *CategoryMutation) ResetColour() {
	m.colour = nil
}

// SetSort sets the "sort" field.
func (m *CategoryMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *CategoryMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *CategoryMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *CategoryMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *CategoryMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetAdmin sets the "admin" field.
func (m *CategoryMutation) SetAdmin(b bool) {
	m.admin = &b
}

// Admin returns the value of the "admin" field in the mutation.
func (m *CategoryMutation) Admin() (r bool, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "admin" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "admin" field.
func (m *CategoryMutation) ResetAdmin() {
	m.admin = nil
}

// SetMetadata sets the "metadata" field.
func (m *CategoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CategoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CategoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[category.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CategoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[category.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CategoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, category.FieldMetadata)
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *CategoryMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *CategoryMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *CategoryMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *CategoryMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *CategoryMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *CategoryMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *CategoryMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.colour != nil {
		fields = append(fields, category.FieldColour)
	}
	if m.sort != nil {
		fields = append(fields, category.FieldSort)
	}
	if m.admin != nil {
		fields = append(fields, category.FieldAdmin)
	}
	if m.metadata != nil {
		fields = append(fields, category.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldName:
		return m.Name()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldDescription:
		return m.Description()
	case category.FieldColour:
		return m.Colour()
	case category.FieldSort:
		return m.Sort()
	case category.FieldAdmin:
		return m.Admin()
	case category.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldColour:
		return m.OldColour(ctx)
	case category.FieldSort:
		return m.OldSort(ctx)
	case category.FieldAdmin:
		return m.OldAdmin(ctx)
	case category.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldColour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColour(v)
		return nil
	case category.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case category.FieldAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	case category.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, category.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldMetadata) {
		fields = append(fields, category.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldColour:
		m.ResetColour()
		return nil
	case category.FieldSort:
		m.ResetSort()
		return nil
	case category.FieldAdmin:
		m.ResetAdmin()
		return nil
	case category.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.posts != nil {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedposts != nil {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedposts {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CollectionMutation represents an operation that mutates the Collection nodes in the graph.
type CollectionMutation struct {
	config
	op                 Op
	typ                string
	id                 *xid.ID
	created_at         *time.Time
	updated_at         *time.Time
	indexed_at         *time.Time
	name               *string
	slug               *string
	description        *string
	visibility         *collection.Visibility
	clearedFields      map[string]struct{}
	owner              *xid.ID
	clearedowner       bool
	cover_image        *xid.ID
	clearedcover_image bool
	posts              map[xid.ID]struct{}
	removedposts       map[xid.ID]struct{}
	clearedposts       bool
	nodes              map[xid.ID]struct{}
	removednodes       map[xid.ID]struct{}
	clearednodes       bool
	done               bool
	oldValue           func(context.Context) (*Collection, error)
	predicates         []predicate.Collection
}

var _ ent.Mutation = (*CollectionMutation)(nil)

// collectionOption allows management of the mutation configuration using functional options.
type collectionOption func(*CollectionMutation)

// newCollectionMutation creates new mutation for the Collection entity.
func newCollectionMutation(c config, op Op, opts ...collectionOption) *CollectionMutation {
	m := &CollectionMutation{
		config:        c,
		op:            op,
		typ:           TypeCollection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollectionID sets the ID field of the mutation.
func withCollectionID(id xid.ID) collectionOption {
	return func(m *CollectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Collection
		)
		m.oldValue = func(ctx context.Context) (*Collection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Collection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollection sets the old Collection of the mutation.
func withCollection(node *Collection) collectionOption {
	return func(m *CollectionMutation) {
		m.oldValue = func(context.Context) (*Collection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Collection entities.
func (m *CollectionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CollectionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CollectionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Collection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CollectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CollectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CollectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIndexedAt sets the "indexed_at" field.
func (m *CollectionMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *CollectionMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *CollectionMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[collection.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *CollectionMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[collection.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *CollectionMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, collection.FieldIndexedAt)
}

// SetName sets the "name" field.
func (m *CollectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CollectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CollectionMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *CollectionMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CollectionMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CollectionMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *CollectionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CollectionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CollectionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[collection.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CollectionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[collection.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CollectionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, collection.FieldDescription)
}

// SetCoverAssetID sets the "cover_asset_id" field.
func (m *CollectionMutation) SetCoverAssetID(x xid.ID) {
	m.cover_image = &x
}

// CoverAssetID returns the value of the "cover_asset_id" field in the mutation.
func (m *CollectionMutation) CoverAssetID() (r xid.ID, exists bool) {
	v := m.cover_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverAssetID returns the old "cover_asset_id" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldCoverAssetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverAssetID: %w", err)
	}
	return oldValue.CoverAssetID, nil
}

// ClearCoverAssetID clears the value of the "cover_asset_id" field.
func (m *CollectionMutation) ClearCoverAssetID() {
	m.cover_image = nil
	m.clearedFields[collection.FieldCoverAssetID] = struct{}{}
}

// CoverAssetIDCleared returns if the "cover_asset_id" field was cleared in this mutation.
func (m *CollectionMutation) CoverAssetIDCleared() bool {
	_, ok := m.clearedFields[collection.FieldCoverAssetID]
	return ok
}

// ResetCoverAssetID resets all changes to the "cover_asset_id" field.
func (m *CollectionMutation) ResetCoverAssetID() {
	m.cover_image = nil
	delete(m.clearedFields, collection.FieldCoverAssetID)
}

// SetVisibility sets the "visibility" field.
func (m *CollectionMutation) SetVisibility(c collection.Visibility) {
	m.visibility = &c
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *CollectionMutation) Visibility() (r collection.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldVisibility(ctx context.Context) (v collection.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *CollectionMutation) ResetVisibility() {
	m.visibility = nil
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *CollectionMutation) SetOwnerID(id xid.ID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *CollectionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *CollectionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CollectionMutation) OwnerID() (id xid.ID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CollectionMutation) OwnerIDs() (ids []xid.ID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CollectionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetCoverImageID sets the "cover_image" edge to the Asset entity by id.
func (m *CollectionMutation) SetCoverImageID(id xid.ID) {
	m.cover_image = &id
}

// ClearCoverImage clears the "cover_image" edge to the Asset entity.
func (m *CollectionMutation) ClearCoverImage() {
	m.clearedcover_image = true
	m.clearedFields[collection.FieldCoverAssetID] = struct{}{}
}

// CoverImageCleared reports if the "cover_image" edge to the Asset entity was cleared.
func (m *CollectionMutation) CoverImageCleared() bool {
	return m.CoverAssetIDCleared() || m.clearedcover_image
}

// CoverImageID returns the "cover_image" edge ID in the mutation.
func (m *CollectionMutation) CoverImageID() (id xid.ID, exists bool) {
	if m.cover_image != nil {
		return *m.cover_image, true
	}
	return
}

// CoverImageIDs returns the "cover_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoverImageID instead. It exists only for internal usage by the builders.
func (m *CollectionMutation) CoverImageIDs() (ids []xid.ID) {
	if id := m.cover_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoverImage resets all changes to the "cover_image" edge.
func (m *CollectionMutation) ResetCoverImage() {
	m.cover_image = nil
	m.clearedcover_image = false
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *CollectionMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *CollectionMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *CollectionMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *CollectionMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *CollectionMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *CollectionMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *CollectionMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *CollectionMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *CollectionMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *CollectionMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *CollectionMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *CollectionMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *CollectionMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *CollectionMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// Where appends a list predicates to the CollectionMutation builder.
func (m *CollectionMutation) Where(ps ...predicate.Collection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Collection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Collection).
func (m *CollectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, collection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, collection.FieldUpdatedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, collection.FieldIndexedAt)
	}
	if m.name != nil {
		fields = append(fields, collection.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, collection.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, collection.FieldDescription)
	}
	if m.cover_image != nil {
		fields = append(fields, collection.FieldCoverAssetID)
	}
	if m.visibility != nil {
		fields = append(fields, collection.FieldVisibility)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collection.FieldCreatedAt:
		return m.CreatedAt()
	case collection.FieldUpdatedAt:
		return m.UpdatedAt()
	case collection.FieldIndexedAt:
		return m.IndexedAt()
	case collection.FieldName:
		return m.Name()
	case collection.FieldSlug:
		return m.Slug()
	case collection.FieldDescription:
		return m.Description()
	case collection.FieldCoverAssetID:
		return m.CoverAssetID()
	case collection.FieldVisibility:
		return m.Visibility()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case collection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case collection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case collection.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case collection.FieldName:
		return m.OldName(ctx)
	case collection.FieldSlug:
		return m.OldSlug(ctx)
	case collection.FieldDescription:
		return m.OldDescription(ctx)
	case collection.FieldCoverAssetID:
		return m.OldCoverAssetID(ctx)
	case collection.FieldVisibility:
		return m.OldVisibility(ctx)
	}
	return nil, fmt.Errorf("unknown Collection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case collection.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case collection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case collection.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case collection.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case collection.FieldCoverAssetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverAssetID(v)
		return nil
	case collection.FieldVisibility:
		v, ok := value.(collection.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Collection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(collection.FieldIndexedAt) {
		fields = append(fields, collection.FieldIndexedAt)
	}
	if m.FieldCleared(collection.FieldDescription) {
		fields = append(fields, collection.FieldDescription)
	}
	if m.FieldCleared(collection.FieldCoverAssetID) {
		fields = append(fields, collection.FieldCoverAssetID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectionMutation) ClearField(name string) error {
	switch name {
	case collection.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case collection.FieldDescription:
		m.ClearDescription()
		return nil
	case collection.FieldCoverAssetID:
		m.ClearCoverAssetID()
		return nil
	}
	return fmt.Errorf("unknown Collection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectionMutation) ResetField(name string) error {
	switch name {
	case collection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case collection.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case collection.FieldName:
		m.ResetName()
		return nil
	case collection.FieldSlug:
		m.ResetSlug()
		return nil
	case collection.FieldDescription:
		m.ResetDescription()
		return nil
	case collection.FieldCoverAssetID:
		m.ResetCoverAssetID()
		return nil
	case collection.FieldVisibility:
		m.ResetVisibility()
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, collection.EdgeOwner)
	}
	if m.cover_image != nil {
		edges = append(edges, collection.EdgeCoverImage)
	}
	if m.posts != nil {
		edges = append(edges, collection.EdgePosts)
	}
	if m.nodes != nil {
		edges = append(edges, collection.EdgeNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collection.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case collection.EdgeCoverImage:
		if id := m.cover_image; id != nil {
			return []ent.Value{*id}
		}
	case collection.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedposts != nil {
		edges = append(edges, collection.EdgePosts)
	}
	if m.removednodes != nil {
		edges = append(edges, collection.EdgeNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case collection.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case collection.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, collection.EdgeOwner)
	}
	if m.clearedcover_image {
		edges = append(edges, collection.EdgeCoverImage)
	}
	if m.clearedposts {
		edges = append(edges, collection.EdgePosts)
	}
	if m.clearednodes {
		edges = append(edges, collection.EdgeNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectionMutation) EdgeCleared(name string) bool {
	switch name {
	case collection.EdgeOwner:
		return m.clearedowner
	case collection.EdgeCoverImage:
		return m.clearedcover_image
	case collection.EdgePosts:
		return m.clearedposts
	case collection.EdgeNodes:
		return m.clearednodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectionMutation) ClearEdge(name string) error {
	switch name {
	case collection.EdgeOwner:
		m.ClearOwner()
		return nil
	case collection.EdgeCoverImage:
		m.ClearCoverImage()
		return nil
	}
	return fmt.Errorf("unknown Collection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectionMutation) ResetEdge(name string) error {
	switch name {
	case collection.EdgeOwner:
		m.ResetOwner()
		return nil
	case collection.EdgeCoverImage:
		m.ResetCoverImage()
		return nil
	case collection.EdgePosts:
		m.ResetPosts()
		return nil
	case collection.EdgeNodes:
		m.ResetNodes()
		return nil
	}
	return fmt.Errorf("unknown Collection edge %s", name)
}

// CollectionNodeMutation represents an operation that mutates the CollectionNode nodes in the graph.
type CollectionNodeMutation struct {
	config
	op                Op
	typ               string
	created_at        *time.Time
	membership_type   *string
	clearedFields     map[string]struct{}
	collection        *xid.ID
	clearedcollection bool
	node              *xid.ID
	clearednode       bool
	done              bool
	oldValue          func(context.Context) (*CollectionNode, error)
	predicates        []predicate.CollectionNode
}

var _ ent.Mutation = (*CollectionNodeMutation)(nil)

// collectionnodeOption allows management of the mutation configuration using functional options.
type collectionnodeOption func(*CollectionNodeMutation)

// newCollectionNodeMutation creates new mutation for the CollectionNode entity.
func newCollectionNodeMutation(c config, op Op, opts ...collectionnodeOption) *CollectionNodeMutation {
	m := &CollectionNodeMutation{
		config:        c,
		op:            op,
		typ:           TypeCollectionNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectionNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectionNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectionNodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectionNodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectionNodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCollectionID sets the "collection_id" field.
func (m *CollectionNodeMutation) SetCollectionID(x xid.ID) {
	m.collection = &x
}

// CollectionID returns the value of the "collection_id" field in the mutation.
func (m *CollectionNodeMutation) CollectionID() (r xid.ID, exists bool) {
	v := m.collection
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectionID resets all changes to the "collection_id" field.
func (m *CollectionNodeMutation) ResetCollectionID() {
	m.collection = nil
}

// SetNodeID sets the "node_id" field.
func (m *CollectionNodeMutation) SetNodeID(x xid.ID) {
	m.node = &x
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *CollectionNodeMutation) NodeID() (r xid.ID, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *CollectionNodeMutation) ResetNodeID() {
	m.node = nil
}

// SetMembershipType sets the "membership_type" field.
func (m *CollectionNodeMutation) SetMembershipType(s string) {
	m.membership_type = &s
}

// MembershipType returns the value of the "membership_type" field in the mutation.
func (m *CollectionNodeMutation) MembershipType() (r string, exists bool) {
	v := m.membership_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetMembershipType resets all changes to the "membership_type" field.
func (m *CollectionNodeMutation) ResetMembershipType() {
	m.membership_type = nil
}

// ClearCollection clears the "collection" edge to the Collection entity.
func (m *CollectionNodeMutation) ClearCollection() {
	m.clearedcollection = true
	m.clearedFields[collectionnode.FieldCollectionID] = struct{}{}
}

// CollectionCleared reports if the "collection" edge to the Collection entity was cleared.
func (m *CollectionNodeMutation) CollectionCleared() bool {
	return m.clearedcollection
}

// CollectionIDs returns the "collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollectionID instead. It exists only for internal usage by the builders.
func (m *CollectionNodeMutation) CollectionIDs() (ids []xid.ID) {
	if id := m.collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollection resets all changes to the "collection" edge.
func (m *CollectionNodeMutation) ResetCollection() {
	m.collection = nil
	m.clearedcollection = false
}

// ClearNode clears the "node" edge to the Node entity.
func (m *CollectionNodeMutation) ClearNode() {
	m.clearednode = true
	m.clearedFields[collectionnode.FieldNodeID] = struct{}{}
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *CollectionNodeMutation) NodeCleared() bool {
	return m.clearednode
}

// NodeIDs returns the "node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeID instead. It exists only for internal usage by the builders.
func (m *CollectionNodeMutation) NodeIDs() (ids []xid.ID) {
	if id := m.node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *CollectionNodeMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
}

// Where appends a list predicates to the CollectionNodeMutation builder.
func (m *CollectionNodeMutation) Where(ps ...predicate.CollectionNode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollectionNodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollectionNodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CollectionNode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollectionNodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollectionNodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CollectionNode).
func (m *CollectionNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectionNodeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, collectionnode.FieldCreatedAt)
	}
	if m.collection != nil {
		fields = append(fields, collectionnode.FieldCollectionID)
	}
	if m.node != nil {
		fields = append(fields, collectionnode.FieldNodeID)
	}
	if m.membership_type != nil {
		fields = append(fields, collectionnode.FieldMembershipType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectionNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collectionnode.FieldCreatedAt:
		return m.CreatedAt()
	case collectionnode.FieldCollectionID:
		return m.CollectionID()
	case collectionnode.FieldNodeID:
		return m.NodeID()
	case collectionnode.FieldMembershipType:
		return m.MembershipType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectionNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema CollectionNode does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collectionnode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collectionnode.FieldCollectionID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionID(v)
		return nil
	case collectionnode.FieldNodeID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case collectionnode.FieldMembershipType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembershipType(v)
		return nil
	}
	return fmt.Errorf("unknown CollectionNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectionNodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectionNodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CollectionNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectionNodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectionNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectionNodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CollectionNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectionNodeMutation) ResetField(name string) error {
	switch name {
	case collectionnode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collectionnode.FieldCollectionID:
		m.ResetCollectionID()
		return nil
	case collectionnode.FieldNodeID:
		m.ResetNodeID()
		return nil
	case collectionnode.FieldMembershipType:
		m.ResetMembershipType()
		return nil
	}
	return fmt.Errorf("unknown CollectionNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectionNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.collection != nil {
		edges = append(edges, collectionnode.EdgeCollection)
	}
	if m.node != nil {
		edges = append(edges, collectionnode.EdgeNode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectionNodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collectionnode.EdgeCollection:
		if id := m.collection; id != nil {
			return []ent.Value{*id}
		}
	case collectionnode.EdgeNode:
		if id := m.node; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectionNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectionNodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectionNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcollection {
		edges = append(edges, collectionnode.EdgeCollection)
	}
	if m.clearednode {
		edges = append(edges, collectionnode.EdgeNode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectionNodeMutation) EdgeCleared(name string) bool {
	switch name {
	case collectionnode.EdgeCollection:
		return m.clearedcollection
	case collectionnode.EdgeNode:
		return m.clearednode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectionNodeMutation) ClearEdge(name string) error {
	switch name {
	case collectionnode.EdgeCollection:
		m.ClearCollection()
		return nil
	case collectionnode.EdgeNode:
		m.ClearNode()
		return nil
	}
	return fmt.Errorf("unknown CollectionNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectionNodeMutation) ResetEdge(name string) error {
	switch name {
	case collectionnode.EdgeCollection:
		m.ResetCollection()
		return nil
	case collectionnode.EdgeNode:
		m.ResetNode()
		return nil
	}
	return fmt.Errorf("unknown CollectionNode edge %s", name)
}

// CollectionPostMutation represents an operation that mutates the CollectionPost nodes in the graph.
type CollectionPostMutation struct {
	config
	op                Op
	typ               string
	created_at        *time.Time
	membership_type   *string
	clearedFields     map[string]struct{}
	collection        *xid.ID
	clearedcollection bool
	post              *xid.ID
	clearedpost       bool
	done              bool
	oldValue          func(context.Context) (*CollectionPost, error)
	predicates        []predicate.CollectionPost
}

var _ ent.Mutation = (*CollectionPostMutation)(nil)

// collectionpostOption allows management of the mutation configuration using functional options.
type collectionpostOption func(*CollectionPostMutation)

// newCollectionPostMutation creates new mutation for the CollectionPost entity.
func newCollectionPostMutation(c config, op Op, opts ...collectionpostOption) *CollectionPostMutation {
	m := &CollectionPostMutation{
		config:        c,
		op:            op,
		typ:           TypeCollectionPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectionPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectionPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectionPostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectionPostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectionPostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCollectionID sets the "collection_id" field.
func (m *CollectionPostMutation) SetCollectionID(x xid.ID) {
	m.collection = &x
}

// CollectionID returns the value of the "collection_id" field in the mutation.
func (m *CollectionPostMutation) CollectionID() (r xid.ID, exists bool) {
	v := m.collection
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectionID resets all changes to the "collection_id" field.
func (m *CollectionPostMutation) ResetCollectionID() {
	m.collection = nil
}

// SetPostID sets the "post_id" field.
func (m *CollectionPostMutation) SetPostID(x xid.ID) {
	m.post = &x
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *CollectionPostMutation) PostID() (r xid.ID, exists bool) {
	v := m.post
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostID resets all changes to the "post_id" field.
func (m *CollectionPostMutation) ResetPostID() {
	m.post = nil
}

// SetMembershipType sets the "membership_type" field.
func (m *CollectionPostMutation) SetMembershipType(s string) {
	m.membership_type = &s
}

// MembershipType returns the value of the "membership_type" field in the mutation.
func (m *CollectionPostMutation) MembershipType() (r string, exists bool) {
	v := m.membership_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetMembershipType resets all changes to the "membership_type" field.
func (m *CollectionPostMutation) ResetMembershipType() {
	m.membership_type = nil
}

// ClearCollection clears the "collection" edge to the Collection entity.
func (m *CollectionPostMutation) ClearCollection() {
	m.clearedcollection = true
	m.clearedFields[collectionpost.FieldCollectionID] = struct{}{}
}

// CollectionCleared reports if the "collection" edge to the Collection entity was cleared.
func (m *CollectionPostMutation) CollectionCleared() bool {
	return m.clearedcollection
}

// CollectionIDs returns the "collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CollectionID instead. It exists only for internal usage by the builders.
func (m *CollectionPostMutation) CollectionIDs() (ids []xid.ID) {
	if id := m.collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCollection resets all changes to the "collection" edge.
func (m *CollectionPostMutation) ResetCollection() {
	m.collection = nil
	m.clearedcollection = false
}

// ClearPost clears the "post" edge to the Post entity.
func (m *CollectionPostMutation) ClearPost() {
	m.clearedpost = true
	m.clearedFields[collectionpost.FieldPostID] = struct{}{}
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *CollectionPostMutation) PostCleared() bool {
	return m.clearedpost
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *CollectionPostMutation) PostIDs() (ids []xid.ID) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *CollectionPostMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the CollectionPostMutation builder.
func (m *CollectionPostMutation) Where(ps ...predicate.CollectionPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CollectionPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CollectionPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CollectionPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CollectionPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CollectionPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CollectionPost).
func (m *CollectionPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectionPostMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, collectionpost.FieldCreatedAt)
	}
	if m.collection != nil {
		fields = append(fields, collectionpost.FieldCollectionID)
	}
	if m.post != nil {
		fields = append(fields, collectionpost.FieldPostID)
	}
	if m.membership_type != nil {
		fields = append(fields, collectionpost.FieldMembershipType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectionPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collectionpost.FieldCreatedAt:
		return m.CreatedAt()
	case collectionpost.FieldCollectionID:
		return m.CollectionID()
	case collectionpost.FieldPostID:
		return m.PostID()
	case collectionpost.FieldMembershipType:
		return m.MembershipType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectionPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema CollectionPost does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collectionpost.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collectionpost.FieldCollectionID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionID(v)
		return nil
	case collectionpost.FieldPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case collectionpost.FieldMembershipType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembershipType(v)
		return nil
	}
	return fmt.Errorf("unknown CollectionPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectionPostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectionPostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CollectionPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectionPostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectionPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectionPostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CollectionPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectionPostMutation) ResetField(name string) error {
	switch name {
	case collectionpost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collectionpost.FieldCollectionID:
		m.ResetCollectionID()
		return nil
	case collectionpost.FieldPostID:
		m.ResetPostID()
		return nil
	case collectionpost.FieldMembershipType:
		m.ResetMembershipType()
		return nil
	}
	return fmt.Errorf("unknown CollectionPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectionPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.collection != nil {
		edges = append(edges, collectionpost.EdgeCollection)
	}
	if m.post != nil {
		edges = append(edges, collectionpost.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectionPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collectionpost.EdgeCollection:
		if id := m.collection; id != nil {
			return []ent.Value{*id}
		}
	case collectionpost.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectionPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectionPostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectionPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcollection {
		edges = append(edges, collectionpost.EdgeCollection)
	}
	if m.clearedpost {
		edges = append(edges, collectionpost.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectionPostMutation) EdgeCleared(name string) bool {
	switch name {
	case collectionpost.EdgeCollection:
		return m.clearedcollection
	case collectionpost.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectionPostMutation) ClearEdge(name string) error {
	switch name {
	case collectionpost.EdgeCollection:
		m.ClearCollection()
		return nil
	case collectionpost.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown CollectionPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectionPostMutation) ResetEdge(name string) error {
	switch name {
	case collectionpost.EdgeCollection:
		m.ResetCollection()
		return nil
	case collectionpost.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown CollectionPost edge %s", name)
}

// EmailMutation represents an operation that mutates the Email nodes in the graph.
type EmailMutation struct {
	config
	op                Op
	typ               string
	id                *xid.ID
	created_at        *time.Time
	email_address     *string
	verification_code *string
	verified          *bool
	clearedFields     map[string]struct{}
	account           *xid.ID
	clearedaccount    bool
	done              bool
	oldValue          func(context.Context) (*Email, error)
	predicates        []predicate.Email
}

var _ ent.Mutation = (*EmailMutation)(nil)

// emailOption allows management of the mutation configuration using functional options.
type emailOption func(*EmailMutation)

// newEmailMutation creates new mutation for the Email entity.
func newEmailMutation(c config, op Op, opts ...emailOption) *EmailMutation {
	m := &EmailMutation{
		config:        c,
		op:            op,
		typ:           TypeEmail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailID sets the ID field of the mutation.
func withEmailID(id xid.ID) emailOption {
	return func(m *EmailMutation) {
		var (
			err   error
			once  sync.Once
			value *Email
		)
		m.oldValue = func(ctx context.Context) (*Email, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Email.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmail sets the old Email of the mutation.
func withEmail(node *Email) emailOption {
	return func(m *EmailMutation) {
		m.oldValue = func(context.Context) (*Email, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Email entities.
func (m *EmailMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Email.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountID sets the "account_id" field.
func (m *EmailMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *EmailMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldAccountID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *EmailMutation) ClearAccountID() {
	m.account = nil
	m.clearedFields[email.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *EmailMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[email.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *EmailMutation) ResetAccountID() {
	m.account = nil
	delete(m.clearedFields, email.FieldAccountID)
}

// SetEmailAddress sets the "email_address" field.
func (m *EmailMutation) SetEmailAddress(s string) {
	m.email_address = &s
}

// EmailAddress returns the value of the "email_address" field in the mutation.
func (m *EmailMutation) EmailAddress() (r string, exists bool) {
	v := m.email_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddress returns the old "email_address" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldEmailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddress: %w", err)
	}
	return oldValue.EmailAddress, nil
}

// ResetEmailAddress resets all changes to the "email_address" field.
func (m *EmailMutation) ResetEmailAddress() {
	m.email_address = nil
}

// SetVerificationCode sets the "verification_code" field.
func (m *EmailMutation) SetVerificationCode(s string) {
	m.verification_code = &s
}

// VerificationCode returns the value of the "verification_code" field in the mutation.
func (m *EmailMutation) VerificationCode() (r string, exists bool) {
	v := m.verification_code
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationCode returns the old "verification_code" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldVerificationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationCode: %w", err)
	}
	return oldValue.VerificationCode, nil
}

// ResetVerificationCode resets all changes to the "verification_code" field.
func (m *EmailMutation) ResetVerificationCode() {
	m.verification_code = nil
}

// SetVerified sets the "verified" field.
func (m *EmailMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *EmailMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *EmailMutation) ResetVerified() {
	m.verified = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *EmailMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[email.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *EmailMutation) AccountCleared() bool {
	return m.AccountIDCleared() || m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *EmailMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *EmailMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the EmailMutation builder.
func (m *EmailMutation) Where(ps ...predicate.Email) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Email, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Email).
func (m *EmailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, email.FieldCreatedAt)
	}
	if m.account != nil {
		fields = append(fields, email.FieldAccountID)
	}
	if m.email_address != nil {
		fields = append(fields, email.FieldEmailAddress)
	}
	if m.verification_code != nil {
		fields = append(fields, email.FieldVerificationCode)
	}
	if m.verified != nil {
		fields = append(fields, email.FieldVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case email.FieldCreatedAt:
		return m.CreatedAt()
	case email.FieldAccountID:
		return m.AccountID()
	case email.FieldEmailAddress:
		return m.EmailAddress()
	case email.FieldVerificationCode:
		return m.VerificationCode()
	case email.FieldVerified:
		return m.Verified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case email.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case email.FieldAccountID:
		return m.OldAccountID(ctx)
	case email.FieldEmailAddress:
		return m.OldEmailAddress(ctx)
	case email.FieldVerificationCode:
		return m.OldVerificationCode(ctx)
	case email.FieldVerified:
		return m.OldVerified(ctx)
	}
	return nil, fmt.Errorf("unknown Email field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case email.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case email.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case email.FieldEmailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddress(v)
		return nil
	case email.FieldVerificationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationCode(v)
		return nil
	case email.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Email numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(email.FieldAccountID) {
		fields = append(fields, email.FieldAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailMutation) ClearField(name string) error {
	switch name {
	case email.FieldAccountID:
		m.ClearAccountID()
		return nil
	}
	return fmt.Errorf("unknown Email nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailMutation) ResetField(name string) error {
	switch name {
	case email.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case email.FieldAccountID:
		m.ResetAccountID()
		return nil
	case email.FieldEmailAddress:
		m.ResetEmailAddress()
		return nil
	case email.FieldVerificationCode:
		m.ResetVerificationCode()
		return nil
	case email.FieldVerified:
		m.ResetVerified()
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.account != nil {
		edges = append(edges, email.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case email.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccount {
		edges = append(edges, email.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailMutation) EdgeCleared(name string) bool {
	switch name {
	case email.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailMutation) ClearEdge(name string) error {
	switch name {
	case email.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Email unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailMutation) ResetEdge(name string) error {
	switch name {
	case email.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown Email edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                    Op
	typ                   string
	id                    *xid.ID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	indexed_at            *time.Time
	name                  *string
	slug                  *string
	description           *string
	start_time            *time.Time
	end_time              *time.Time
	participation_policy  *string
	visibility            *event.Visibility
	location_type         *string
	location_name         *string
	location_address      *string
	location_latitude     *float64
	addlocation_latitude  *float64
	location_longitude    *float64
	addlocation_longitude *float64
	location_url          *string
	capacity              *int
	addcapacity           *int
	metadata              *map[string]interface{}
	clearedFields         map[string]struct{}
	participants          map[xid.ID]struct{}
	removedparticipants   map[xid.ID]struct{}
	clearedparticipants   bool
	thread                *xid.ID
	clearedthread         bool
	primary_image         *xid.ID
	clearedprimary_image  bool
	done                  bool
	oldValue              func(context.Context) (*Event, error)
	predicates            []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id xid.ID) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[event.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[event.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, event.FieldDeletedAt)
}

// SetIndexedAt sets the "indexed_at" field.
func (m *EventMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *EventMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *EventMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[event.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *EventMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[event.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *EventMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, event.FieldIndexedAt)
}

// SetName sets the "name" field.
func (m *EventMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EventMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EventMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *EventMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *EventMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *EventMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *EventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[event.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[event.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, event.FieldDescription)
}

// SetStartTime sets the "start_time" field.
func (m *EventMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *EventMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *EventMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *EventMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *EventMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *EventMutation) ResetEndTime() {
	m.end_time = nil
}

// SetParticipationPolicy sets the "participation_policy" field.
func (m *EventMutation) SetParticipationPolicy(s string) {
	m.participation_policy = &s
}

// ParticipationPolicy returns the value of the "participation_policy" field in the mutation.
func (m *EventMutation) ParticipationPolicy() (r string, exists bool) {
	v := m.participation_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipationPolicy returns the old "participation_policy" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldParticipationPolicy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParticipationPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParticipationPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipationPolicy: %w", err)
	}
	return oldValue.ParticipationPolicy, nil
}

// ResetParticipationPolicy resets all changes to the "participation_policy" field.
func (m *EventMutation) ResetParticipationPolicy() {
	m.participation_policy = nil
}

// SetVisibility sets the "visibility" field.
func (m *EventMutation) SetVisibility(e event.Visibility) {
	m.visibility = &e
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *EventMutation) Visibility() (r event.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVisibility(ctx context.Context) (v event.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *EventMutation) ResetVisibility() {
	m.visibility = nil
}

// SetLocationType sets the "location_type" field.
func (m *EventMutation) SetLocationType(s string) {
	m.location_type = &s
}

// LocationType returns the value of the "location_type" field in the mutation.
func (m *EventMutation) LocationType() (r string, exists bool) {
	v := m.location_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationType returns the old "location_type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationType: %w", err)
	}
	return oldValue.LocationType, nil
}

// ClearLocationType clears the value of the "location_type" field.
func (m *EventMutation) ClearLocationType() {
	m.location_type = nil
	m.clearedFields[event.FieldLocationType] = struct{}{}
}

// LocationTypeCleared returns if the "location_type" field was cleared in this mutation.
func (m *EventMutation) LocationTypeCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationType]
	return ok
}

// ResetLocationType resets all changes to the "location_type" field.
func (m *EventMutation) ResetLocationType() {
	m.location_type = nil
	delete(m.clearedFields, event.FieldLocationType)
}

// SetLocationName sets the "location_name" field.
func (m *EventMutation) SetLocationName(s string) {
	m.location_name = &s
}

// LocationName returns the value of the "location_name" field in the mutation.
func (m *EventMutation) LocationName() (r string, exists bool) {
	v := m.location_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationName returns the old "location_name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationName: %w", err)
	}
	return oldValue.LocationName, nil
}

// ClearLocationName clears the value of the "location_name" field.
func (m *EventMutation) ClearLocationName() {
	m.location_name = nil
	m.clearedFields[event.FieldLocationName] = struct{}{}
}

// LocationNameCleared returns if the "location_name" field was cleared in this mutation.
func (m *EventMutation) LocationNameCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationName]
	return ok
}

// ResetLocationName resets all changes to the "location_name" field.
func (m *EventMutation) ResetLocationName() {
	m.location_name = nil
	delete(m.clearedFields, event.FieldLocationName)
}

// SetLocationAddress sets the "location_address" field.
func (m *EventMutation) SetLocationAddress(s string) {
	m.location_address = &s
}

// LocationAddress returns the value of the "location_address" field in the mutation.
func (m *EventMutation) LocationAddress() (r string, exists bool) {
	v := m.location_address
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationAddress returns the old "location_address" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationAddress: %w", err)
	}
	return oldValue.LocationAddress, nil
}

// ClearLocationAddress clears the value of the "location_address" field.
func (m *EventMutation) ClearLocationAddress() {
	m.location_address = nil
	m.clearedFields[event.FieldLocationAddress] = struct{}{}
}

// LocationAddressCleared returns if the "location_address" field was cleared in this mutation.
func (m *EventMutation) LocationAddressCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationAddress]
	return ok
}

// ResetLocationAddress resets all changes to the "location_address" field.
func (m *EventMutation) ResetLocationAddress() {
	m.location_address = nil
	delete(m.clearedFields, event.FieldLocationAddress)
}

// SetLocationLatitude sets the "location_latitude" field.
func (m *EventMutation) SetLocationLatitude(f float64) {
	m.location_latitude = &f
	m.addlocation_latitude = nil
}

// LocationLatitude returns the value of the "location_latitude" field in the mutation.
func (m *EventMutation) LocationLatitude() (r float64, exists bool) {
	v := m.location_latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationLatitude returns the old "location_latitude" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationLatitude: %w", err)
	}
	return oldValue.LocationLatitude, nil
}

// AddLocationLatitude adds f to the "location_latitude" field.
func (m *EventMutation) AddLocationLatitude(f float64) {
	if m.addlocation_latitude != nil {
		*m.addlocation_latitude += f
	} else {
		m.addlocation_latitude = &f
	}
}

// AddedLocationLatitude returns the value that was added to the "location_latitude" field in this mutation.
func (m *EventMutation) AddedLocationLatitude() (r float64, exists bool) {
	v := m.addlocation_latitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocationLatitude clears the value of the "location_latitude" field.
func (m *EventMutation) ClearLocationLatitude() {
	m.location_latitude = nil
	m.addlocation_latitude = nil
	m.clearedFields[event.FieldLocationLatitude] = struct{}{}
}

// LocationLatitudeCleared returns if the "location_latitude" field was cleared in this mutation.
func (m *EventMutation) LocationLatitudeCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationLatitude]
	return ok
}

// ResetLocationLatitude resets all changes to the "location_latitude" field.
func (m *EventMutation) ResetLocationLatitude() {
	m.location_latitude = nil
	m.addlocation_latitude = nil
	delete(m.clearedFields, event.FieldLocationLatitude)
}

// SetLocationLongitude sets the "location_longitude" field.
func (m *EventMutation) SetLocationLongitude(f float64) {
	m.location_longitude = &f
	m.addlocation_longitude = nil
}

// LocationLongitude returns the value of the "location_longitude" field in the mutation.
func (m *EventMutation) LocationLongitude() (r float64, exists bool) {
	v := m.location_longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationLongitude returns the old "location_longitude" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationLongitude: %w", err)
	}
	return oldValue.LocationLongitude, nil
}

// AddLocationLongitude adds f to the "location_longitude" field.
func (m *EventMutation) AddLocationLongitude(f float64) {
	if m.addlocation_longitude != nil {
		*m.addlocation_longitude += f
	} else {
		m.addlocation_longitude = &f
	}
}

// AddedLocationLongitude returns the value that was added to the "location_longitude" field in this mutation.
func (m *EventMutation) AddedLocationLongitude() (r float64, exists bool) {
	v := m.addlocation_longitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocationLongitude clears the value of the "location_longitude" field.
func (m *EventMutation) ClearLocationLongitude() {
	m.location_longitude = nil
	m.addlocation_longitude = nil
	m.clearedFields[event.FieldLocationLongitude] = struct{}{}
}

// LocationLongitudeCleared returns if the "location_longitude" field was cleared in this mutation.
func (m *EventMutation) LocationLongitudeCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationLongitude]
	return ok
}

// ResetLocationLongitude resets all changes to the "location_longitude" field.
func (m *EventMutation) ResetLocationLongitude() {
	m.location_longitude = nil
	m.addlocation_longitude = nil
	delete(m.clearedFields, event.FieldLocationLongitude)
}

// SetLocationURL sets the "location_url" field.
func (m *EventMutation) SetLocationURL(s string) {
	m.location_url = &s
}

// LocationURL returns the value of the "location_url" field in the mutation.
func (m *EventMutation) LocationURL() (r string, exists bool) {
	v := m.location_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationURL returns the old "location_url" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationURL: %w", err)
	}
	return oldValue.LocationURL, nil
}

// ClearLocationURL clears the value of the "location_url" field.
func (m *EventMutation) ClearLocationURL() {
	m.location_url = nil
	m.clearedFields[event.FieldLocationURL] = struct{}{}
}

// LocationURLCleared returns if the "location_url" field was cleared in this mutation.
func (m *EventMutation) LocationURLCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationURL]
	return ok
}

// ResetLocationURL resets all changes to the "location_url" field.
func (m *EventMutation) ResetLocationURL() {
	m.location_url = nil
	delete(m.clearedFields, event.FieldLocationURL)
}

// SetCapacity sets the "capacity" field.
func (m *EventMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *EventMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCapacity(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *EventMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *EventMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCapacity clears the value of the "capacity" field.
func (m *EventMutation) ClearCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	m.clearedFields[event.FieldCapacity] = struct{}{}
}

// CapacityCleared returns if the "capacity" field was cleared in this mutation.
func (m *EventMutation) CapacityCleared() bool {
	_, ok := m.clearedFields[event.FieldCapacity]
	return ok
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *EventMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	delete(m.clearedFields, event.FieldCapacity)
}

// SetMetadata sets the "metadata" field.
func (m *EventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[event.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[event.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, event.FieldMetadata)
}

// AddParticipantIDs adds the "participants" edge to the EventParticipant entity by ids.
func (m *EventMutation) AddParticipantIDs(ids ...xid.ID) {
	if m.participants == nil {
		m.participants = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the EventParticipant entity.
func (m *EventMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the EventParticipant entity was cleared.
func (m *EventMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the EventParticipant entity by IDs.
func (m *EventMutation) RemoveParticipantIDs(ids ...xid.ID) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the EventParticipant entity.
func (m *EventMutation) RemovedParticipantsIDs() (ids []xid.ID) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *EventMutation) ParticipantsIDs() (ids []xid.ID) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *EventMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// SetThreadID sets the "thread" edge to the Post entity by id.
func (m *EventMutation) SetThreadID(id xid.ID) {
	m.thread = &id
}

// ClearThread clears the "thread" edge to the Post entity.
func (m *EventMutation) ClearThread() {
	m.clearedthread = true
}

// ThreadCleared reports if the "thread" edge to the Post entity was cleared.
func (m *EventMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadID returns the "thread" edge ID in the mutation.
func (m *EventMutation) ThreadID() (id xid.ID, exists bool) {
	if m.thread != nil {
		return *m.thread, true
	}
	return
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *EventMutation) ThreadIDs() (ids []xid.ID) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *EventMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// SetPrimaryImageID sets the "primary_image" edge to the Asset entity by id.
func (m *EventMutation) SetPrimaryImageID(id xid.ID) {
	m.primary_image = &id
}

// ClearPrimaryImage clears the "primary_image" edge to the Asset entity.
func (m *EventMutation) ClearPrimaryImage() {
	m.clearedprimary_image = true
}

// PrimaryImageCleared reports if the "primary_image" edge to the Asset entity was cleared.
func (m *EventMutation) PrimaryImageCleared() bool {
	return m.clearedprimary_image
}

// PrimaryImageID returns the "primary_image" edge ID in the mutation.
func (m *EventMutation) PrimaryImageID() (id xid.ID, exists bool) {
	if m.primary_image != nil {
		return *m.primary_image, true
	}
	return
}

// PrimaryImageIDs returns the "primary_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryImageID instead. It exists only for internal usage by the builders.
func (m *EventMutation) PrimaryImageIDs() (ids []xid.ID) {
	if id := m.primary_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryImage resets all changes to the "primary_image" edge.
func (m *EventMutation) ResetPrimaryImage() {
	m.primary_image = nil
	m.clearedprimary_image = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, event.FieldIndexedAt)
	}
	if m.name != nil {
		fields = append(fields, event.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, event.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, event.FieldDescription)
	}
	if m.start_time != nil {
		fields = append(fields, event.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, event.FieldEndTime)
	}
	if m.participation_policy != nil {
		fields = append(fields, event.FieldParticipationPolicy)
	}
	if m.visibility != nil {
		fields = append(fields, event.FieldVisibility)
	}
	if m.location_type != nil {
		fields = append(fields, event.FieldLocationType)
	}
	if m.location_name != nil {
		fields = append(fields, event.FieldLocationName)
	}
	if m.location_address != nil {
		fields = append(fields, event.FieldLocationAddress)
	}
	if m.location_latitude != nil {
		fields = append(fields, event.FieldLocationLatitude)
	}
	if m.location_longitude != nil {
		fields = append(fields, event.FieldLocationLongitude)
	}
	if m.location_url != nil {
		fields = append(fields, event.FieldLocationURL)
	}
	if m.capacity != nil {
		fields = append(fields, event.FieldCapacity)
	}
	if m.metadata != nil {
		fields = append(fields, event.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldDeletedAt:
		return m.DeletedAt()
	case event.FieldIndexedAt:
		return m.IndexedAt()
	case event.FieldName:
		return m.Name()
	case event.FieldSlug:
		return m.Slug()
	case event.FieldDescription:
		return m.Description()
	case event.FieldStartTime:
		return m.StartTime()
	case event.FieldEndTime:
		return m.EndTime()
	case event.FieldParticipationPolicy:
		return m.ParticipationPolicy()
	case event.FieldVisibility:
		return m.Visibility()
	case event.FieldLocationType:
		return m.LocationType()
	case event.FieldLocationName:
		return m.LocationName()
	case event.FieldLocationAddress:
		return m.LocationAddress()
	case event.FieldLocationLatitude:
		return m.LocationLatitude()
	case event.FieldLocationLongitude:
		return m.LocationLongitude()
	case event.FieldLocationURL:
		return m.LocationURL()
	case event.FieldCapacity:
		return m.Capacity()
	case event.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case event.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case event.FieldName:
		return m.OldName(ctx)
	case event.FieldSlug:
		return m.OldSlug(ctx)
	case event.FieldDescription:
		return m.OldDescription(ctx)
	case event.FieldStartTime:
		return m.OldStartTime(ctx)
	case event.FieldEndTime:
		return m.OldEndTime(ctx)
	case event.FieldParticipationPolicy:
		return m.OldParticipationPolicy(ctx)
	case event.FieldVisibility:
		return m.OldVisibility(ctx)
	case event.FieldLocationType:
		return m.OldLocationType(ctx)
	case event.FieldLocationName:
		return m.OldLocationName(ctx)
	case event.FieldLocationAddress:
		return m.OldLocationAddress(ctx)
	case event.FieldLocationLatitude:
		return m.OldLocationLatitude(ctx)
	case event.FieldLocationLongitude:
		return m.OldLocationLongitude(ctx)
	case event.FieldLocationURL:
		return m.OldLocationURL(ctx)
	case event.FieldCapacity:
		return m.OldCapacity(ctx)
	case event.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case event.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case event.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case event.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case event.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case event.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case event.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case event.FieldParticipationPolicy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipationPolicy(v)
		return nil
	case event.FieldVisibility:
		v, ok := value.(event.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case event.FieldLocationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationType(v)
		return nil
	case event.FieldLocationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationName(v)
		return nil
	case event.FieldLocationAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationAddress(v)
		return nil
	case event.FieldLocationLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationLatitude(v)
		return nil
	case event.FieldLocationLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationLongitude(v)
		return nil
	case event.FieldLocationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationURL(v)
		return nil
	case event.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case event.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addlocation_latitude != nil {
		fields = append(fields, event.FieldLocationLatitude)
	}
	if m.addlocation_longitude != nil {
		fields = append(fields, event.FieldLocationLongitude)
	}
	if m.addcapacity != nil {
		fields = append(fields, event.FieldCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldLocationLatitude:
		return m.AddedLocationLatitude()
	case event.FieldLocationLongitude:
		return m.AddedLocationLongitude()
	case event.FieldCapacity:
		return m.AddedCapacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldLocationLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationLatitude(v)
		return nil
	case event.FieldLocationLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationLongitude(v)
		return nil
	case event.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldDeletedAt) {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.FieldCleared(event.FieldIndexedAt) {
		fields = append(fields, event.FieldIndexedAt)
	}
	if m.FieldCleared(event.FieldDescription) {
		fields = append(fields, event.FieldDescription)
	}
	if m.FieldCleared(event.FieldLocationType) {
		fields = append(fields, event.FieldLocationType)
	}
	if m.FieldCleared(event.FieldLocationName) {
		fields = append(fields, event.FieldLocationName)
	}
	if m.FieldCleared(event.FieldLocationAddress) {
		fields = append(fields, event.FieldLocationAddress)
	}
	if m.FieldCleared(event.FieldLocationLatitude) {
		fields = append(fields, event.FieldLocationLatitude)
	}
	if m.FieldCleared(event.FieldLocationLongitude) {
		fields = append(fields, event.FieldLocationLongitude)
	}
	if m.FieldCleared(event.FieldLocationURL) {
		fields = append(fields, event.FieldLocationURL)
	}
	if m.FieldCleared(event.FieldCapacity) {
		fields = append(fields, event.FieldCapacity)
	}
	if m.FieldCleared(event.FieldMetadata) {
		fields = append(fields, event.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case event.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case event.FieldDescription:
		m.ClearDescription()
		return nil
	case event.FieldLocationType:
		m.ClearLocationType()
		return nil
	case event.FieldLocationName:
		m.ClearLocationName()
		return nil
	case event.FieldLocationAddress:
		m.ClearLocationAddress()
		return nil
	case event.FieldLocationLatitude:
		m.ClearLocationLatitude()
		return nil
	case event.FieldLocationLongitude:
		m.ClearLocationLongitude()
		return nil
	case event.FieldLocationURL:
		m.ClearLocationURL()
		return nil
	case event.FieldCapacity:
		m.ClearCapacity()
		return nil
	case event.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case event.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case event.FieldName:
		m.ResetName()
		return nil
	case event.FieldSlug:
		m.ResetSlug()
		return nil
	case event.FieldDescription:
		m.ResetDescription()
		return nil
	case event.FieldStartTime:
		m.ResetStartTime()
		return nil
	case event.FieldEndTime:
		m.ResetEndTime()
		return nil
	case event.FieldParticipationPolicy:
		m.ResetParticipationPolicy()
		return nil
	case event.FieldVisibility:
		m.ResetVisibility()
		return nil
	case event.FieldLocationType:
		m.ResetLocationType()
		return nil
	case event.FieldLocationName:
		m.ResetLocationName()
		return nil
	case event.FieldLocationAddress:
		m.ResetLocationAddress()
		return nil
	case event.FieldLocationLatitude:
		m.ResetLocationLatitude()
		return nil
	case event.FieldLocationLongitude:
		m.ResetLocationLongitude()
		return nil
	case event.FieldLocationURL:
		m.ResetLocationURL()
		return nil
	case event.FieldCapacity:
		m.ResetCapacity()
		return nil
	case event.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.participants != nil {
		edges = append(edges, event.EdgeParticipants)
	}
	if m.thread != nil {
		edges = append(edges, event.EdgeThread)
	}
	if m.primary_image != nil {
		edges = append(edges, event.EdgePrimaryImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgePrimaryImage:
		if id := m.primary_image; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedparticipants != nil {
		edges = append(edges, event.EdgeParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparticipants {
		edges = append(edges, event.EdgeParticipants)
	}
	if m.clearedthread {
		edges = append(edges, event.EdgeThread)
	}
	if m.clearedprimary_image {
		edges = append(edges, event.EdgePrimaryImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeParticipants:
		return m.clearedparticipants
	case event.EdgeThread:
		return m.clearedthread
	case event.EdgePrimaryImage:
		return m.clearedprimary_image
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeThread:
		m.ClearThread()
		return nil
	case event.EdgePrimaryImage:
		m.ClearPrimaryImage()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case event.EdgeThread:
		m.ResetThread()
		return nil
	case event.EdgePrimaryImage:
		m.ResetPrimaryImage()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// EventParticipantMutation represents an operation that mutates the EventParticipant nodes in the graph.
type EventParticipantMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	role           *string
	status         *string
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	event          *xid.ID
	clearedevent   bool
	done           bool
	oldValue       func(context.Context) (*EventParticipant, error)
	predicates     []predicate.EventParticipant
}

var _ ent.Mutation = (*EventParticipantMutation)(nil)

// eventparticipantOption allows management of the mutation configuration using functional options.
type eventparticipantOption func(*EventParticipantMutation)

// newEventParticipantMutation creates new mutation for the EventParticipant entity.
func newEventParticipantMutation(c config, op Op, opts ...eventparticipantOption) *EventParticipantMutation {
	m := &EventParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeEventParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventParticipantID sets the ID field of the mutation.
func withEventParticipantID(id xid.ID) eventparticipantOption {
	return func(m *EventParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *EventParticipant
		)
		m.oldValue = func(ctx context.Context) (*EventParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventParticipant sets the old EventParticipant of the mutation.
func withEventParticipant(node *EventParticipant) eventparticipantOption {
	return func(m *EventParticipantMutation) {
		m.oldValue = func(context.Context) (*EventParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventParticipant entities.
func (m *EventParticipantMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventParticipantMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventParticipantMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventParticipantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventParticipantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventParticipantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetRole sets the "role" field.
func (m *EventParticipantMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *EventParticipantMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *EventParticipantMutation) ResetRole() {
	m.role = nil
}

// SetStatus sets the "status" field.
func (m *EventParticipantMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EventParticipantMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EventParticipantMutation) ResetStatus() {
	m.status = nil
}

// SetAccountID sets the "account_id" field.
func (m *EventParticipantMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *EventParticipantMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *EventParticipantMutation) ResetAccountID() {
	m.account = nil
}

// SetEventID sets the "event_id" field.
func (m *EventParticipantMutation) SetEventID(x xid.ID) {
	m.event = &x
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *EventParticipantMutation) EventID() (r xid.ID, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the EventParticipant entity.
// If the EventParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventParticipantMutation) OldEventID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *EventParticipantMutation) ResetEventID() {
	m.event = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *EventParticipantMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[eventparticipant.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *EventParticipantMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *EventParticipantMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *EventParticipantMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *EventParticipantMutation) ClearEvent() {
	m.clearedevent = true
	m.clearedFields[eventparticipant.FieldEventID] = struct{}{}
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *EventParticipantMutation) EventCleared() bool {
	return m.clearedevent
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *EventParticipantMutation) EventIDs() (ids []xid.ID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *EventParticipantMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the EventParticipantMutation builder.
func (m *EventParticipantMutation) Where(ps ...predicate.EventParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventParticipant).
func (m *EventParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventParticipantMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, eventparticipant.FieldCreatedAt)
	}
	if m.role != nil {
		fields = append(fields, eventparticipant.FieldRole)
	}
	if m.status != nil {
		fields = append(fields, eventparticipant.FieldStatus)
	}
	if m.account != nil {
		fields = append(fields, eventparticipant.FieldAccountID)
	}
	if m.event != nil {
		fields = append(fields, eventparticipant.FieldEventID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventparticipant.FieldCreatedAt:
		return m.CreatedAt()
	case eventparticipant.FieldRole:
		return m.Role()
	case eventparticipant.FieldStatus:
		return m.Status()
	case eventparticipant.FieldAccountID:
		return m.AccountID()
	case eventparticipant.FieldEventID:
		return m.EventID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventparticipant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case eventparticipant.FieldRole:
		return m.OldRole(ctx)
	case eventparticipant.FieldStatus:
		return m.OldStatus(ctx)
	case eventparticipant.FieldAccountID:
		return m.OldAccountID(ctx)
	case eventparticipant.FieldEventID:
		return m.OldEventID(ctx)
	}
	return nil, fmt.Errorf("unknown EventParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventparticipant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case eventparticipant.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case eventparticipant.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case eventparticipant.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case eventparticipant.FieldEventID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	}
	return fmt.Errorf("unknown EventParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventParticipantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventParticipantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventParticipantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventParticipantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EventParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventParticipantMutation) ResetField(name string) error {
	switch name {
	case eventparticipant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case eventparticipant.FieldRole:
		m.ResetRole()
		return nil
	case eventparticipant.FieldStatus:
		m.ResetStatus()
		return nil
	case eventparticipant.FieldAccountID:
		m.ResetAccountID()
		return nil
	case eventparticipant.FieldEventID:
		m.ResetEventID()
		return nil
	}
	return fmt.Errorf("unknown EventParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, eventparticipant.EdgeAccount)
	}
	if m.event != nil {
		edges = append(edges, eventparticipant.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventparticipant.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case eventparticipant.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventParticipantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, eventparticipant.EdgeAccount)
	}
	if m.clearedevent {
		edges = append(edges, eventparticipant.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case eventparticipant.EdgeAccount:
		return m.clearedaccount
	case eventparticipant.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventParticipantMutation) ClearEdge(name string) error {
	switch name {
	case eventparticipant.EdgeAccount:
		m.ClearAccount()
		return nil
	case eventparticipant.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown EventParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventParticipantMutation) ResetEdge(name string) error {
	switch name {
	case eventparticipant.EdgeAccount:
		m.ResetAccount()
		return nil
	case eventparticipant.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown EventParticipant edge %s", name)
}

// InvitationMutation represents an operation that mutates the Invitation nodes in the graph.
type InvitationMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	message        *string
	clearedFields  map[string]struct{}
	creator        *xid.ID
	clearedcreator bool
	invited        map[xid.ID]struct{}
	removedinvited map[xid.ID]struct{}
	clearedinvited bool
	done           bool
	oldValue       func(context.Context) (*Invitation, error)
	predicates     []predicate.Invitation
}

var _ ent.Mutation = (*InvitationMutation)(nil)

// invitationOption allows management of the mutation configuration using functional options.
type invitationOption func(*InvitationMutation)

// newInvitationMutation creates new mutation for the Invitation entity.
func newInvitationMutation(c config, op Op, opts ...invitationOption) *InvitationMutation {
	m := &InvitationMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationID sets the ID field of the mutation.
func withInvitationID(id xid.ID) invitationOption {
	return func(m *InvitationMutation) {
		var (
			err   error
			once  sync.Once
			value *Invitation
		)
		m.oldValue = func(ctx context.Context) (*Invitation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invitation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitation sets the old Invitation of the mutation.
func withInvitation(node *Invitation) invitationOption {
	return func(m *InvitationMutation) {
		m.oldValue = func(context.Context) (*Invitation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invitation entities.
func (m *InvitationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invitation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvitationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvitationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvitationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InvitationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InvitationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InvitationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[invitation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InvitationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[invitation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InvitationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, invitation.FieldDeletedAt)
}

// SetMessage sets the "message" field.
func (m *InvitationMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *InvitationMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *InvitationMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[invitation.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *InvitationMutation) MessageCleared() bool {
	_, ok := m.clearedFields[invitation.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *InvitationMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, invitation.FieldMessage)
}

// SetCreatorAccountID sets the "creator_account_id" field.
func (m *InvitationMutation) SetCreatorAccountID(x xid.ID) {
	m.creator = &x
}

// CreatorAccountID returns the value of the "creator_account_id" field in the mutation.
func (m *InvitationMutation) CreatorAccountID() (r xid.ID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorAccountID returns the old "creator_account_id" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldCreatorAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorAccountID: %w", err)
	}
	return oldValue.CreatorAccountID, nil
}

// ResetCreatorAccountID resets all changes to the "creator_account_id" field.
func (m *InvitationMutation) ResetCreatorAccountID() {
	m.creator = nil
}

// SetCreatorID sets the "creator" edge to the Account entity by id.
func (m *InvitationMutation) SetCreatorID(id xid.ID) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Account entity.
func (m *InvitationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[invitation.FieldCreatorAccountID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Account entity was cleared.
func (m *InvitationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *InvitationMutation) CreatorID() (id xid.ID, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *InvitationMutation) CreatorIDs() (ids []xid.ID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *InvitationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddInvitedIDs adds the "invited" edge to the Account entity by ids.
func (m *InvitationMutation) AddInvitedIDs(ids ...xid.ID) {
	if m.invited == nil {
		m.invited = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.invited[ids[i]] = struct{}{}
	}
}

// ClearInvited clears the "invited" edge to the Account entity.
func (m *InvitationMutation) ClearInvited() {
	m.clearedinvited = true
}

// InvitedCleared reports if the "invited" edge to the Account entity was cleared.
func (m *InvitationMutation) InvitedCleared() bool {
	return m.clearedinvited
}

// RemoveInvitedIDs removes the "invited" edge to the Account entity by IDs.
func (m *InvitationMutation) RemoveInvitedIDs(ids ...xid.ID) {
	if m.removedinvited == nil {
		m.removedinvited = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.invited, ids[i])
		m.removedinvited[ids[i]] = struct{}{}
	}
}

// RemovedInvited returns the removed IDs of the "invited" edge to the Account entity.
func (m *InvitationMutation) RemovedInvitedIDs() (ids []xid.ID) {
	for id := range m.removedinvited {
		ids = append(ids, id)
	}
	return
}

// InvitedIDs returns the "invited" edge IDs in the mutation.
func (m *InvitationMutation) InvitedIDs() (ids []xid.ID) {
	for id := range m.invited {
		ids = append(ids, id)
	}
	return
}

// ResetInvited resets all changes to the "invited" edge.
func (m *InvitationMutation) ResetInvited() {
	m.invited = nil
	m.clearedinvited = false
	m.removedinvited = nil
}

// Where appends a list predicates to the InvitationMutation builder.
func (m *InvitationMutation) Where(ps ...predicate.Invitation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvitationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvitationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invitation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvitationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvitationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invitation).
func (m *InvitationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, invitation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invitation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, invitation.FieldDeletedAt)
	}
	if m.message != nil {
		fields = append(fields, invitation.FieldMessage)
	}
	if m.creator != nil {
		fields = append(fields, invitation.FieldCreatorAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitation.FieldCreatedAt:
		return m.CreatedAt()
	case invitation.FieldUpdatedAt:
		return m.UpdatedAt()
	case invitation.FieldDeletedAt:
		return m.DeletedAt()
	case invitation.FieldMessage:
		return m.Message()
	case invitation.FieldCreatorAccountID:
		return m.CreatorAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invitation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invitation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case invitation.FieldMessage:
		return m.OldMessage(ctx)
	case invitation.FieldCreatorAccountID:
		return m.OldCreatorAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown Invitation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invitation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invitation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case invitation.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case invitation.FieldCreatorAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invitation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invitation.FieldDeletedAt) {
		fields = append(fields, invitation.FieldDeletedAt)
	}
	if m.FieldCleared(invitation.FieldMessage) {
		fields = append(fields, invitation.FieldMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationMutation) ClearField(name string) error {
	switch name {
	case invitation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case invitation.FieldMessage:
		m.ClearMessage()
		return nil
	}
	return fmt.Errorf("unknown Invitation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationMutation) ResetField(name string) error {
	switch name {
	case invitation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invitation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invitation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case invitation.FieldMessage:
		m.ResetMessage()
		return nil
	case invitation.FieldCreatorAccountID:
		m.ResetCreatorAccountID()
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.creator != nil {
		edges = append(edges, invitation.EdgeCreator)
	}
	if m.invited != nil {
		edges = append(edges, invitation.EdgeInvited)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case invitation.EdgeInvited:
		ids := make([]ent.Value, 0, len(m.invited))
		for id := range m.invited {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinvited != nil {
		edges = append(edges, invitation.EdgeInvited)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invitation.EdgeInvited:
		ids := make([]ent.Value, 0, len(m.removedinvited))
		for id := range m.removedinvited {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcreator {
		edges = append(edges, invitation.EdgeCreator)
	}
	if m.clearedinvited {
		edges = append(edges, invitation.EdgeInvited)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationMutation) EdgeCleared(name string) bool {
	switch name {
	case invitation.EdgeCreator:
		return m.clearedcreator
	case invitation.EdgeInvited:
		return m.clearedinvited
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationMutation) ClearEdge(name string) error {
	switch name {
	case invitation.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown Invitation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationMutation) ResetEdge(name string) error {
	switch name {
	case invitation.EdgeCreator:
		m.ResetCreator()
		return nil
	case invitation.EdgeInvited:
		m.ResetInvited()
		return nil
	}
	return fmt.Errorf("unknown Invitation edge %s", name)
}

// LikePostMutation represents an operation that mutates the LikePost nodes in the graph.
type LikePostMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	_Post          *xid.ID
	cleared_Post   bool
	done           bool
	oldValue       func(context.Context) (*LikePost, error)
	predicates     []predicate.LikePost
}

var _ ent.Mutation = (*LikePostMutation)(nil)

// likepostOption allows management of the mutation configuration using functional options.
type likepostOption func(*LikePostMutation)

// newLikePostMutation creates new mutation for the LikePost entity.
func newLikePostMutation(c config, op Op, opts ...likepostOption) *LikePostMutation {
	m := &LikePostMutation{
		config:        c,
		op:            op,
		typ:           TypeLikePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLikePostID sets the ID field of the mutation.
func withLikePostID(id xid.ID) likepostOption {
	return func(m *LikePostMutation) {
		var (
			err   error
			once  sync.Once
			value *LikePost
		)
		m.oldValue = func(ctx context.Context) (*LikePost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LikePost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLikePost sets the old LikePost of the mutation.
func withLikePost(node *LikePost) likepostOption {
	return func(m *LikePostMutation) {
		m.oldValue = func(context.Context) (*LikePost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LikePostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LikePostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LikePost entities.
func (m *LikePostMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LikePostMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LikePostMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LikePost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LikePostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LikePostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LikePost entity.
// If the LikePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikePostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LikePostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountID sets the "account_id" field.
func (m *LikePostMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *LikePostMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the LikePost entity.
// If the LikePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikePostMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *LikePostMutation) ResetAccountID() {
	m.account = nil
}

// SetPostID sets the "post_id" field.
func (m *LikePostMutation) SetPostID(x xid.ID) {
	m._Post = &x
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *LikePostMutation) PostID() (r xid.ID, exists bool) {
	v := m._Post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the LikePost entity.
// If the LikePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikePostMutation) OldPostID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *LikePostMutation) ResetPostID() {
	m._Post = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *LikePostMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[likepost.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *LikePostMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *LikePostMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *LikePostMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearPost clears the "Post" edge to the Post entity.
func (m *LikePostMutation) ClearPost() {
	m.cleared_Post = true
	m.clearedFields[likepost.FieldPostID] = struct{}{}
}

// PostCleared reports if the "Post" edge to the Post entity was cleared.
func (m *LikePostMutation) PostCleared() bool {
	return m.cleared_Post
}

// PostIDs returns the "Post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *LikePostMutation) PostIDs() (ids []xid.ID) {
	if id := m._Post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "Post" edge.
func (m *LikePostMutation) ResetPost() {
	m._Post = nil
	m.cleared_Post = false
}

// Where appends a list predicates to the LikePostMutation builder.
func (m *LikePostMutation) Where(ps ...predicate.LikePost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LikePostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LikePostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LikePost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LikePostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LikePostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LikePost).
func (m *LikePostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LikePostMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, likepost.FieldCreatedAt)
	}
	if m.account != nil {
		fields = append(fields, likepost.FieldAccountID)
	}
	if m._Post != nil {
		fields = append(fields, likepost.FieldPostID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LikePostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case likepost.FieldCreatedAt:
		return m.CreatedAt()
	case likepost.FieldAccountID:
		return m.AccountID()
	case likepost.FieldPostID:
		return m.PostID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LikePostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case likepost.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case likepost.FieldAccountID:
		return m.OldAccountID(ctx)
	case likepost.FieldPostID:
		return m.OldPostID(ctx)
	}
	return nil, fmt.Errorf("unknown LikePost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikePostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case likepost.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case likepost.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case likepost.FieldPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	}
	return fmt.Errorf("unknown LikePost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LikePostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LikePostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikePostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LikePost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LikePostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LikePostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LikePostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LikePost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LikePostMutation) ResetField(name string) error {
	switch name {
	case likepost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case likepost.FieldAccountID:
		m.ResetAccountID()
		return nil
	case likepost.FieldPostID:
		m.ResetPostID()
		return nil
	}
	return fmt.Errorf("unknown LikePost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LikePostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, likepost.EdgeAccount)
	}
	if m._Post != nil {
		edges = append(edges, likepost.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LikePostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case likepost.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case likepost.EdgePost:
		if id := m._Post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LikePostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LikePostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LikePostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, likepost.EdgeAccount)
	}
	if m.cleared_Post {
		edges = append(edges, likepost.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LikePostMutation) EdgeCleared(name string) bool {
	switch name {
	case likepost.EdgeAccount:
		return m.clearedaccount
	case likepost.EdgePost:
		return m.cleared_Post
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LikePostMutation) ClearEdge(name string) error {
	switch name {
	case likepost.EdgeAccount:
		m.ClearAccount()
		return nil
	case likepost.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown LikePost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LikePostMutation) ResetEdge(name string) error {
	switch name {
	case likepost.EdgeAccount:
		m.ResetAccount()
		return nil
	case likepost.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown LikePost edge %s", name)
}

// LinkMutation represents an operation that mutates the Link nodes in the graph.
type LinkMutation struct {
	config
	op                             Op
	typ                            string
	id                             *xid.ID
	created_at                     *time.Time
	url                            *string
	slug                           *string
	domain                         *string
	title                          *string
	description                    *string
	clearedFields                  map[string]struct{}
	posts                          map[xid.ID]struct{}
	removedposts                   map[xid.ID]struct{}
	clearedposts                   bool
	post_content_references        map[xid.ID]struct{}
	removedpost_content_references map[xid.ID]struct{}
	clearedpost_content_references bool
	nodes                          map[xid.ID]struct{}
	removednodes                   map[xid.ID]struct{}
	clearednodes                   bool
	node_content_references        map[xid.ID]struct{}
	removednode_content_references map[xid.ID]struct{}
	clearednode_content_references bool
	primary_image                  *xid.ID
	clearedprimary_image           bool
	favicon_image                  *xid.ID
	clearedfavicon_image           bool
	assets                         map[xid.ID]struct{}
	removedassets                  map[xid.ID]struct{}
	clearedassets                  bool
	done                           bool
	oldValue                       func(context.Context) (*Link, error)
	predicates                     []predicate.Link
}

var _ ent.Mutation = (*LinkMutation)(nil)

// linkOption allows management of the mutation configuration using functional options.
type linkOption func(*LinkMutation)

// newLinkMutation creates new mutation for the Link entity.
func newLinkMutation(c config, op Op, opts ...linkOption) *LinkMutation {
	m := &LinkMutation{
		config:        c,
		op:            op,
		typ:           TypeLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkID sets the ID field of the mutation.
func withLinkID(id xid.ID) linkOption {
	return func(m *LinkMutation) {
		var (
			err   error
			once  sync.Once
			value *Link
		)
		m.oldValue = func(ctx context.Context) (*Link, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Link.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLink sets the old Link of the mutation.
func withLink(node *Link) linkOption {
	return func(m *LinkMutation) {
		m.oldValue = func(context.Context) (*Link, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Link entities.
func (m *LinkMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Link.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetURL sets the "url" field.
func (m *LinkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *LinkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *LinkMutation) ResetURL() {
	m.url = nil
}

// SetSlug sets the "slug" field.
func (m *LinkMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *LinkMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *LinkMutation) ResetSlug() {
	m.slug = nil
}

// SetDomain sets the "domain" field.
func (m *LinkMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *LinkMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *LinkMutation) ResetDomain() {
	m.domain = nil
}

// SetTitle sets the "title" field.
func (m *LinkMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *LinkMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *LinkMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *LinkMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LinkMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *LinkMutation) ResetDescription() {
	m.description = nil
}

// SetPrimaryAssetID sets the "primary_asset_id" field.
func (m *LinkMutation) SetPrimaryAssetID(x xid.ID) {
	m.primary_image = &x
}

// PrimaryAssetID returns the value of the "primary_asset_id" field in the mutation.
func (m *LinkMutation) PrimaryAssetID() (r xid.ID, exists bool) {
	v := m.primary_image
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryAssetID returns the old "primary_asset_id" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldPrimaryAssetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryAssetID: %w", err)
	}
	return oldValue.PrimaryAssetID, nil
}

// ClearPrimaryAssetID clears the value of the "primary_asset_id" field.
func (m *LinkMutation) ClearPrimaryAssetID() {
	m.primary_image = nil
	m.clearedFields[link.FieldPrimaryAssetID] = struct{}{}
}

// PrimaryAssetIDCleared returns if the "primary_asset_id" field was cleared in this mutation.
func (m *LinkMutation) PrimaryAssetIDCleared() bool {
	_, ok := m.clearedFields[link.FieldPrimaryAssetID]
	return ok
}

// ResetPrimaryAssetID resets all changes to the "primary_asset_id" field.
func (m *LinkMutation) ResetPrimaryAssetID() {
	m.primary_image = nil
	delete(m.clearedFields, link.FieldPrimaryAssetID)
}

// SetFaviconAssetID sets the "favicon_asset_id" field.
func (m *LinkMutation) SetFaviconAssetID(x xid.ID) {
	m.favicon_image = &x
}

// FaviconAssetID returns the value of the "favicon_asset_id" field in the mutation.
func (m *LinkMutation) FaviconAssetID() (r xid.ID, exists bool) {
	v := m.favicon_image
	if v == nil {
		return
	}
	return *v, true
}

// OldFaviconAssetID returns the old "favicon_asset_id" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldFaviconAssetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaviconAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaviconAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaviconAssetID: %w", err)
	}
	return oldValue.FaviconAssetID, nil
}

// ClearFaviconAssetID clears the value of the "favicon_asset_id" field.
func (m *LinkMutation) ClearFaviconAssetID() {
	m.favicon_image = nil
	m.clearedFields[link.FieldFaviconAssetID] = struct{}{}
}

// FaviconAssetIDCleared returns if the "favicon_asset_id" field was cleared in this mutation.
func (m *LinkMutation) FaviconAssetIDCleared() bool {
	_, ok := m.clearedFields[link.FieldFaviconAssetID]
	return ok
}

// ResetFaviconAssetID resets all changes to the "favicon_asset_id" field.
func (m *LinkMutation) ResetFaviconAssetID() {
	m.favicon_image = nil
	delete(m.clearedFields, link.FieldFaviconAssetID)
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *LinkMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *LinkMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *LinkMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *LinkMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *LinkMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *LinkMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *LinkMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddPostContentReferenceIDs adds the "post_content_references" edge to the Post entity by ids.
func (m *LinkMutation) AddPostContentReferenceIDs(ids ...xid.ID) {
	if m.post_content_references == nil {
		m.post_content_references = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.post_content_references[ids[i]] = struct{}{}
	}
}

// ClearPostContentReferences clears the "post_content_references" edge to the Post entity.
func (m *LinkMutation) ClearPostContentReferences() {
	m.clearedpost_content_references = true
}

// PostContentReferencesCleared reports if the "post_content_references" edge to the Post entity was cleared.
func (m *LinkMutation) PostContentReferencesCleared() bool {
	return m.clearedpost_content_references
}

// RemovePostContentReferenceIDs removes the "post_content_references" edge to the Post entity by IDs.
func (m *LinkMutation) RemovePostContentReferenceIDs(ids ...xid.ID) {
	if m.removedpost_content_references == nil {
		m.removedpost_content_references = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.post_content_references, ids[i])
		m.removedpost_content_references[ids[i]] = struct{}{}
	}
}

// RemovedPostContentReferences returns the removed IDs of the "post_content_references" edge to the Post entity.
func (m *LinkMutation) RemovedPostContentReferencesIDs() (ids []xid.ID) {
	for id := range m.removedpost_content_references {
		ids = append(ids, id)
	}
	return
}

// PostContentReferencesIDs returns the "post_content_references" edge IDs in the mutation.
func (m *LinkMutation) PostContentReferencesIDs() (ids []xid.ID) {
	for id := range m.post_content_references {
		ids = append(ids, id)
	}
	return
}

// ResetPostContentReferences resets all changes to the "post_content_references" edge.
func (m *LinkMutation) ResetPostContentReferences() {
	m.post_content_references = nil
	m.clearedpost_content_references = false
	m.removedpost_content_references = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *LinkMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *LinkMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *LinkMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *LinkMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *LinkMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *LinkMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *LinkMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddNodeContentReferenceIDs adds the "node_content_references" edge to the Node entity by ids.
func (m *LinkMutation) AddNodeContentReferenceIDs(ids ...xid.ID) {
	if m.node_content_references == nil {
		m.node_content_references = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.node_content_references[ids[i]] = struct{}{}
	}
}

// ClearNodeContentReferences clears the "node_content_references" edge to the Node entity.
func (m *LinkMutation) ClearNodeContentReferences() {
	m.clearednode_content_references = true
}

// NodeContentReferencesCleared reports if the "node_content_references" edge to the Node entity was cleared.
func (m *LinkMutation) NodeContentReferencesCleared() bool {
	return m.clearednode_content_references
}

// RemoveNodeContentReferenceIDs removes the "node_content_references" edge to the Node entity by IDs.
func (m *LinkMutation) RemoveNodeContentReferenceIDs(ids ...xid.ID) {
	if m.removednode_content_references == nil {
		m.removednode_content_references = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.node_content_references, ids[i])
		m.removednode_content_references[ids[i]] = struct{}{}
	}
}

// RemovedNodeContentReferences returns the removed IDs of the "node_content_references" edge to the Node entity.
func (m *LinkMutation) RemovedNodeContentReferencesIDs() (ids []xid.ID) {
	for id := range m.removednode_content_references {
		ids = append(ids, id)
	}
	return
}

// NodeContentReferencesIDs returns the "node_content_references" edge IDs in the mutation.
func (m *LinkMutation) NodeContentReferencesIDs() (ids []xid.ID) {
	for id := range m.node_content_references {
		ids = append(ids, id)
	}
	return
}

// ResetNodeContentReferences resets all changes to the "node_content_references" edge.
func (m *LinkMutation) ResetNodeContentReferences() {
	m.node_content_references = nil
	m.clearednode_content_references = false
	m.removednode_content_references = nil
}

// SetPrimaryImageID sets the "primary_image" edge to the Asset entity by id.
func (m *LinkMutation) SetPrimaryImageID(id xid.ID) {
	m.primary_image = &id
}

// ClearPrimaryImage clears the "primary_image" edge to the Asset entity.
func (m *LinkMutation) ClearPrimaryImage() {
	m.clearedprimary_image = true
	m.clearedFields[link.FieldPrimaryAssetID] = struct{}{}
}

// PrimaryImageCleared reports if the "primary_image" edge to the Asset entity was cleared.
func (m *LinkMutation) PrimaryImageCleared() bool {
	return m.PrimaryAssetIDCleared() || m.clearedprimary_image
}

// PrimaryImageID returns the "primary_image" edge ID in the mutation.
func (m *LinkMutation) PrimaryImageID() (id xid.ID, exists bool) {
	if m.primary_image != nil {
		return *m.primary_image, true
	}
	return
}

// PrimaryImageIDs returns the "primary_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryImageID instead. It exists only for internal usage by the builders.
func (m *LinkMutation) PrimaryImageIDs() (ids []xid.ID) {
	if id := m.primary_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryImage resets all changes to the "primary_image" edge.
func (m *LinkMutation) ResetPrimaryImage() {
	m.primary_image = nil
	m.clearedprimary_image = false
}

// SetFaviconImageID sets the "favicon_image" edge to the Asset entity by id.
func (m *LinkMutation) SetFaviconImageID(id xid.ID) {
	m.favicon_image = &id
}

// ClearFaviconImage clears the "favicon_image" edge to the Asset entity.
func (m *LinkMutation) ClearFaviconImage() {
	m.clearedfavicon_image = true
	m.clearedFields[link.FieldFaviconAssetID] = struct{}{}
}

// FaviconImageCleared reports if the "favicon_image" edge to the Asset entity was cleared.
func (m *LinkMutation) FaviconImageCleared() bool {
	return m.FaviconAssetIDCleared() || m.clearedfavicon_image
}

// FaviconImageID returns the "favicon_image" edge ID in the mutation.
func (m *LinkMutation) FaviconImageID() (id xid.ID, exists bool) {
	if m.favicon_image != nil {
		return *m.favicon_image, true
	}
	return
}

// FaviconImageIDs returns the "favicon_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FaviconImageID instead. It exists only for internal usage by the builders.
func (m *LinkMutation) FaviconImageIDs() (ids []xid.ID) {
	if id := m.favicon_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFaviconImage resets all changes to the "favicon_image" edge.
func (m *LinkMutation) ResetFaviconImage() {
	m.favicon_image = nil
	m.clearedfavicon_image = false
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *LinkMutation) AddAssetIDs(ids ...xid.ID) {
	if m.assets == nil {
		m.assets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *LinkMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *LinkMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *LinkMutation) RemoveAssetIDs(ids ...xid.ID) {
	if m.removedassets == nil {
		m.removedassets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *LinkMutation) RemovedAssetsIDs() (ids []xid.ID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *LinkMutation) AssetsIDs() (ids []xid.ID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *LinkMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// Where appends a list predicates to the LinkMutation builder.
func (m *LinkMutation) Where(ps ...predicate.Link) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Link, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Link).
func (m *LinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, link.FieldCreatedAt)
	}
	if m.url != nil {
		fields = append(fields, link.FieldURL)
	}
	if m.slug != nil {
		fields = append(fields, link.FieldSlug)
	}
	if m.domain != nil {
		fields = append(fields, link.FieldDomain)
	}
	if m.title != nil {
		fields = append(fields, link.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, link.FieldDescription)
	}
	if m.primary_image != nil {
		fields = append(fields, link.FieldPrimaryAssetID)
	}
	if m.favicon_image != nil {
		fields = append(fields, link.FieldFaviconAssetID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case link.FieldCreatedAt:
		return m.CreatedAt()
	case link.FieldURL:
		return m.URL()
	case link.FieldSlug:
		return m.Slug()
	case link.FieldDomain:
		return m.Domain()
	case link.FieldTitle:
		return m.Title()
	case link.FieldDescription:
		return m.Description()
	case link.FieldPrimaryAssetID:
		return m.PrimaryAssetID()
	case link.FieldFaviconAssetID:
		return m.FaviconAssetID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case link.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case link.FieldURL:
		return m.OldURL(ctx)
	case link.FieldSlug:
		return m.OldSlug(ctx)
	case link.FieldDomain:
		return m.OldDomain(ctx)
	case link.FieldTitle:
		return m.OldTitle(ctx)
	case link.FieldDescription:
		return m.OldDescription(ctx)
	case link.FieldPrimaryAssetID:
		return m.OldPrimaryAssetID(ctx)
	case link.FieldFaviconAssetID:
		return m.OldFaviconAssetID(ctx)
	}
	return nil, fmt.Errorf("unknown Link field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case link.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case link.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case link.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case link.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case link.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case link.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case link.FieldPrimaryAssetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryAssetID(v)
		return nil
	case link.FieldFaviconAssetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaviconAssetID(v)
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Link numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(link.FieldPrimaryAssetID) {
		fields = append(fields, link.FieldPrimaryAssetID)
	}
	if m.FieldCleared(link.FieldFaviconAssetID) {
		fields = append(fields, link.FieldFaviconAssetID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkMutation) ClearField(name string) error {
	switch name {
	case link.FieldPrimaryAssetID:
		m.ClearPrimaryAssetID()
		return nil
	case link.FieldFaviconAssetID:
		m.ClearFaviconAssetID()
		return nil
	}
	return fmt.Errorf("unknown Link nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkMutation) ResetField(name string) error {
	switch name {
	case link.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case link.FieldURL:
		m.ResetURL()
		return nil
	case link.FieldSlug:
		m.ResetSlug()
		return nil
	case link.FieldDomain:
		m.ResetDomain()
		return nil
	case link.FieldTitle:
		m.ResetTitle()
		return nil
	case link.FieldDescription:
		m.ResetDescription()
		return nil
	case link.FieldPrimaryAssetID:
		m.ResetPrimaryAssetID()
		return nil
	case link.FieldFaviconAssetID:
		m.ResetFaviconAssetID()
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.posts != nil {
		edges = append(edges, link.EdgePosts)
	}
	if m.post_content_references != nil {
		edges = append(edges, link.EdgePostContentReferences)
	}
	if m.nodes != nil {
		edges = append(edges, link.EdgeNodes)
	}
	if m.node_content_references != nil {
		edges = append(edges, link.EdgeNodeContentReferences)
	}
	if m.primary_image != nil {
		edges = append(edges, link.EdgePrimaryImage)
	}
	if m.favicon_image != nil {
		edges = append(edges, link.EdgeFaviconImage)
	}
	if m.assets != nil {
		edges = append(edges, link.EdgeAssets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case link.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case link.EdgePostContentReferences:
		ids := make([]ent.Value, 0, len(m.post_content_references))
		for id := range m.post_content_references {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeNodeContentReferences:
		ids := make([]ent.Value, 0, len(m.node_content_references))
		for id := range m.node_content_references {
			ids = append(ids, id)
		}
		return ids
	case link.EdgePrimaryImage:
		if id := m.primary_image; id != nil {
			return []ent.Value{*id}
		}
	case link.EdgeFaviconImage:
		if id := m.favicon_image; id != nil {
			return []ent.Value{*id}
		}
	case link.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedposts != nil {
		edges = append(edges, link.EdgePosts)
	}
	if m.removedpost_content_references != nil {
		edges = append(edges, link.EdgePostContentReferences)
	}
	if m.removednodes != nil {
		edges = append(edges, link.EdgeNodes)
	}
	if m.removednode_content_references != nil {
		edges = append(edges, link.EdgeNodeContentReferences)
	}
	if m.removedassets != nil {
		edges = append(edges, link.EdgeAssets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case link.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case link.EdgePostContentReferences:
		ids := make([]ent.Value, 0, len(m.removedpost_content_references))
		for id := range m.removedpost_content_references {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeNodeContentReferences:
		ids := make([]ent.Value, 0, len(m.removednode_content_references))
		for id := range m.removednode_content_references {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedposts {
		edges = append(edges, link.EdgePosts)
	}
	if m.clearedpost_content_references {
		edges = append(edges, link.EdgePostContentReferences)
	}
	if m.clearednodes {
		edges = append(edges, link.EdgeNodes)
	}
	if m.clearednode_content_references {
		edges = append(edges, link.EdgeNodeContentReferences)
	}
	if m.clearedprimary_image {
		edges = append(edges, link.EdgePrimaryImage)
	}
	if m.clearedfavicon_image {
		edges = append(edges, link.EdgeFaviconImage)
	}
	if m.clearedassets {
		edges = append(edges, link.EdgeAssets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkMutation) EdgeCleared(name string) bool {
	switch name {
	case link.EdgePosts:
		return m.clearedposts
	case link.EdgePostContentReferences:
		return m.clearedpost_content_references
	case link.EdgeNodes:
		return m.clearednodes
	case link.EdgeNodeContentReferences:
		return m.clearednode_content_references
	case link.EdgePrimaryImage:
		return m.clearedprimary_image
	case link.EdgeFaviconImage:
		return m.clearedfavicon_image
	case link.EdgeAssets:
		return m.clearedassets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkMutation) ClearEdge(name string) error {
	switch name {
	case link.EdgePrimaryImage:
		m.ClearPrimaryImage()
		return nil
	case link.EdgeFaviconImage:
		m.ClearFaviconImage()
		return nil
	}
	return fmt.Errorf("unknown Link unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkMutation) ResetEdge(name string) error {
	switch name {
	case link.EdgePosts:
		m.ResetPosts()
		return nil
	case link.EdgePostContentReferences:
		m.ResetPostContentReferences()
		return nil
	case link.EdgeNodes:
		m.ResetNodes()
		return nil
	case link.EdgeNodeContentReferences:
		m.ResetNodeContentReferences()
		return nil
	case link.EdgePrimaryImage:
		m.ResetPrimaryImage()
		return nil
	case link.EdgeFaviconImage:
		m.ResetFaviconImage()
		return nil
	case link.EdgeAssets:
		m.ResetAssets()
		return nil
	}
	return fmt.Errorf("unknown Link edge %s", name)
}

// MentionProfileMutation represents an operation that mutates the MentionProfile nodes in the graph.
type MentionProfileMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	_Post          *xid.ID
	cleared_Post   bool
	done           bool
	oldValue       func(context.Context) (*MentionProfile, error)
	predicates     []predicate.MentionProfile
}

var _ ent.Mutation = (*MentionProfileMutation)(nil)

// mentionprofileOption allows management of the mutation configuration using functional options.
type mentionprofileOption func(*MentionProfileMutation)

// newMentionProfileMutation creates new mutation for the MentionProfile entity.
func newMentionProfileMutation(c config, op Op, opts ...mentionprofileOption) *MentionProfileMutation {
	m := &MentionProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeMentionProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMentionProfileID sets the ID field of the mutation.
func withMentionProfileID(id xid.ID) mentionprofileOption {
	return func(m *MentionProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *MentionProfile
		)
		m.oldValue = func(ctx context.Context) (*MentionProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MentionProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMentionProfile sets the old MentionProfile of the mutation.
func withMentionProfile(node *MentionProfile) mentionprofileOption {
	return func(m *MentionProfileMutation) {
		m.oldValue = func(context.Context) (*MentionProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MentionProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MentionProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MentionProfile entities.
func (m *MentionProfileMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MentionProfileMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MentionProfileMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MentionProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MentionProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MentionProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MentionProfile entity.
// If the MentionProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentionProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MentionProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountID sets the "account_id" field.
func (m *MentionProfileMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *MentionProfileMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the MentionProfile entity.
// If the MentionProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentionProfileMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *MentionProfileMutation) ResetAccountID() {
	m.account = nil
}

// SetPostID sets the "post_id" field.
func (m *MentionProfileMutation) SetPostID(x xid.ID) {
	m._Post = &x
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *MentionProfileMutation) PostID() (r xid.ID, exists bool) {
	v := m._Post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the MentionProfile entity.
// If the MentionProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentionProfileMutation) OldPostID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *MentionProfileMutation) ResetPostID() {
	m._Post = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *MentionProfileMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[mentionprofile.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *MentionProfileMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *MentionProfileMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *MentionProfileMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearPost clears the "Post" edge to the Post entity.
func (m *MentionProfileMutation) ClearPost() {
	m.cleared_Post = true
	m.clearedFields[mentionprofile.FieldPostID] = struct{}{}
}

// PostCleared reports if the "Post" edge to the Post entity was cleared.
func (m *MentionProfileMutation) PostCleared() bool {
	return m.cleared_Post
}

// PostIDs returns the "Post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *MentionProfileMutation) PostIDs() (ids []xid.ID) {
	if id := m._Post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "Post" edge.
func (m *MentionProfileMutation) ResetPost() {
	m._Post = nil
	m.cleared_Post = false
}

// Where appends a list predicates to the MentionProfileMutation builder.
func (m *MentionProfileMutation) Where(ps ...predicate.MentionProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MentionProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MentionProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MentionProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MentionProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MentionProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MentionProfile).
func (m *MentionProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MentionProfileMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, mentionprofile.FieldCreatedAt)
	}
	if m.account != nil {
		fields = append(fields, mentionprofile.FieldAccountID)
	}
	if m._Post != nil {
		fields = append(fields, mentionprofile.FieldPostID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MentionProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mentionprofile.FieldCreatedAt:
		return m.CreatedAt()
	case mentionprofile.FieldAccountID:
		return m.AccountID()
	case mentionprofile.FieldPostID:
		return m.PostID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MentionProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mentionprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mentionprofile.FieldAccountID:
		return m.OldAccountID(ctx)
	case mentionprofile.FieldPostID:
		return m.OldPostID(ctx)
	}
	return nil, fmt.Errorf("unknown MentionProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentionProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mentionprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mentionprofile.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case mentionprofile.FieldPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	}
	return fmt.Errorf("unknown MentionProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MentionProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MentionProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentionProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MentionProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MentionProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MentionProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MentionProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MentionProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MentionProfileMutation) ResetField(name string) error {
	switch name {
	case mentionprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mentionprofile.FieldAccountID:
		m.ResetAccountID()
		return nil
	case mentionprofile.FieldPostID:
		m.ResetPostID()
		return nil
	}
	return fmt.Errorf("unknown MentionProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MentionProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, mentionprofile.EdgeAccount)
	}
	if m._Post != nil {
		edges = append(edges, mentionprofile.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MentionProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mentionprofile.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case mentionprofile.EdgePost:
		if id := m._Post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MentionProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MentionProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MentionProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, mentionprofile.EdgeAccount)
	}
	if m.cleared_Post {
		edges = append(edges, mentionprofile.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MentionProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case mentionprofile.EdgeAccount:
		return m.clearedaccount
	case mentionprofile.EdgePost:
		return m.cleared_Post
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MentionProfileMutation) ClearEdge(name string) error {
	switch name {
	case mentionprofile.EdgeAccount:
		m.ClearAccount()
		return nil
	case mentionprofile.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown MentionProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MentionProfileMutation) ResetEdge(name string) error {
	switch name {
	case mentionprofile.EdgeAccount:
		m.ResetAccount()
		return nil
	case mentionprofile.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown MentionProfile edge %s", name)
}

// NodeMutation represents an operation that mutates the Node nodes in the graph.
type NodeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *xid.ID
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	indexed_at           *time.Time
	name                 *string
	slug                 *string
	description          *string
	content              *string
	visibility           *node.Visibility
	metadata             *map[string]interface{}
	clearedFields        map[string]struct{}
	owner                *xid.ID
	clearedowner         bool
	parent               *xid.ID
	clearedparent        bool
	nodes                map[xid.ID]struct{}
	removednodes         map[xid.ID]struct{}
	clearednodes         bool
	primary_image        *xid.ID
	clearedprimary_image bool
	assets               map[xid.ID]struct{}
	removedassets        map[xid.ID]struct{}
	clearedassets        bool
	tags                 map[xid.ID]struct{}
	removedtags          map[xid.ID]struct{}
	clearedtags          bool
	link                 *xid.ID
	clearedlink          bool
	content_links        map[xid.ID]struct{}
	removedcontent_links map[xid.ID]struct{}
	clearedcontent_links bool
	collections          map[xid.ID]struct{}
	removedcollections   map[xid.ID]struct{}
	clearedcollections   bool
	node_tags            map[xid.ID]struct{}
	removednode_tags     map[xid.ID]struct{}
	clearednode_tags     bool
	done                 bool
	oldValue             func(context.Context) (*Node, error)
	predicates           []predicate.Node
}

var _ ent.Mutation = (*NodeMutation)(nil)

// nodeOption allows management of the mutation configuration using functional options.
type nodeOption func(*NodeMutation)

// newNodeMutation creates new mutation for the Node entity.
func newNodeMutation(c config, op Op, opts ...nodeOption) *NodeMutation {
	m := &NodeMutation{
		config:        c,
		op:            op,
		typ:           TypeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeID sets the ID field of the mutation.
func withNodeID(id xid.ID) nodeOption {
	return func(m *NodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Node
		)
		m.oldValue = func(ctx context.Context) (*Node, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Node.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNode sets the old Node of the mutation.
func withNode(node *Node) nodeOption {
	return func(m *NodeMutation) {
		m.oldValue = func(context.Context) (*Node, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Node entities.
func (m *NodeMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodeMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Node.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NodeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NodeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NodeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[node.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NodeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[node.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, node.FieldDeletedAt)
}

// SetIndexedAt sets the "indexed_at" field.
func (m *NodeMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *NodeMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *NodeMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[node.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *NodeMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[node.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *NodeMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, node.FieldIndexedAt)
}

// SetName sets the "name" field.
func (m *NodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NodeMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *NodeMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *NodeMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *NodeMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *NodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NodeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[node.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NodeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[node.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NodeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, node.FieldDescription)
}

// SetContent sets the "content" field.
func (m *NodeMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *NodeMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *NodeMutation) ClearContent() {
	m.content = nil
	m.clearedFields[node.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *NodeMutation) ContentCleared() bool {
	_, ok := m.clearedFields[node.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *NodeMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, node.FieldContent)
}

// SetParentNodeID sets the "parent_node_id" field.
func (m *NodeMutation) SetParentNodeID(x xid.ID) {
	m.parent = &x
}

// ParentNodeID returns the value of the "parent_node_id" field in the mutation.
func (m *NodeMutation) ParentNodeID() (r xid.ID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentNodeID returns the old "parent_node_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldParentNodeID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentNodeID: %w", err)
	}
	return oldValue.ParentNodeID, nil
}

// ClearParentNodeID clears the value of the "parent_node_id" field.
func (m *NodeMutation) ClearParentNodeID() {
	m.parent = nil
	m.clearedFields[node.FieldParentNodeID] = struct{}{}
}

// ParentNodeIDCleared returns if the "parent_node_id" field was cleared in this mutation.
func (m *NodeMutation) ParentNodeIDCleared() bool {
	_, ok := m.clearedFields[node.FieldParentNodeID]
	return ok
}

// ResetParentNodeID resets all changes to the "parent_node_id" field.
func (m *NodeMutation) ResetParentNodeID() {
	m.parent = nil
	delete(m.clearedFields, node.FieldParentNodeID)
}

// SetAccountID sets the "account_id" field.
func (m *NodeMutation) SetAccountID(x xid.ID) {
	m.owner = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *NodeMutation) AccountID() (r xid.ID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *NodeMutation) ResetAccountID() {
	m.owner = nil
}

// SetPrimaryAssetID sets the "primary_asset_id" field.
func (m *NodeMutation) SetPrimaryAssetID(x xid.ID) {
	m.primary_image = &x
}

// PrimaryAssetID returns the value of the "primary_asset_id" field in the mutation.
func (m *NodeMutation) PrimaryAssetID() (r xid.ID, exists bool) {
	v := m.primary_image
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryAssetID returns the old "primary_asset_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPrimaryAssetID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryAssetID: %w", err)
	}
	return oldValue.PrimaryAssetID, nil
}

// ClearPrimaryAssetID clears the value of the "primary_asset_id" field.
func (m *NodeMutation) ClearPrimaryAssetID() {
	m.primary_image = nil
	m.clearedFields[node.FieldPrimaryAssetID] = struct{}{}
}

// PrimaryAssetIDCleared returns if the "primary_asset_id" field was cleared in this mutation.
func (m *NodeMutation) PrimaryAssetIDCleared() bool {
	_, ok := m.clearedFields[node.FieldPrimaryAssetID]
	return ok
}

// ResetPrimaryAssetID resets all changes to the "primary_asset_id" field.
func (m *NodeMutation) ResetPrimaryAssetID() {
	m.primary_image = nil
	delete(m.clearedFields, node.FieldPrimaryAssetID)
}

// SetLinkID sets the "link_id" field.
func (m *NodeMutation) SetLinkID(x xid.ID) {
	m.link = &x
}

// LinkID returns the value of the "link_id" field in the mutation.
func (m *NodeMutation) LinkID() (r xid.ID, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkID returns the old "link_id" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldLinkID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkID: %w", err)
	}
	return oldValue.LinkID, nil
}

// ClearLinkID clears the value of the "link_id" field.
func (m *NodeMutation) ClearLinkID() {
	m.link = nil
	m.clearedFields[node.FieldLinkID] = struct{}{}
}

// LinkIDCleared returns if the "link_id" field was cleared in this mutation.
func (m *NodeMutation) LinkIDCleared() bool {
	_, ok := m.clearedFields[node.FieldLinkID]
	return ok
}

// ResetLinkID resets all changes to the "link_id" field.
func (m *NodeMutation) ResetLinkID() {
	m.link = nil
	delete(m.clearedFields, node.FieldLinkID)
}

// SetVisibility sets the "visibility" field.
func (m *NodeMutation) SetVisibility(n node.Visibility) {
	m.visibility = &n
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *NodeMutation) Visibility() (r node.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldVisibility(ctx context.Context) (v node.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *NodeMutation) ResetVisibility() {
	m.visibility = nil
}

// SetMetadata sets the "metadata" field.
func (m *NodeMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *NodeMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *NodeMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[node.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *NodeMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[node.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *NodeMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, node.FieldMetadata)
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *NodeMutation) SetOwnerID(id xid.ID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *NodeMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[node.FieldAccountID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *NodeMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NodeMutation) OwnerID() (id xid.ID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) OwnerIDs() (ids []xid.ID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NodeMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetParentID sets the "parent" edge to the Node entity by id.
func (m *NodeMutation) SetParentID(id xid.ID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Node entity.
func (m *NodeMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[node.FieldParentNodeID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Node entity was cleared.
func (m *NodeMutation) ParentCleared() bool {
	return m.ParentNodeIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *NodeMutation) ParentID() (id xid.ID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) ParentIDs() (ids []xid.ID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *NodeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *NodeMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *NodeMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *NodeMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *NodeMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *NodeMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *NodeMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *NodeMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// SetPrimaryImageID sets the "primary_image" edge to the Asset entity by id.
func (m *NodeMutation) SetPrimaryImageID(id xid.ID) {
	m.primary_image = &id
}

// ClearPrimaryImage clears the "primary_image" edge to the Asset entity.
func (m *NodeMutation) ClearPrimaryImage() {
	m.clearedprimary_image = true
	m.clearedFields[node.FieldPrimaryAssetID] = struct{}{}
}

// PrimaryImageCleared reports if the "primary_image" edge to the Asset entity was cleared.
func (m *NodeMutation) PrimaryImageCleared() bool {
	return m.PrimaryAssetIDCleared() || m.clearedprimary_image
}

// PrimaryImageID returns the "primary_image" edge ID in the mutation.
func (m *NodeMutation) PrimaryImageID() (id xid.ID, exists bool) {
	if m.primary_image != nil {
		return *m.primary_image, true
	}
	return
}

// PrimaryImageIDs returns the "primary_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryImageID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) PrimaryImageIDs() (ids []xid.ID) {
	if id := m.primary_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryImage resets all changes to the "primary_image" edge.
func (m *NodeMutation) ResetPrimaryImage() {
	m.primary_image = nil
	m.clearedprimary_image = false
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *NodeMutation) AddAssetIDs(ids ...xid.ID) {
	if m.assets == nil {
		m.assets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *NodeMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *NodeMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *NodeMutation) RemoveAssetIDs(ids ...xid.ID) {
	if m.removedassets == nil {
		m.removedassets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *NodeMutation) RemovedAssetsIDs() (ids []xid.ID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *NodeMutation) AssetsIDs() (ids []xid.ID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *NodeMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *NodeMutation) AddTagIDs(ids ...xid.ID) {
	if m.tags == nil {
		m.tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *NodeMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *NodeMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *NodeMutation) RemoveTagIDs(ids ...xid.ID) {
	if m.removedtags == nil {
		m.removedtags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *NodeMutation) RemovedTagsIDs() (ids []xid.ID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *NodeMutation) TagsIDs() (ids []xid.ID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *NodeMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// ClearLink clears the "link" edge to the Link entity.
func (m *NodeMutation) ClearLink() {
	m.clearedlink = true
	m.clearedFields[node.FieldLinkID] = struct{}{}
}

// LinkCleared reports if the "link" edge to the Link entity was cleared.
func (m *NodeMutation) LinkCleared() bool {
	return m.LinkIDCleared() || m.clearedlink
}

// LinkIDs returns the "link" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LinkID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) LinkIDs() (ids []xid.ID) {
	if id := m.link; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLink resets all changes to the "link" edge.
func (m *NodeMutation) ResetLink() {
	m.link = nil
	m.clearedlink = false
}

// AddContentLinkIDs adds the "content_links" edge to the Link entity by ids.
func (m *NodeMutation) AddContentLinkIDs(ids ...xid.ID) {
	if m.content_links == nil {
		m.content_links = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.content_links[ids[i]] = struct{}{}
	}
}

// ClearContentLinks clears the "content_links" edge to the Link entity.
func (m *NodeMutation) ClearContentLinks() {
	m.clearedcontent_links = true
}

// ContentLinksCleared reports if the "content_links" edge to the Link entity was cleared.
func (m *NodeMutation) ContentLinksCleared() bool {
	return m.clearedcontent_links
}

// RemoveContentLinkIDs removes the "content_links" edge to the Link entity by IDs.
func (m *NodeMutation) RemoveContentLinkIDs(ids ...xid.ID) {
	if m.removedcontent_links == nil {
		m.removedcontent_links = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.content_links, ids[i])
		m.removedcontent_links[ids[i]] = struct{}{}
	}
}

// RemovedContentLinks returns the removed IDs of the "content_links" edge to the Link entity.
func (m *NodeMutation) RemovedContentLinksIDs() (ids []xid.ID) {
	for id := range m.removedcontent_links {
		ids = append(ids, id)
	}
	return
}

// ContentLinksIDs returns the "content_links" edge IDs in the mutation.
func (m *NodeMutation) ContentLinksIDs() (ids []xid.ID) {
	for id := range m.content_links {
		ids = append(ids, id)
	}
	return
}

// ResetContentLinks resets all changes to the "content_links" edge.
func (m *NodeMutation) ResetContentLinks() {
	m.content_links = nil
	m.clearedcontent_links = false
	m.removedcontent_links = nil
}

// AddCollectionIDs adds the "collections" edge to the Collection entity by ids.
func (m *NodeMutation) AddCollectionIDs(ids ...xid.ID) {
	if m.collections == nil {
		m.collections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.collections[ids[i]] = struct{}{}
	}
}

// ClearCollections clears the "collections" edge to the Collection entity.
func (m *NodeMutation) ClearCollections() {
	m.clearedcollections = true
}

// CollectionsCleared reports if the "collections" edge to the Collection entity was cleared.
func (m *NodeMutation) CollectionsCleared() bool {
	return m.clearedcollections
}

// RemoveCollectionIDs removes the "collections" edge to the Collection entity by IDs.
func (m *NodeMutation) RemoveCollectionIDs(ids ...xid.ID) {
	if m.removedcollections == nil {
		m.removedcollections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.collections, ids[i])
		m.removedcollections[ids[i]] = struct{}{}
	}
}

// RemovedCollections returns the removed IDs of the "collections" edge to the Collection entity.
func (m *NodeMutation) RemovedCollectionsIDs() (ids []xid.ID) {
	for id := range m.removedcollections {
		ids = append(ids, id)
	}
	return
}

// CollectionsIDs returns the "collections" edge IDs in the mutation.
func (m *NodeMutation) CollectionsIDs() (ids []xid.ID) {
	for id := range m.collections {
		ids = append(ids, id)
	}
	return
}

// ResetCollections resets all changes to the "collections" edge.
func (m *NodeMutation) ResetCollections() {
	m.collections = nil
	m.clearedcollections = false
	m.removedcollections = nil
}

// AddNodeTagIDs adds the "node_tags" edge to the TagNode entity by ids.
func (m *NodeMutation) AddNodeTagIDs(ids ...xid.ID) {
	if m.node_tags == nil {
		m.node_tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.node_tags[ids[i]] = struct{}{}
	}
}

// ClearNodeTags clears the "node_tags" edge to the TagNode entity.
func (m *NodeMutation) ClearNodeTags() {
	m.clearednode_tags = true
}

// NodeTagsCleared reports if the "node_tags" edge to the TagNode entity was cleared.
func (m *NodeMutation) NodeTagsCleared() bool {
	return m.clearednode_tags
}

// RemoveNodeTagIDs removes the "node_tags" edge to the TagNode entity by IDs.
func (m *NodeMutation) RemoveNodeTagIDs(ids ...xid.ID) {
	if m.removednode_tags == nil {
		m.removednode_tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.node_tags, ids[i])
		m.removednode_tags[ids[i]] = struct{}{}
	}
}

// RemovedNodeTags returns the removed IDs of the "node_tags" edge to the TagNode entity.
func (m *NodeMutation) RemovedNodeTagsIDs() (ids []xid.ID) {
	for id := range m.removednode_tags {
		ids = append(ids, id)
	}
	return
}

// NodeTagsIDs returns the "node_tags" edge IDs in the mutation.
func (m *NodeMutation) NodeTagsIDs() (ids []xid.ID) {
	for id := range m.node_tags {
		ids = append(ids, id)
	}
	return
}

// ResetNodeTags resets all changes to the "node_tags" edge.
func (m *NodeMutation) ResetNodeTags() {
	m.node_tags = nil
	m.clearednode_tags = false
	m.removednode_tags = nil
}

// Where appends a list predicates to the NodeMutation builder.
func (m *NodeMutation) Where(ps ...predicate.Node) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Node, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Node).
func (m *NodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, node.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, node.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, node.FieldDeletedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, node.FieldIndexedAt)
	}
	if m.name != nil {
		fields = append(fields, node.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, node.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, node.FieldDescription)
	}
	if m.content != nil {
		fields = append(fields, node.FieldContent)
	}
	if m.parent != nil {
		fields = append(fields, node.FieldParentNodeID)
	}
	if m.owner != nil {
		fields = append(fields, node.FieldAccountID)
	}
	if m.primary_image != nil {
		fields = append(fields, node.FieldPrimaryAssetID)
	}
	if m.link != nil {
		fields = append(fields, node.FieldLinkID)
	}
	if m.visibility != nil {
		fields = append(fields, node.FieldVisibility)
	}
	if m.metadata != nil {
		fields = append(fields, node.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case node.FieldCreatedAt:
		return m.CreatedAt()
	case node.FieldUpdatedAt:
		return m.UpdatedAt()
	case node.FieldDeletedAt:
		return m.DeletedAt()
	case node.FieldIndexedAt:
		return m.IndexedAt()
	case node.FieldName:
		return m.Name()
	case node.FieldSlug:
		return m.Slug()
	case node.FieldDescription:
		return m.Description()
	case node.FieldContent:
		return m.Content()
	case node.FieldParentNodeID:
		return m.ParentNodeID()
	case node.FieldAccountID:
		return m.AccountID()
	case node.FieldPrimaryAssetID:
		return m.PrimaryAssetID()
	case node.FieldLinkID:
		return m.LinkID()
	case node.FieldVisibility:
		return m.Visibility()
	case node.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case node.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case node.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case node.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case node.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case node.FieldName:
		return m.OldName(ctx)
	case node.FieldSlug:
		return m.OldSlug(ctx)
	case node.FieldDescription:
		return m.OldDescription(ctx)
	case node.FieldContent:
		return m.OldContent(ctx)
	case node.FieldParentNodeID:
		return m.OldParentNodeID(ctx)
	case node.FieldAccountID:
		return m.OldAccountID(ctx)
	case node.FieldPrimaryAssetID:
		return m.OldPrimaryAssetID(ctx)
	case node.FieldLinkID:
		return m.OldLinkID(ctx)
	case node.FieldVisibility:
		return m.OldVisibility(ctx)
	case node.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Node field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case node.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case node.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case node.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case node.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case node.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case node.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case node.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case node.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case node.FieldParentNodeID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentNodeID(v)
		return nil
	case node.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case node.FieldPrimaryAssetID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryAssetID(v)
		return nil
	case node.FieldLinkID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkID(v)
		return nil
	case node.FieldVisibility:
		v, ok := value.(node.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case node.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Node numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(node.FieldDeletedAt) {
		fields = append(fields, node.FieldDeletedAt)
	}
	if m.FieldCleared(node.FieldIndexedAt) {
		fields = append(fields, node.FieldIndexedAt)
	}
	if m.FieldCleared(node.FieldDescription) {
		fields = append(fields, node.FieldDescription)
	}
	if m.FieldCleared(node.FieldContent) {
		fields = append(fields, node.FieldContent)
	}
	if m.FieldCleared(node.FieldParentNodeID) {
		fields = append(fields, node.FieldParentNodeID)
	}
	if m.FieldCleared(node.FieldPrimaryAssetID) {
		fields = append(fields, node.FieldPrimaryAssetID)
	}
	if m.FieldCleared(node.FieldLinkID) {
		fields = append(fields, node.FieldLinkID)
	}
	if m.FieldCleared(node.FieldMetadata) {
		fields = append(fields, node.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeMutation) ClearField(name string) error {
	switch name {
	case node.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case node.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case node.FieldDescription:
		m.ClearDescription()
		return nil
	case node.FieldContent:
		m.ClearContent()
		return nil
	case node.FieldParentNodeID:
		m.ClearParentNodeID()
		return nil
	case node.FieldPrimaryAssetID:
		m.ClearPrimaryAssetID()
		return nil
	case node.FieldLinkID:
		m.ClearLinkID()
		return nil
	case node.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Node nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeMutation) ResetField(name string) error {
	switch name {
	case node.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case node.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case node.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case node.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case node.FieldName:
		m.ResetName()
		return nil
	case node.FieldSlug:
		m.ResetSlug()
		return nil
	case node.FieldDescription:
		m.ResetDescription()
		return nil
	case node.FieldContent:
		m.ResetContent()
		return nil
	case node.FieldParentNodeID:
		m.ResetParentNodeID()
		return nil
	case node.FieldAccountID:
		m.ResetAccountID()
		return nil
	case node.FieldPrimaryAssetID:
		m.ResetPrimaryAssetID()
		return nil
	case node.FieldLinkID:
		m.ResetLinkID()
		return nil
	case node.FieldVisibility:
		m.ResetVisibility()
		return nil
	case node.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.owner != nil {
		edges = append(edges, node.EdgeOwner)
	}
	if m.parent != nil {
		edges = append(edges, node.EdgeParent)
	}
	if m.nodes != nil {
		edges = append(edges, node.EdgeNodes)
	}
	if m.primary_image != nil {
		edges = append(edges, node.EdgePrimaryImage)
	}
	if m.assets != nil {
		edges = append(edges, node.EdgeAssets)
	}
	if m.tags != nil {
		edges = append(edges, node.EdgeTags)
	}
	if m.link != nil {
		edges = append(edges, node.EdgeLink)
	}
	if m.content_links != nil {
		edges = append(edges, node.EdgeContentLinks)
	}
	if m.collections != nil {
		edges = append(edges, node.EdgeCollections)
	}
	if m.node_tags != nil {
		edges = append(edges, node.EdgeNodeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case node.EdgePrimaryImage:
		if id := m.primary_image; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeLink:
		if id := m.link; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeContentLinks:
		ids := make([]ent.Value, 0, len(m.content_links))
		for id := range m.content_links {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.collections))
		for id := range m.collections {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeNodeTags:
		ids := make([]ent.Value, 0, len(m.node_tags))
		for id := range m.node_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removednodes != nil {
		edges = append(edges, node.EdgeNodes)
	}
	if m.removedassets != nil {
		edges = append(edges, node.EdgeAssets)
	}
	if m.removedtags != nil {
		edges = append(edges, node.EdgeTags)
	}
	if m.removedcontent_links != nil {
		edges = append(edges, node.EdgeContentLinks)
	}
	if m.removedcollections != nil {
		edges = append(edges, node.EdgeCollections)
	}
	if m.removednode_tags != nil {
		edges = append(edges, node.EdgeNodeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeContentLinks:
		ids := make([]ent.Value, 0, len(m.removedcontent_links))
		for id := range m.removedcontent_links {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.removedcollections))
		for id := range m.removedcollections {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeNodeTags:
		ids := make([]ent.Value, 0, len(m.removednode_tags))
		for id := range m.removednode_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedowner {
		edges = append(edges, node.EdgeOwner)
	}
	if m.clearedparent {
		edges = append(edges, node.EdgeParent)
	}
	if m.clearednodes {
		edges = append(edges, node.EdgeNodes)
	}
	if m.clearedprimary_image {
		edges = append(edges, node.EdgePrimaryImage)
	}
	if m.clearedassets {
		edges = append(edges, node.EdgeAssets)
	}
	if m.clearedtags {
		edges = append(edges, node.EdgeTags)
	}
	if m.clearedlink {
		edges = append(edges, node.EdgeLink)
	}
	if m.clearedcontent_links {
		edges = append(edges, node.EdgeContentLinks)
	}
	if m.clearedcollections {
		edges = append(edges, node.EdgeCollections)
	}
	if m.clearednode_tags {
		edges = append(edges, node.EdgeNodeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeMutation) EdgeCleared(name string) bool {
	switch name {
	case node.EdgeOwner:
		return m.clearedowner
	case node.EdgeParent:
		return m.clearedparent
	case node.EdgeNodes:
		return m.clearednodes
	case node.EdgePrimaryImage:
		return m.clearedprimary_image
	case node.EdgeAssets:
		return m.clearedassets
	case node.EdgeTags:
		return m.clearedtags
	case node.EdgeLink:
		return m.clearedlink
	case node.EdgeContentLinks:
		return m.clearedcontent_links
	case node.EdgeCollections:
		return m.clearedcollections
	case node.EdgeNodeTags:
		return m.clearednode_tags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeMutation) ClearEdge(name string) error {
	switch name {
	case node.EdgeOwner:
		m.ClearOwner()
		return nil
	case node.EdgeParent:
		m.ClearParent()
		return nil
	case node.EdgePrimaryImage:
		m.ClearPrimaryImage()
		return nil
	case node.EdgeLink:
		m.ClearLink()
		return nil
	}
	return fmt.Errorf("unknown Node unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeMutation) ResetEdge(name string) error {
	switch name {
	case node.EdgeOwner:
		m.ResetOwner()
		return nil
	case node.EdgeParent:
		m.ResetParent()
		return nil
	case node.EdgeNodes:
		m.ResetNodes()
		return nil
	case node.EdgePrimaryImage:
		m.ResetPrimaryImage()
		return nil
	case node.EdgeAssets:
		m.ResetAssets()
		return nil
	case node.EdgeTags:
		m.ResetTags()
		return nil
	case node.EdgeLink:
		m.ResetLink()
		return nil
	case node.EdgeContentLinks:
		m.ResetContentLinks()
		return nil
	case node.EdgeCollections:
		m.ResetCollections()
		return nil
	case node.EdgeNodeTags:
		m.ResetNodeTags()
		return nil
	}
	return fmt.Errorf("unknown Node edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	deleted_at     *time.Time
	event_type     *string
	datagraph_kind *string
	datagraph_id   *xid.ID
	read           *bool
	clearedFields  map[string]struct{}
	owner          *xid.ID
	clearedowner   bool
	source         *xid.ID
	clearedsource  bool
	done           bool
	oldValue       func(context.Context) (*Notification, error)
	predicates     []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id xid.ID) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notification.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notification.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notification.FieldDeletedAt)
}

// SetEventType sets the "event_type" field.
func (m *NotificationMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *NotificationMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *NotificationMutation) ResetEventType() {
	m.event_type = nil
}

// SetDatagraphKind sets the "datagraph_kind" field.
func (m *NotificationMutation) SetDatagraphKind(s string) {
	m.datagraph_kind = &s
}

// DatagraphKind returns the value of the "datagraph_kind" field in the mutation.
func (m *NotificationMutation) DatagraphKind() (r string, exists bool) {
	v := m.datagraph_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldDatagraphKind returns the old "datagraph_kind" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldDatagraphKind(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatagraphKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatagraphKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatagraphKind: %w", err)
	}
	return oldValue.DatagraphKind, nil
}

// ClearDatagraphKind clears the value of the "datagraph_kind" field.
func (m *NotificationMutation) ClearDatagraphKind() {
	m.datagraph_kind = nil
	m.clearedFields[notification.FieldDatagraphKind] = struct{}{}
}

// DatagraphKindCleared returns if the "datagraph_kind" field was cleared in this mutation.
func (m *NotificationMutation) DatagraphKindCleared() bool {
	_, ok := m.clearedFields[notification.FieldDatagraphKind]
	return ok
}

// ResetDatagraphKind resets all changes to the "datagraph_kind" field.
func (m *NotificationMutation) ResetDatagraphKind() {
	m.datagraph_kind = nil
	delete(m.clearedFields, notification.FieldDatagraphKind)
}

// SetDatagraphID sets the "datagraph_id" field.
func (m *NotificationMutation) SetDatagraphID(x xid.ID) {
	m.datagraph_id = &x
}

// DatagraphID returns the value of the "datagraph_id" field in the mutation.
func (m *NotificationMutation) DatagraphID() (r xid.ID, exists bool) {
	v := m.datagraph_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDatagraphID returns the old "datagraph_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldDatagraphID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatagraphID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatagraphID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatagraphID: %w", err)
	}
	return oldValue.DatagraphID, nil
}

// ClearDatagraphID clears the value of the "datagraph_id" field.
func (m *NotificationMutation) ClearDatagraphID() {
	m.datagraph_id = nil
	m.clearedFields[notification.FieldDatagraphID] = struct{}{}
}

// DatagraphIDCleared returns if the "datagraph_id" field was cleared in this mutation.
func (m *NotificationMutation) DatagraphIDCleared() bool {
	_, ok := m.clearedFields[notification.FieldDatagraphID]
	return ok
}

// ResetDatagraphID resets all changes to the "datagraph_id" field.
func (m *NotificationMutation) ResetDatagraphID() {
	m.datagraph_id = nil
	delete(m.clearedFields, notification.FieldDatagraphID)
}

// SetRead sets the "read" field.
func (m *NotificationMutation) SetRead(b bool) {
	m.read = &b
}

// Read returns the value of the "read" field in the mutation.
func (m *NotificationMutation) Read() (r bool, exists bool) {
	v := m.read
	if v == nil {
		return
	}
	return *v, true
}

// OldRead returns the old "read" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRead: %w", err)
	}
	return oldValue.Read, nil
}

// ResetRead resets all changes to the "read" field.
func (m *NotificationMutation) ResetRead() {
	m.read = nil
}

// SetOwnerAccountID sets the "owner_account_id" field.
func (m *NotificationMutation) SetOwnerAccountID(x xid.ID) {
	m.owner = &x
}

// OwnerAccountID returns the value of the "owner_account_id" field in the mutation.
func (m *NotificationMutation) OwnerAccountID() (r xid.ID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerAccountID returns the old "owner_account_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldOwnerAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerAccountID: %w", err)
	}
	return oldValue.OwnerAccountID, nil
}

// ResetOwnerAccountID resets all changes to the "owner_account_id" field.
func (m *NotificationMutation) ResetOwnerAccountID() {
	m.owner = nil
}

// SetSourceAccountID sets the "source_account_id" field.
func (m *NotificationMutation) SetSourceAccountID(x xid.ID) {
	m.source = &x
}

// SourceAccountID returns the value of the "source_account_id" field in the mutation.
func (m *NotificationMutation) SourceAccountID() (r xid.ID, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceAccountID returns the old "source_account_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSourceAccountID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceAccountID: %w", err)
	}
	return oldValue.SourceAccountID, nil
}

// ClearSourceAccountID clears the value of the "source_account_id" field.
func (m *NotificationMutation) ClearSourceAccountID() {
	m.source = nil
	m.clearedFields[notification.FieldSourceAccountID] = struct{}{}
}

// SourceAccountIDCleared returns if the "source_account_id" field was cleared in this mutation.
func (m *NotificationMutation) SourceAccountIDCleared() bool {
	_, ok := m.clearedFields[notification.FieldSourceAccountID]
	return ok
}

// ResetSourceAccountID resets all changes to the "source_account_id" field.
func (m *NotificationMutation) ResetSourceAccountID() {
	m.source = nil
	delete(m.clearedFields, notification.FieldSourceAccountID)
}

// SetOwnerID sets the "owner" edge to the Account entity by id.
func (m *NotificationMutation) SetOwnerID(id xid.ID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *NotificationMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[notification.FieldOwnerAccountID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *NotificationMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NotificationMutation) OwnerID() (id xid.ID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) OwnerIDs() (ids []xid.ID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NotificationMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetSourceID sets the "source" edge to the Account entity by id.
func (m *NotificationMutation) SetSourceID(id xid.ID) {
	m.source = &id
}

// ClearSource clears the "source" edge to the Account entity.
func (m *NotificationMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[notification.FieldSourceAccountID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the Account entity was cleared.
func (m *NotificationMutation) SourceCleared() bool {
	return m.SourceAccountIDCleared() || m.clearedsource
}

// SourceID returns the "source" edge ID in the mutation.
func (m *NotificationMutation) SourceID() (id xid.ID, exists bool) {
	if m.source != nil {
		return *m.source, true
	}
	return
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) SourceIDs() (ids []xid.ID) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *NotificationMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notification.FieldDeletedAt)
	}
	if m.event_type != nil {
		fields = append(fields, notification.FieldEventType)
	}
	if m.datagraph_kind != nil {
		fields = append(fields, notification.FieldDatagraphKind)
	}
	if m.datagraph_id != nil {
		fields = append(fields, notification.FieldDatagraphID)
	}
	if m.read != nil {
		fields = append(fields, notification.FieldRead)
	}
	if m.owner != nil {
		fields = append(fields, notification.FieldOwnerAccountID)
	}
	if m.source != nil {
		fields = append(fields, notification.FieldSourceAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldDeletedAt:
		return m.DeletedAt()
	case notification.FieldEventType:
		return m.EventType()
	case notification.FieldDatagraphKind:
		return m.DatagraphKind()
	case notification.FieldDatagraphID:
		return m.DatagraphID()
	case notification.FieldRead:
		return m.Read()
	case notification.FieldOwnerAccountID:
		return m.OwnerAccountID()
	case notification.FieldSourceAccountID:
		return m.SourceAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notification.FieldEventType:
		return m.OldEventType(ctx)
	case notification.FieldDatagraphKind:
		return m.OldDatagraphKind(ctx)
	case notification.FieldDatagraphID:
		return m.OldDatagraphID(ctx)
	case notification.FieldRead:
		return m.OldRead(ctx)
	case notification.FieldOwnerAccountID:
		return m.OldOwnerAccountID(ctx)
	case notification.FieldSourceAccountID:
		return m.OldSourceAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notification.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case notification.FieldDatagraphKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatagraphKind(v)
		return nil
	case notification.FieldDatagraphID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatagraphID(v)
		return nil
	case notification.FieldRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRead(v)
		return nil
	case notification.FieldOwnerAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerAccountID(v)
		return nil
	case notification.FieldSourceAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldDeletedAt) {
		fields = append(fields, notification.FieldDeletedAt)
	}
	if m.FieldCleared(notification.FieldDatagraphKind) {
		fields = append(fields, notification.FieldDatagraphKind)
	}
	if m.FieldCleared(notification.FieldDatagraphID) {
		fields = append(fields, notification.FieldDatagraphID)
	}
	if m.FieldCleared(notification.FieldSourceAccountID) {
		fields = append(fields, notification.FieldSourceAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notification.FieldDatagraphKind:
		m.ClearDatagraphKind()
		return nil
	case notification.FieldDatagraphID:
		m.ClearDatagraphID()
		return nil
	case notification.FieldSourceAccountID:
		m.ClearSourceAccountID()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notification.FieldEventType:
		m.ResetEventType()
		return nil
	case notification.FieldDatagraphKind:
		m.ResetDatagraphKind()
		return nil
	case notification.FieldDatagraphID:
		m.ResetDatagraphID()
		return nil
	case notification.FieldRead:
		m.ResetRead()
		return nil
	case notification.FieldOwnerAccountID:
		m.ResetOwnerAccountID()
		return nil
	case notification.FieldSourceAccountID:
		m.ResetSourceAccountID()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, notification.EdgeOwner)
	}
	if m.source != nil {
		edges = append(edges, notification.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case notification.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, notification.EdgeOwner)
	}
	if m.clearedsource {
		edges = append(edges, notification.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeOwner:
		return m.clearedowner
	case notification.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeOwner:
		m.ClearOwner()
		return nil
	case notification.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeOwner:
		m.ResetOwner()
		return nil
	case notification.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                   Op
	typ                  string
	id                   *xid.ID
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	indexed_at           *time.Time
	first                *bool
	title                *string
	slug                 *string
	pinned               *bool
	body                 *string
	short                *string
	metadata             *map[string]interface{}
	visibility           *post.Visibility
	clearedFields        map[string]struct{}
	author               *xid.ID
	clearedauthor        bool
	category             *xid.ID
	clearedcategory      bool
	tags                 map[xid.ID]struct{}
	removedtags          map[xid.ID]struct{}
	clearedtags          bool
	root                 *xid.ID
	clearedroot          bool
	posts                map[xid.ID]struct{}
	removedposts         map[xid.ID]struct{}
	clearedposts         bool
	replyTo              *xid.ID
	clearedreplyTo       bool
	replies              map[xid.ID]struct{}
	removedreplies       map[xid.ID]struct{}
	clearedreplies       bool
	reacts               map[xid.ID]struct{}
	removedreacts        map[xid.ID]struct{}
	clearedreacts        bool
	likes                map[xid.ID]struct{}
	removedlikes         map[xid.ID]struct{}
	clearedlikes         bool
	mentions             map[xid.ID]struct{}
	removedmentions      map[xid.ID]struct{}
	clearedmentions      bool
	assets               map[xid.ID]struct{}
	removedassets        map[xid.ID]struct{}
	clearedassets        bool
	collections          map[xid.ID]struct{}
	removedcollections   map[xid.ID]struct{}
	clearedcollections   bool
	link                 *xid.ID
	clearedlink          bool
	content_links        map[xid.ID]struct{}
	removedcontent_links map[xid.ID]struct{}
	clearedcontent_links bool
	event                map[xid.ID]struct{}
	removedevent         map[xid.ID]struct{}
	clearedevent         bool
	post_tags            map[xid.ID]struct{}
	removedpost_tags     map[xid.ID]struct{}
	clearedpost_tags     bool
	done                 bool
	oldValue             func(context.Context) (*Post, error)
	predicates           []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id xid.ID) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PostMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PostMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PostMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[post.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PostMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PostMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, post.FieldDeletedAt)
}

// SetIndexedAt sets the "indexed_at" field.
func (m *PostMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *PostMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *PostMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[post.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *PostMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *PostMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, post.FieldIndexedAt)
}

// SetFirst sets the "first" field.
func (m *PostMutation) SetFirst(b bool) {
	m.first = &b
}

// First returns the value of the "first" field in the mutation.
func (m *PostMutation) First() (r bool, exists bool) {
	v := m.first
	if v == nil {
		return
	}
	return *v, true
}

// OldFirst returns the old "first" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldFirst(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirst: %w", err)
	}
	return oldValue.First, nil
}

// ResetFirst resets all changes to the "first" field.
func (m *PostMutation) ResetFirst() {
	m.first = nil
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *PostMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[post.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *PostMutation) TitleCleared() bool {
	_, ok := m.clearedFields[post.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, post.FieldTitle)
}

// SetSlug sets the "slug" field.
func (m *PostMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *PostMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[post.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *PostMutation) SlugCleared() bool {
	_, ok := m.clearedFields[post.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, post.FieldSlug)
}

// SetPinned sets the "pinned" field.
func (m *PostMutation) SetPinned(b bool) {
	m.pinned = &b
}

// Pinned returns the value of the "pinned" field in the mutation.
func (m *PostMutation) Pinned() (r bool, exists bool) {
	v := m.pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldPinned returns the old "pinned" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinned: %w", err)
	}
	return oldValue.Pinned, nil
}

// ResetPinned resets all changes to the "pinned" field.
func (m *PostMutation) ResetPinned() {
	m.pinned = nil
}

// SetRootPostID sets the "root_post_id" field.
func (m *PostMutation) SetRootPostID(x xid.ID) {
	m.root = &x
}

// RootPostID returns the value of the "root_post_id" field in the mutation.
func (m *PostMutation) RootPostID() (r xid.ID, exists bool) {
	v := m.root
	if v == nil {
		return
	}
	return *v, true
}

// OldRootPostID returns the old "root_post_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldRootPostID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootPostID: %w", err)
	}
	return oldValue.RootPostID, nil
}

// ClearRootPostID clears the value of the "root_post_id" field.
func (m *PostMutation) ClearRootPostID() {
	m.root = nil
	m.clearedFields[post.FieldRootPostID] = struct{}{}
}

// RootPostIDCleared returns if the "root_post_id" field was cleared in this mutation.
func (m *PostMutation) RootPostIDCleared() bool {
	_, ok := m.clearedFields[post.FieldRootPostID]
	return ok
}

// ResetRootPostID resets all changes to the "root_post_id" field.
func (m *PostMutation) ResetRootPostID() {
	m.root = nil
	delete(m.clearedFields, post.FieldRootPostID)
}

// SetReplyToPostID sets the "reply_to_post_id" field.
func (m *PostMutation) SetReplyToPostID(x xid.ID) {
	m.replyTo = &x
}

// ReplyToPostID returns the value of the "reply_to_post_id" field in the mutation.
func (m *PostMutation) ReplyToPostID() (r xid.ID, exists bool) {
	v := m.replyTo
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyToPostID returns the old "reply_to_post_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldReplyToPostID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyToPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyToPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyToPostID: %w", err)
	}
	return oldValue.ReplyToPostID, nil
}

// ClearReplyToPostID clears the value of the "reply_to_post_id" field.
func (m *PostMutation) ClearReplyToPostID() {
	m.replyTo = nil
	m.clearedFields[post.FieldReplyToPostID] = struct{}{}
}

// ReplyToPostIDCleared returns if the "reply_to_post_id" field was cleared in this mutation.
func (m *PostMutation) ReplyToPostIDCleared() bool {
	_, ok := m.clearedFields[post.FieldReplyToPostID]
	return ok
}

// ResetReplyToPostID resets all changes to the "reply_to_post_id" field.
func (m *PostMutation) ResetReplyToPostID() {
	m.replyTo = nil
	delete(m.clearedFields, post.FieldReplyToPostID)
}

// SetBody sets the "body" field.
func (m *PostMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *PostMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *PostMutation) ResetBody() {
	m.body = nil
}

// SetShort sets the "short" field.
func (m *PostMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *PostMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ResetShort resets all changes to the "short" field.
func (m *PostMutation) ResetShort() {
	m.short = nil
}

// SetMetadata sets the "metadata" field.
func (m *PostMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PostMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PostMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[post.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PostMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[post.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PostMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, post.FieldMetadata)
}

// SetVisibility sets the "visibility" field.
func (m *PostMutation) SetVisibility(po post.Visibility) {
	m.visibility = &po
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *PostMutation) Visibility() (r post.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldVisibility(ctx context.Context) (v post.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *PostMutation) ResetVisibility() {
	m.visibility = nil
}

// SetAccountPosts sets the "account_posts" field.
func (m *PostMutation) SetAccountPosts(x xid.ID) {
	m.author = &x
}

// AccountPosts returns the value of the "account_posts" field in the mutation.
func (m *PostMutation) AccountPosts() (r xid.ID, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountPosts returns the old "account_posts" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldAccountPosts(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountPosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountPosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountPosts: %w", err)
	}
	return oldValue.AccountPosts, nil
}

// ResetAccountPosts resets all changes to the "account_posts" field.
func (m *PostMutation) ResetAccountPosts() {
	m.author = nil
}

// SetCategoryID sets the "category_id" field.
func (m *PostMutation) SetCategoryID(x xid.ID) {
	m.category = &x
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *PostMutation) CategoryID() (r xid.ID, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCategoryID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *PostMutation) ClearCategoryID() {
	m.category = nil
	m.clearedFields[post.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *PostMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[post.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *PostMutation) ResetCategoryID() {
	m.category = nil
	delete(m.clearedFields, post.FieldCategoryID)
}

// SetLinkID sets the "link_id" field.
func (m *PostMutation) SetLinkID(x xid.ID) {
	m.link = &x
}

// LinkID returns the value of the "link_id" field in the mutation.
func (m *PostMutation) LinkID() (r xid.ID, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkID returns the old "link_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldLinkID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkID: %w", err)
	}
	return oldValue.LinkID, nil
}

// ClearLinkID clears the value of the "link_id" field.
func (m *PostMutation) ClearLinkID() {
	m.link = nil
	m.clearedFields[post.FieldLinkID] = struct{}{}
}

// LinkIDCleared returns if the "link_id" field was cleared in this mutation.
func (m *PostMutation) LinkIDCleared() bool {
	_, ok := m.clearedFields[post.FieldLinkID]
	return ok
}

// ResetLinkID resets all changes to the "link_id" field.
func (m *PostMutation) ResetLinkID() {
	m.link = nil
	delete(m.clearedFields, post.FieldLinkID)
}

// SetAuthorID sets the "author" edge to the Account entity by id.
func (m *PostMutation) SetAuthorID(id xid.ID) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the Account entity.
func (m *PostMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[post.FieldAccountPosts] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the Account entity was cleared.
func (m *PostMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *PostMutation) AuthorID() (id xid.ID, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *PostMutation) AuthorIDs() (ids []xid.ID) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *PostMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *PostMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[post.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *PostMutation) CategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *PostMutation) CategoryIDs() (ids []xid.ID) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *PostMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *PostMutation) AddTagIDs(ids ...xid.ID) {
	if m.tags == nil {
		m.tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *PostMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *PostMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *PostMutation) RemoveTagIDs(ids ...xid.ID) {
	if m.removedtags == nil {
		m.removedtags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *PostMutation) RemovedTagsIDs() (ids []xid.ID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *PostMutation) TagsIDs() (ids []xid.ID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *PostMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// SetRootID sets the "root" edge to the Post entity by id.
func (m *PostMutation) SetRootID(id xid.ID) {
	m.root = &id
}

// ClearRoot clears the "root" edge to the Post entity.
func (m *PostMutation) ClearRoot() {
	m.clearedroot = true
	m.clearedFields[post.FieldRootPostID] = struct{}{}
}

// RootCleared reports if the "root" edge to the Post entity was cleared.
func (m *PostMutation) RootCleared() bool {
	return m.RootPostIDCleared() || m.clearedroot
}

// RootID returns the "root" edge ID in the mutation.
func (m *PostMutation) RootID() (id xid.ID, exists bool) {
	if m.root != nil {
		return *m.root, true
	}
	return
}

// RootIDs returns the "root" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RootID instead. It exists only for internal usage by the builders.
func (m *PostMutation) RootIDs() (ids []xid.ID) {
	if id := m.root; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoot resets all changes to the "root" edge.
func (m *PostMutation) ResetRoot() {
	m.root = nil
	m.clearedroot = false
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *PostMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *PostMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *PostMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *PostMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *PostMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *PostMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *PostMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// SetReplyToID sets the "replyTo" edge to the Post entity by id.
func (m *PostMutation) SetReplyToID(id xid.ID) {
	m.replyTo = &id
}

// ClearReplyTo clears the "replyTo" edge to the Post entity.
func (m *PostMutation) ClearReplyTo() {
	m.clearedreplyTo = true
	m.clearedFields[post.FieldReplyToPostID] = struct{}{}
}

// ReplyToCleared reports if the "replyTo" edge to the Post entity was cleared.
func (m *PostMutation) ReplyToCleared() bool {
	return m.ReplyToPostIDCleared() || m.clearedreplyTo
}

// ReplyToID returns the "replyTo" edge ID in the mutation.
func (m *PostMutation) ReplyToID() (id xid.ID, exists bool) {
	if m.replyTo != nil {
		return *m.replyTo, true
	}
	return
}

// ReplyToIDs returns the "replyTo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReplyToID instead. It exists only for internal usage by the builders.
func (m *PostMutation) ReplyToIDs() (ids []xid.ID) {
	if id := m.replyTo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReplyTo resets all changes to the "replyTo" edge.
func (m *PostMutation) ResetReplyTo() {
	m.replyTo = nil
	m.clearedreplyTo = false
}

// AddReplyIDs adds the "replies" edge to the Post entity by ids.
func (m *PostMutation) AddReplyIDs(ids ...xid.ID) {
	if m.replies == nil {
		m.replies = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the Post entity.
func (m *PostMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the Post entity was cleared.
func (m *PostMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the Post entity by IDs.
func (m *PostMutation) RemoveReplyIDs(ids ...xid.ID) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the Post entity.
func (m *PostMutation) RemovedRepliesIDs() (ids []xid.ID) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *PostMutation) RepliesIDs() (ids []xid.ID) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *PostMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// AddReactIDs adds the "reacts" edge to the React entity by ids.
func (m *PostMutation) AddReactIDs(ids ...xid.ID) {
	if m.reacts == nil {
		m.reacts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.reacts[ids[i]] = struct{}{}
	}
}

// ClearReacts clears the "reacts" edge to the React entity.
func (m *PostMutation) ClearReacts() {
	m.clearedreacts = true
}

// ReactsCleared reports if the "reacts" edge to the React entity was cleared.
func (m *PostMutation) ReactsCleared() bool {
	return m.clearedreacts
}

// RemoveReactIDs removes the "reacts" edge to the React entity by IDs.
func (m *PostMutation) RemoveReactIDs(ids ...xid.ID) {
	if m.removedreacts == nil {
		m.removedreacts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.reacts, ids[i])
		m.removedreacts[ids[i]] = struct{}{}
	}
}

// RemovedReacts returns the removed IDs of the "reacts" edge to the React entity.
func (m *PostMutation) RemovedReactsIDs() (ids []xid.ID) {
	for id := range m.removedreacts {
		ids = append(ids, id)
	}
	return
}

// ReactsIDs returns the "reacts" edge IDs in the mutation.
func (m *PostMutation) ReactsIDs() (ids []xid.ID) {
	for id := range m.reacts {
		ids = append(ids, id)
	}
	return
}

// ResetReacts resets all changes to the "reacts" edge.
func (m *PostMutation) ResetReacts() {
	m.reacts = nil
	m.clearedreacts = false
	m.removedreacts = nil
}

// AddLikeIDs adds the "likes" edge to the LikePost entity by ids.
func (m *PostMutation) AddLikeIDs(ids ...xid.ID) {
	if m.likes == nil {
		m.likes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the LikePost entity.
func (m *PostMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the LikePost entity was cleared.
func (m *PostMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the LikePost entity by IDs.
func (m *PostMutation) RemoveLikeIDs(ids ...xid.ID) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the LikePost entity.
func (m *PostMutation) RemovedLikesIDs() (ids []xid.ID) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *PostMutation) LikesIDs() (ids []xid.ID) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *PostMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// AddMentionIDs adds the "mentions" edge to the MentionProfile entity by ids.
func (m *PostMutation) AddMentionIDs(ids ...xid.ID) {
	if m.mentions == nil {
		m.mentions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.mentions[ids[i]] = struct{}{}
	}
}

// ClearMentions clears the "mentions" edge to the MentionProfile entity.
func (m *PostMutation) ClearMentions() {
	m.clearedmentions = true
}

// MentionsCleared reports if the "mentions" edge to the MentionProfile entity was cleared.
func (m *PostMutation) MentionsCleared() bool {
	return m.clearedmentions
}

// RemoveMentionIDs removes the "mentions" edge to the MentionProfile entity by IDs.
func (m *PostMutation) RemoveMentionIDs(ids ...xid.ID) {
	if m.removedmentions == nil {
		m.removedmentions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.mentions, ids[i])
		m.removedmentions[ids[i]] = struct{}{}
	}
}

// RemovedMentions returns the removed IDs of the "mentions" edge to the MentionProfile entity.
func (m *PostMutation) RemovedMentionsIDs() (ids []xid.ID) {
	for id := range m.removedmentions {
		ids = append(ids, id)
	}
	return
}

// MentionsIDs returns the "mentions" edge IDs in the mutation.
func (m *PostMutation) MentionsIDs() (ids []xid.ID) {
	for id := range m.mentions {
		ids = append(ids, id)
	}
	return
}

// ResetMentions resets all changes to the "mentions" edge.
func (m *PostMutation) ResetMentions() {
	m.mentions = nil
	m.clearedmentions = false
	m.removedmentions = nil
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *PostMutation) AddAssetIDs(ids ...xid.ID) {
	if m.assets == nil {
		m.assets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *PostMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *PostMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *PostMutation) RemoveAssetIDs(ids ...xid.ID) {
	if m.removedassets == nil {
		m.removedassets = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *PostMutation) RemovedAssetsIDs() (ids []xid.ID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *PostMutation) AssetsIDs() (ids []xid.ID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *PostMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// AddCollectionIDs adds the "collections" edge to the Collection entity by ids.
func (m *PostMutation) AddCollectionIDs(ids ...xid.ID) {
	if m.collections == nil {
		m.collections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.collections[ids[i]] = struct{}{}
	}
}

// ClearCollections clears the "collections" edge to the Collection entity.
func (m *PostMutation) ClearCollections() {
	m.clearedcollections = true
}

// CollectionsCleared reports if the "collections" edge to the Collection entity was cleared.
func (m *PostMutation) CollectionsCleared() bool {
	return m.clearedcollections
}

// RemoveCollectionIDs removes the "collections" edge to the Collection entity by IDs.
func (m *PostMutation) RemoveCollectionIDs(ids ...xid.ID) {
	if m.removedcollections == nil {
		m.removedcollections = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.collections, ids[i])
		m.removedcollections[ids[i]] = struct{}{}
	}
}

// RemovedCollections returns the removed IDs of the "collections" edge to the Collection entity.
func (m *PostMutation) RemovedCollectionsIDs() (ids []xid.ID) {
	for id := range m.removedcollections {
		ids = append(ids, id)
	}
	return
}

// CollectionsIDs returns the "collections" edge IDs in the mutation.
func (m *PostMutation) CollectionsIDs() (ids []xid.ID) {
	for id := range m.collections {
		ids = append(ids, id)
	}
	return
}

// ResetCollections resets all changes to the "collections" edge.
func (m *PostMutation) ResetCollections() {
	m.collections = nil
	m.clearedcollections = false
	m.removedcollections = nil
}

// ClearLink clears the "link" edge to the Link entity.
func (m *PostMutation) ClearLink() {
	m.clearedlink = true
	m.clearedFields[post.FieldLinkID] = struct{}{}
}

// LinkCleared reports if the "link" edge to the Link entity was cleared.
func (m *PostMutation) LinkCleared() bool {
	return m.LinkIDCleared() || m.clearedlink
}

// LinkIDs returns the "link" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LinkID instead. It exists only for internal usage by the builders.
func (m *PostMutation) LinkIDs() (ids []xid.ID) {
	if id := m.link; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLink resets all changes to the "link" edge.
func (m *PostMutation) ResetLink() {
	m.link = nil
	m.clearedlink = false
}

// AddContentLinkIDs adds the "content_links" edge to the Link entity by ids.
func (m *PostMutation) AddContentLinkIDs(ids ...xid.ID) {
	if m.content_links == nil {
		m.content_links = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.content_links[ids[i]] = struct{}{}
	}
}

// ClearContentLinks clears the "content_links" edge to the Link entity.
func (m *PostMutation) ClearContentLinks() {
	m.clearedcontent_links = true
}

// ContentLinksCleared reports if the "content_links" edge to the Link entity was cleared.
func (m *PostMutation) ContentLinksCleared() bool {
	return m.clearedcontent_links
}

// RemoveContentLinkIDs removes the "content_links" edge to the Link entity by IDs.
func (m *PostMutation) RemoveContentLinkIDs(ids ...xid.ID) {
	if m.removedcontent_links == nil {
		m.removedcontent_links = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.content_links, ids[i])
		m.removedcontent_links[ids[i]] = struct{}{}
	}
}

// RemovedContentLinks returns the removed IDs of the "content_links" edge to the Link entity.
func (m *PostMutation) RemovedContentLinksIDs() (ids []xid.ID) {
	for id := range m.removedcontent_links {
		ids = append(ids, id)
	}
	return
}

// ContentLinksIDs returns the "content_links" edge IDs in the mutation.
func (m *PostMutation) ContentLinksIDs() (ids []xid.ID) {
	for id := range m.content_links {
		ids = append(ids, id)
	}
	return
}

// ResetContentLinks resets all changes to the "content_links" edge.
func (m *PostMutation) ResetContentLinks() {
	m.content_links = nil
	m.clearedcontent_links = false
	m.removedcontent_links = nil
}

// AddEventIDs adds the "event" edge to the Event entity by ids.
func (m *PostMutation) AddEventIDs(ids ...xid.ID) {
	if m.event == nil {
		m.event = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.event[ids[i]] = struct{}{}
	}
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *PostMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *PostMutation) EventCleared() bool {
	return m.clearedevent
}

// RemoveEventIDs removes the "event" edge to the Event entity by IDs.
func (m *PostMutation) RemoveEventIDs(ids ...xid.ID) {
	if m.removedevent == nil {
		m.removedevent = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.event, ids[i])
		m.removedevent[ids[i]] = struct{}{}
	}
}

// RemovedEvent returns the removed IDs of the "event" edge to the Event entity.
func (m *PostMutation) RemovedEventIDs() (ids []xid.ID) {
	for id := range m.removedevent {
		ids = append(ids, id)
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
func (m *PostMutation) EventIDs() (ids []xid.ID) {
	for id := range m.event {
		ids = append(ids, id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *PostMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
	m.removedevent = nil
}

// AddPostTagIDs adds the "post_tags" edge to the TagPost entity by ids.
func (m *PostMutation) AddPostTagIDs(ids ...xid.ID) {
	if m.post_tags == nil {
		m.post_tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.post_tags[ids[i]] = struct{}{}
	}
}

// ClearPostTags clears the "post_tags" edge to the TagPost entity.
func (m *PostMutation) ClearPostTags() {
	m.clearedpost_tags = true
}

// PostTagsCleared reports if the "post_tags" edge to the TagPost entity was cleared.
func (m *PostMutation) PostTagsCleared() bool {
	return m.clearedpost_tags
}

// RemovePostTagIDs removes the "post_tags" edge to the TagPost entity by IDs.
func (m *PostMutation) RemovePostTagIDs(ids ...xid.ID) {
	if m.removedpost_tags == nil {
		m.removedpost_tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.post_tags, ids[i])
		m.removedpost_tags[ids[i]] = struct{}{}
	}
}

// RemovedPostTags returns the removed IDs of the "post_tags" edge to the TagPost entity.
func (m *PostMutation) RemovedPostTagsIDs() (ids []xid.ID) {
	for id := range m.removedpost_tags {
		ids = append(ids, id)
	}
	return
}

// PostTagsIDs returns the "post_tags" edge IDs in the mutation.
func (m *PostMutation) PostTagsIDs() (ids []xid.ID) {
	for id := range m.post_tags {
		ids = append(ids, id)
	}
	return
}

// ResetPostTags resets all changes to the "post_tags" edge.
func (m *PostMutation) ResetPostTags() {
	m.post_tags = nil
	m.clearedpost_tags = false
	m.removedpost_tags = nil
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, post.FieldDeletedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, post.FieldIndexedAt)
	}
	if m.first != nil {
		fields = append(fields, post.FieldFirst)
	}
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, post.FieldSlug)
	}
	if m.pinned != nil {
		fields = append(fields, post.FieldPinned)
	}
	if m.root != nil {
		fields = append(fields, post.FieldRootPostID)
	}
	if m.replyTo != nil {
		fields = append(fields, post.FieldReplyToPostID)
	}
	if m.body != nil {
		fields = append(fields, post.FieldBody)
	}
	if m.short != nil {
		fields = append(fields, post.FieldShort)
	}
	if m.metadata != nil {
		fields = append(fields, post.FieldMetadata)
	}
	if m.visibility != nil {
		fields = append(fields, post.FieldVisibility)
	}
	if m.author != nil {
		fields = append(fields, post.FieldAccountPosts)
	}
	if m.category != nil {
		fields = append(fields, post.FieldCategoryID)
	}
	if m.link != nil {
		fields = append(fields, post.FieldLinkID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldDeletedAt:
		return m.DeletedAt()
	case post.FieldIndexedAt:
		return m.IndexedAt()
	case post.FieldFirst:
		return m.First()
	case post.FieldTitle:
		return m.Title()
	case post.FieldSlug:
		return m.Slug()
	case post.FieldPinned:
		return m.Pinned()
	case post.FieldRootPostID:
		return m.RootPostID()
	case post.FieldReplyToPostID:
		return m.ReplyToPostID()
	case post.FieldBody:
		return m.Body()
	case post.FieldShort:
		return m.Short()
	case post.FieldMetadata:
		return m.Metadata()
	case post.FieldVisibility:
		return m.Visibility()
	case post.FieldAccountPosts:
		return m.AccountPosts()
	case post.FieldCategoryID:
		return m.CategoryID()
	case post.FieldLinkID:
		return m.LinkID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case post.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case post.FieldFirst:
		return m.OldFirst(ctx)
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldSlug:
		return m.OldSlug(ctx)
	case post.FieldPinned:
		return m.OldPinned(ctx)
	case post.FieldRootPostID:
		return m.OldRootPostID(ctx)
	case post.FieldReplyToPostID:
		return m.OldReplyToPostID(ctx)
	case post.FieldBody:
		return m.OldBody(ctx)
	case post.FieldShort:
		return m.OldShort(ctx)
	case post.FieldMetadata:
		return m.OldMetadata(ctx)
	case post.FieldVisibility:
		return m.OldVisibility(ctx)
	case post.FieldAccountPosts:
		return m.OldAccountPosts(ctx)
	case post.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case post.FieldLinkID:
		return m.OldLinkID(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case post.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case post.FieldFirst:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirst(v)
		return nil
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case post.FieldPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinned(v)
		return nil
	case post.FieldRootPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootPostID(v)
		return nil
	case post.FieldReplyToPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyToPostID(v)
		return nil
	case post.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case post.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case post.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case post.FieldVisibility:
		v, ok := value.(post.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case post.FieldAccountPosts:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountPosts(v)
		return nil
	case post.FieldCategoryID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case post.FieldLinkID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkID(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldDeletedAt) {
		fields = append(fields, post.FieldDeletedAt)
	}
	if m.FieldCleared(post.FieldIndexedAt) {
		fields = append(fields, post.FieldIndexedAt)
	}
	if m.FieldCleared(post.FieldTitle) {
		fields = append(fields, post.FieldTitle)
	}
	if m.FieldCleared(post.FieldSlug) {
		fields = append(fields, post.FieldSlug)
	}
	if m.FieldCleared(post.FieldRootPostID) {
		fields = append(fields, post.FieldRootPostID)
	}
	if m.FieldCleared(post.FieldReplyToPostID) {
		fields = append(fields, post.FieldReplyToPostID)
	}
	if m.FieldCleared(post.FieldMetadata) {
		fields = append(fields, post.FieldMetadata)
	}
	if m.FieldCleared(post.FieldCategoryID) {
		fields = append(fields, post.FieldCategoryID)
	}
	if m.FieldCleared(post.FieldLinkID) {
		fields = append(fields, post.FieldLinkID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case post.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case post.FieldTitle:
		m.ClearTitle()
		return nil
	case post.FieldSlug:
		m.ClearSlug()
		return nil
	case post.FieldRootPostID:
		m.ClearRootPostID()
		return nil
	case post.FieldReplyToPostID:
		m.ClearReplyToPostID()
		return nil
	case post.FieldMetadata:
		m.ClearMetadata()
		return nil
	case post.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case post.FieldLinkID:
		m.ClearLinkID()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case post.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case post.FieldFirst:
		m.ResetFirst()
		return nil
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldSlug:
		m.ResetSlug()
		return nil
	case post.FieldPinned:
		m.ResetPinned()
		return nil
	case post.FieldRootPostID:
		m.ResetRootPostID()
		return nil
	case post.FieldReplyToPostID:
		m.ResetReplyToPostID()
		return nil
	case post.FieldBody:
		m.ResetBody()
		return nil
	case post.FieldShort:
		m.ResetShort()
		return nil
	case post.FieldMetadata:
		m.ResetMetadata()
		return nil
	case post.FieldVisibility:
		m.ResetVisibility()
		return nil
	case post.FieldAccountPosts:
		m.ResetAccountPosts()
		return nil
	case post.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case post.FieldLinkID:
		m.ResetLinkID()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.author != nil {
		edges = append(edges, post.EdgeAuthor)
	}
	if m.category != nil {
		edges = append(edges, post.EdgeCategory)
	}
	if m.tags != nil {
		edges = append(edges, post.EdgeTags)
	}
	if m.root != nil {
		edges = append(edges, post.EdgeRoot)
	}
	if m.posts != nil {
		edges = append(edges, post.EdgePosts)
	}
	if m.replyTo != nil {
		edges = append(edges, post.EdgeReplyTo)
	}
	if m.replies != nil {
		edges = append(edges, post.EdgeReplies)
	}
	if m.reacts != nil {
		edges = append(edges, post.EdgeReacts)
	}
	if m.likes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	if m.mentions != nil {
		edges = append(edges, post.EdgeMentions)
	}
	if m.assets != nil {
		edges = append(edges, post.EdgeAssets)
	}
	if m.collections != nil {
		edges = append(edges, post.EdgeCollections)
	}
	if m.link != nil {
		edges = append(edges, post.EdgeLink)
	}
	if m.content_links != nil {
		edges = append(edges, post.EdgeContentLinks)
	}
	if m.event != nil {
		edges = append(edges, post.EdgeEvent)
	}
	if m.post_tags != nil {
		edges = append(edges, post.EdgePostTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeRoot:
		if id := m.root; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReplyTo:
		if id := m.replyTo; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.reacts))
		for id := range m.reacts {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeMentions:
		ids := make([]ent.Value, 0, len(m.mentions))
		for id := range m.mentions {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.collections))
		for id := range m.collections {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLink:
		if id := m.link; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeContentLinks:
		ids := make([]ent.Value, 0, len(m.content_links))
		for id := range m.content_links {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.event))
		for id := range m.event {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostTags:
		ids := make([]ent.Value, 0, len(m.post_tags))
		for id := range m.post_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedtags != nil {
		edges = append(edges, post.EdgeTags)
	}
	if m.removedposts != nil {
		edges = append(edges, post.EdgePosts)
	}
	if m.removedreplies != nil {
		edges = append(edges, post.EdgeReplies)
	}
	if m.removedreacts != nil {
		edges = append(edges, post.EdgeReacts)
	}
	if m.removedlikes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	if m.removedmentions != nil {
		edges = append(edges, post.EdgeMentions)
	}
	if m.removedassets != nil {
		edges = append(edges, post.EdgeAssets)
	}
	if m.removedcollections != nil {
		edges = append(edges, post.EdgeCollections)
	}
	if m.removedcontent_links != nil {
		edges = append(edges, post.EdgeContentLinks)
	}
	if m.removedevent != nil {
		edges = append(edges, post.EdgeEvent)
	}
	if m.removedpost_tags != nil {
		edges = append(edges, post.EdgePostTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeReacts:
		ids := make([]ent.Value, 0, len(m.removedreacts))
		for id := range m.removedreacts {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeMentions:
		ids := make([]ent.Value, 0, len(m.removedmentions))
		for id := range m.removedmentions {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeCollections:
		ids := make([]ent.Value, 0, len(m.removedcollections))
		for id := range m.removedcollections {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeContentLinks:
		ids := make([]ent.Value, 0, len(m.removedcontent_links))
		for id := range m.removedcontent_links {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.removedevent))
		for id := range m.removedevent {
			ids = append(ids, id)
		}
		return ids
	case post.EdgePostTags:
		ids := make([]ent.Value, 0, len(m.removedpost_tags))
		for id := range m.removedpost_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedauthor {
		edges = append(edges, post.EdgeAuthor)
	}
	if m.clearedcategory {
		edges = append(edges, post.EdgeCategory)
	}
	if m.clearedtags {
		edges = append(edges, post.EdgeTags)
	}
	if m.clearedroot {
		edges = append(edges, post.EdgeRoot)
	}
	if m.clearedposts {
		edges = append(edges, post.EdgePosts)
	}
	if m.clearedreplyTo {
		edges = append(edges, post.EdgeReplyTo)
	}
	if m.clearedreplies {
		edges = append(edges, post.EdgeReplies)
	}
	if m.clearedreacts {
		edges = append(edges, post.EdgeReacts)
	}
	if m.clearedlikes {
		edges = append(edges, post.EdgeLikes)
	}
	if m.clearedmentions {
		edges = append(edges, post.EdgeMentions)
	}
	if m.clearedassets {
		edges = append(edges, post.EdgeAssets)
	}
	if m.clearedcollections {
		edges = append(edges, post.EdgeCollections)
	}
	if m.clearedlink {
		edges = append(edges, post.EdgeLink)
	}
	if m.clearedcontent_links {
		edges = append(edges, post.EdgeContentLinks)
	}
	if m.clearedevent {
		edges = append(edges, post.EdgeEvent)
	}
	if m.clearedpost_tags {
		edges = append(edges, post.EdgePostTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeAuthor:
		return m.clearedauthor
	case post.EdgeCategory:
		return m.clearedcategory
	case post.EdgeTags:
		return m.clearedtags
	case post.EdgeRoot:
		return m.clearedroot
	case post.EdgePosts:
		return m.clearedposts
	case post.EdgeReplyTo:
		return m.clearedreplyTo
	case post.EdgeReplies:
		return m.clearedreplies
	case post.EdgeReacts:
		return m.clearedreacts
	case post.EdgeLikes:
		return m.clearedlikes
	case post.EdgeMentions:
		return m.clearedmentions
	case post.EdgeAssets:
		return m.clearedassets
	case post.EdgeCollections:
		return m.clearedcollections
	case post.EdgeLink:
		return m.clearedlink
	case post.EdgeContentLinks:
		return m.clearedcontent_links
	case post.EdgeEvent:
		return m.clearedevent
	case post.EdgePostTags:
		return m.clearedpost_tags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case post.EdgeCategory:
		m.ClearCategory()
		return nil
	case post.EdgeRoot:
		m.ClearRoot()
		return nil
	case post.EdgeReplyTo:
		m.ClearReplyTo()
		return nil
	case post.EdgeLink:
		m.ClearLink()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case post.EdgeCategory:
		m.ResetCategory()
		return nil
	case post.EdgeTags:
		m.ResetTags()
		return nil
	case post.EdgeRoot:
		m.ResetRoot()
		return nil
	case post.EdgePosts:
		m.ResetPosts()
		return nil
	case post.EdgeReplyTo:
		m.ResetReplyTo()
		return nil
	case post.EdgeReplies:
		m.ResetReplies()
		return nil
	case post.EdgeReacts:
		m.ResetReacts()
		return nil
	case post.EdgeLikes:
		m.ResetLikes()
		return nil
	case post.EdgeMentions:
		m.ResetMentions()
		return nil
	case post.EdgeAssets:
		m.ResetAssets()
		return nil
	case post.EdgeCollections:
		m.ResetCollections()
		return nil
	case post.EdgeLink:
		m.ResetLink()
		return nil
	case post.EdgeContentLinks:
		m.ResetContentLinks()
		return nil
	case post.EdgeEvent:
		m.ResetEvent()
		return nil
	case post.EdgePostTags:
		m.ResetPostTags()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// QuestionMutation represents an operation that mutates the Question nodes in the graph.
type QuestionMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	indexed_at    *time.Time
	slug          *string
	query         *string
	result        *string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	author        *xid.ID
	clearedauthor bool
	done          bool
	oldValue      func(context.Context) (*Question, error)
	predicates    []predicate.Question
}

var _ ent.Mutation = (*QuestionMutation)(nil)

// questionOption allows management of the mutation configuration using functional options.
type questionOption func(*QuestionMutation)

// newQuestionMutation creates new mutation for the Question entity.
func newQuestionMutation(c config, op Op, opts ...questionOption) *QuestionMutation {
	m := &QuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuestionID sets the ID field of the mutation.
func withQuestionID(id xid.ID) questionOption {
	return func(m *QuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *Question
		)
		m.oldValue = func(ctx context.Context) (*Question, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Question.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuestion sets the old Question of the mutation.
func withQuestion(node *Question) questionOption {
	return func(m *QuestionMutation) {
		m.oldValue = func(context.Context) (*Question, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Question entities.
func (m *QuestionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuestionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuestionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Question.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *QuestionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *QuestionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *QuestionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetIndexedAt sets the "indexed_at" field.
func (m *QuestionMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *QuestionMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldIndexedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ClearIndexedAt clears the value of the "indexed_at" field.
func (m *QuestionMutation) ClearIndexedAt() {
	m.indexed_at = nil
	m.clearedFields[question.FieldIndexedAt] = struct{}{}
}

// IndexedAtCleared returns if the "indexed_at" field was cleared in this mutation.
func (m *QuestionMutation) IndexedAtCleared() bool {
	_, ok := m.clearedFields[question.FieldIndexedAt]
	return ok
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *QuestionMutation) ResetIndexedAt() {
	m.indexed_at = nil
	delete(m.clearedFields, question.FieldIndexedAt)
}

// SetSlug sets the "slug" field.
func (m *QuestionMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *QuestionMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *QuestionMutation) ResetSlug() {
	m.slug = nil
}

// SetQuery sets the "query" field.
func (m *QuestionMutation) SetQuery(s string) {
	m.query = &s
}

// Query returns the value of the "query" field in the mutation.
func (m *QuestionMutation) Query() (r string, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ResetQuery resets all changes to the "query" field.
func (m *QuestionMutation) ResetQuery() {
	m.query = nil
}

// SetResult sets the "result" field.
func (m *QuestionMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *QuestionMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *QuestionMutation) ResetResult() {
	m.result = nil
}

// SetMetadata sets the "metadata" field.
func (m *QuestionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *QuestionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *QuestionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[question.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *QuestionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[question.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *QuestionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, question.FieldMetadata)
}

// SetAccountID sets the "account_id" field.
func (m *QuestionMutation) SetAccountID(x xid.ID) {
	m.author = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *QuestionMutation) AccountID() (r xid.ID, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *QuestionMutation) ClearAccountID() {
	m.author = nil
	m.clearedFields[question.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *QuestionMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[question.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *QuestionMutation) ResetAccountID() {
	m.author = nil
	delete(m.clearedFields, question.FieldAccountID)
}

// SetAuthorID sets the "author" edge to the Account entity by id.
func (m *QuestionMutation) SetAuthorID(id xid.ID) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the Account entity.
func (m *QuestionMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[question.FieldAccountID] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the Account entity was cleared.
func (m *QuestionMutation) AuthorCleared() bool {
	return m.AccountIDCleared() || m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *QuestionMutation) AuthorID() (id xid.ID, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *QuestionMutation) AuthorIDs() (ids []xid.ID) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *QuestionMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// Where appends a list predicates to the QuestionMutation builder.
func (m *QuestionMutation) Where(ps ...predicate.Question) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Question, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Question).
func (m *QuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuestionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, question.FieldCreatedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, question.FieldIndexedAt)
	}
	if m.slug != nil {
		fields = append(fields, question.FieldSlug)
	}
	if m.query != nil {
		fields = append(fields, question.FieldQuery)
	}
	if m.result != nil {
		fields = append(fields, question.FieldResult)
	}
	if m.metadata != nil {
		fields = append(fields, question.FieldMetadata)
	}
	if m.author != nil {
		fields = append(fields, question.FieldAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case question.FieldCreatedAt:
		return m.CreatedAt()
	case question.FieldIndexedAt:
		return m.IndexedAt()
	case question.FieldSlug:
		return m.Slug()
	case question.FieldQuery:
		return m.Query()
	case question.FieldResult:
		return m.Result()
	case question.FieldMetadata:
		return m.Metadata()
	case question.FieldAccountID:
		return m.AccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case question.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case question.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case question.FieldSlug:
		return m.OldSlug(ctx)
	case question.FieldQuery:
		return m.OldQuery(ctx)
	case question.FieldResult:
		return m.OldResult(ctx)
	case question.FieldMetadata:
		return m.OldMetadata(ctx)
	case question.FieldAccountID:
		return m.OldAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown Question field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case question.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case question.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case question.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case question.FieldQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	case question.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case question.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case question.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuestionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuestionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Question numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(question.FieldIndexedAt) {
		fields = append(fields, question.FieldIndexedAt)
	}
	if m.FieldCleared(question.FieldMetadata) {
		fields = append(fields, question.FieldMetadata)
	}
	if m.FieldCleared(question.FieldAccountID) {
		fields = append(fields, question.FieldAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuestionMutation) ClearField(name string) error {
	switch name {
	case question.FieldIndexedAt:
		m.ClearIndexedAt()
		return nil
	case question.FieldMetadata:
		m.ClearMetadata()
		return nil
	case question.FieldAccountID:
		m.ClearAccountID()
		return nil
	}
	return fmt.Errorf("unknown Question nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuestionMutation) ResetField(name string) error {
	switch name {
	case question.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case question.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case question.FieldSlug:
		m.ResetSlug()
		return nil
	case question.FieldQuery:
		m.ResetQuery()
		return nil
	case question.FieldResult:
		m.ResetResult()
		return nil
	case question.FieldMetadata:
		m.ResetMetadata()
		return nil
	case question.FieldAccountID:
		m.ResetAccountID()
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.author != nil {
		edges = append(edges, question.EdgeAuthor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuestionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedauthor {
		edges = append(edges, question.EdgeAuthor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case question.EdgeAuthor:
		return m.clearedauthor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuestionMutation) ClearEdge(name string) error {
	switch name {
	case question.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Question unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuestionMutation) ResetEdge(name string) error {
	switch name {
	case question.EdgeAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown Question edge %s", name)
}

// ReactMutation represents an operation that mutates the React nodes in the graph.
type ReactMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	emoji          *string
	clearedFields  map[string]struct{}
	account        *xid.ID
	clearedaccount bool
	_Post          *xid.ID
	cleared_Post   bool
	done           bool
	oldValue       func(context.Context) (*React, error)
	predicates     []predicate.React
}

var _ ent.Mutation = (*ReactMutation)(nil)

// reactOption allows management of the mutation configuration using functional options.
type reactOption func(*ReactMutation)

// newReactMutation creates new mutation for the React entity.
func newReactMutation(c config, op Op, opts ...reactOption) *ReactMutation {
	m := &ReactMutation{
		config:        c,
		op:            op,
		typ:           TypeReact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReactID sets the ID field of the mutation.
func withReactID(id xid.ID) reactOption {
	return func(m *ReactMutation) {
		var (
			err   error
			once  sync.Once
			value *React
		)
		m.oldValue = func(ctx context.Context) (*React, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().React.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReact sets the old React of the mutation.
func withReact(node *React) reactOption {
	return func(m *ReactMutation) {
		m.oldValue = func(context.Context) (*React, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of React entities.
func (m *ReactMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReactMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReactMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().React.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccountID sets the "account_id" field.
func (m *ReactMutation) SetAccountID(x xid.ID) {
	m.account = &x
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *ReactMutation) AccountID() (r xid.ID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldAccountID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *ReactMutation) ResetAccountID() {
	m.account = nil
}

// SetPostID sets the "post_id" field.
func (m *ReactMutation) SetPostID(x xid.ID) {
	m._Post = &x
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *ReactMutation) PostID() (r xid.ID, exists bool) {
	v := m._Post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldPostID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *ReactMutation) ResetPostID() {
	m._Post = nil
}

// SetEmoji sets the "emoji" field.
func (m *ReactMutation) SetEmoji(s string) {
	m.emoji = &s
}

// Emoji returns the value of the "emoji" field in the mutation.
func (m *ReactMutation) Emoji() (r string, exists bool) {
	v := m.emoji
	if v == nil {
		return
	}
	return *v, true
}

// OldEmoji returns the old "emoji" field's value of the React entity.
// If the React object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactMutation) OldEmoji(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmoji is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmoji requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmoji: %w", err)
	}
	return oldValue.Emoji, nil
}

// ResetEmoji resets all changes to the "emoji" field.
func (m *ReactMutation) ResetEmoji() {
	m.emoji = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *ReactMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[react.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *ReactMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *ReactMutation) AccountIDs() (ids []xid.ID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *ReactMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearPost clears the "Post" edge to the Post entity.
func (m *ReactMutation) ClearPost() {
	m.cleared_Post = true
	m.clearedFields[react.FieldPostID] = struct{}{}
}

// PostCleared reports if the "Post" edge to the Post entity was cleared.
func (m *ReactMutation) PostCleared() bool {
	return m.cleared_Post
}

// PostIDs returns the "Post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *ReactMutation) PostIDs() (ids []xid.ID) {
	if id := m._Post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "Post" edge.
func (m *ReactMutation) ResetPost() {
	m._Post = nil
	m.cleared_Post = false
}

// Where appends a list predicates to the ReactMutation builder.
func (m *ReactMutation) Where(ps ...predicate.React) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.React, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (React).
func (m *ReactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReactMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, react.FieldCreatedAt)
	}
	if m.account != nil {
		fields = append(fields, react.FieldAccountID)
	}
	if m._Post != nil {
		fields = append(fields, react.FieldPostID)
	}
	if m.emoji != nil {
		fields = append(fields, react.FieldEmoji)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case react.FieldCreatedAt:
		return m.CreatedAt()
	case react.FieldAccountID:
		return m.AccountID()
	case react.FieldPostID:
		return m.PostID()
	case react.FieldEmoji:
		return m.Emoji()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case react.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case react.FieldAccountID:
		return m.OldAccountID(ctx)
	case react.FieldPostID:
		return m.OldPostID(ctx)
	case react.FieldEmoji:
		return m.OldEmoji(ctx)
	}
	return nil, fmt.Errorf("unknown React field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case react.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case react.FieldAccountID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case react.FieldPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case react.FieldEmoji:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmoji(v)
		return nil
	}
	return fmt.Errorf("unknown React field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown React numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown React nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReactMutation) ResetField(name string) error {
	switch name {
	case react.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case react.FieldAccountID:
		m.ResetAccountID()
		return nil
	case react.FieldPostID:
		m.ResetPostID()
		return nil
	case react.FieldEmoji:
		m.ResetEmoji()
		return nil
	}
	return fmt.Errorf("unknown React field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReactMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, react.EdgeAccount)
	}
	if m._Post != nil {
		edges = append(edges, react.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case react.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case react.EdgePost:
		if id := m._Post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, react.EdgeAccount)
	}
	if m.cleared_Post {
		edges = append(edges, react.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReactMutation) EdgeCleared(name string) bool {
	switch name {
	case react.EdgeAccount:
		return m.clearedaccount
	case react.EdgePost:
		return m.cleared_Post
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReactMutation) ClearEdge(name string) error {
	switch name {
	case react.EdgeAccount:
		m.ClearAccount()
		return nil
	case react.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown React unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReactMutation) ResetEdge(name string) error {
	switch name {
	case react.EdgeAccount:
		m.ResetAccount()
		return nil
	case react.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown React edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *xid.ID
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	colour               *string
	permissions          *[]string
	appendpermissions    []string
	sort_key             *float64
	addsort_key          *float64
	clearedFields        map[string]struct{}
	accounts             map[xid.ID]struct{}
	removedaccounts      map[xid.ID]struct{}
	clearedaccounts      bool
	account_roles        map[xid.ID]struct{}
	removedaccount_roles map[xid.ID]struct{}
	clearedaccount_roles bool
	done                 bool
	oldValue             func(context.Context) (*Role, error)
	predicates           []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id xid.ID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetColour sets the "colour" field.
func (m *RoleMutation) SetColour(s string) {
	m.colour = &s
}

// Colour returns the value of the "colour" field in the mutation.
func (m *RoleMutation) Colour() (r string, exists bool) {
	v := m.colour
	if v == nil {
		return
	}
	return *v, true
}

// OldColour returns the old "colour" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldColour(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColour: %w", err)
	}
	return oldValue.Colour, nil
}

// ResetColour resets all changes to the "colour" field.
func (m *RoleMutation) ResetColour() {
	m.colour = nil
}

// SetPermissions sets the "permissions" field.
func (m *RoleMutation) SetPermissions(s []string) {
	m.permissions = &s
	m.appendpermissions = nil
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *RoleMutation) Permissions() (r []string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldPermissions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// AppendPermissions adds s to the "permissions" field.
func (m *RoleMutation) AppendPermissions(s []string) {
	m.appendpermissions = append(m.appendpermissions, s...)
}

// AppendedPermissions returns the list of values that were appended to the "permissions" field in this mutation.
func (m *RoleMutation) AppendedPermissions() ([]string, bool) {
	if len(m.appendpermissions) == 0 {
		return nil, false
	}
	return m.appendpermissions, true
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
}

// SetSortKey sets the "sort_key" field.
func (m *RoleMutation) SetSortKey(f float64) {
	m.sort_key = &f
	m.addsort_key = nil
}

// SortKey returns the value of the "sort_key" field in the mutation.
func (m *RoleMutation) SortKey() (r float64, exists bool) {
	v := m.sort_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSortKey returns the old "sort_key" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldSortKey(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortKey: %w", err)
	}
	return oldValue.SortKey, nil
}

// AddSortKey adds f to the "sort_key" field.
func (m *RoleMutation) AddSortKey(f float64) {
	if m.addsort_key != nil {
		*m.addsort_key += f
	} else {
		m.addsort_key = &f
	}
}

// AddedSortKey returns the value that was added to the "sort_key" field in this mutation.
func (m *RoleMutation) AddedSortKey() (r float64, exists bool) {
	v := m.addsort_key
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortKey resets all changes to the "sort_key" field.
func (m *RoleMutation) ResetSortKey() {
	m.sort_key = nil
	m.addsort_key = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *RoleMutation) AddAccountIDs(ids ...xid.ID) {
	if m.accounts == nil {
		m.accounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *RoleMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *RoleMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *RoleMutation) RemoveAccountIDs(ids ...xid.ID) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *RoleMutation) RemovedAccountsIDs() (ids []xid.ID) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *RoleMutation) AccountsIDs() (ids []xid.ID) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *RoleMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddAccountRoleIDs adds the "account_roles" edge to the AccountRoles entity by ids.
func (m *RoleMutation) AddAccountRoleIDs(ids ...xid.ID) {
	if m.account_roles == nil {
		m.account_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.account_roles[ids[i]] = struct{}{}
	}
}

// ClearAccountRoles clears the "account_roles" edge to the AccountRoles entity.
func (m *RoleMutation) ClearAccountRoles() {
	m.clearedaccount_roles = true
}

// AccountRolesCleared reports if the "account_roles" edge to the AccountRoles entity was cleared.
func (m *RoleMutation) AccountRolesCleared() bool {
	return m.clearedaccount_roles
}

// RemoveAccountRoleIDs removes the "account_roles" edge to the AccountRoles entity by IDs.
func (m *RoleMutation) RemoveAccountRoleIDs(ids ...xid.ID) {
	if m.removedaccount_roles == nil {
		m.removedaccount_roles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.account_roles, ids[i])
		m.removedaccount_roles[ids[i]] = struct{}{}
	}
}

// RemovedAccountRoles returns the removed IDs of the "account_roles" edge to the AccountRoles entity.
func (m *RoleMutation) RemovedAccountRolesIDs() (ids []xid.ID) {
	for id := range m.removedaccount_roles {
		ids = append(ids, id)
	}
	return
}

// AccountRolesIDs returns the "account_roles" edge IDs in the mutation.
func (m *RoleMutation) AccountRolesIDs() (ids []xid.ID) {
	for id := range m.account_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAccountRoles resets all changes to the "account_roles" edge.
func (m *RoleMutation) ResetAccountRoles() {
	m.account_roles = nil
	m.clearedaccount_roles = false
	m.removedaccount_roles = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.colour != nil {
		fields = append(fields, role.FieldColour)
	}
	if m.permissions != nil {
		fields = append(fields, role.FieldPermissions)
	}
	if m.sort_key != nil {
		fields = append(fields, role.FieldSortKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldColour:
		return m.Colour()
	case role.FieldPermissions:
		return m.Permissions()
	case role.FieldSortKey:
		return m.SortKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldColour:
		return m.OldColour(ctx)
	case role.FieldPermissions:
		return m.OldPermissions(ctx)
	case role.FieldSortKey:
		return m.OldSortKey(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldColour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColour(v)
		return nil
	case role.FieldPermissions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case role.FieldSortKey:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortKey(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addsort_key != nil {
		fields = append(fields, role.FieldSortKey)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldSortKey:
		return m.AddedSortKey()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldSortKey:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortKey(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldColour:
		m.ResetColour()
		return nil
	case role.FieldPermissions:
		m.ResetPermissions()
		return nil
	case role.FieldSortKey:
		m.ResetSortKey()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.accounts != nil {
		edges = append(edges, role.EdgeAccounts)
	}
	if m.account_roles != nil {
		edges = append(edges, role.EdgeAccountRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAccountRoles:
		ids := make([]ent.Value, 0, len(m.account_roles))
		for id := range m.account_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaccounts != nil {
		edges = append(edges, role.EdgeAccounts)
	}
	if m.removedaccount_roles != nil {
		edges = append(edges, role.EdgeAccountRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAccountRoles:
		ids := make([]ent.Value, 0, len(m.removedaccount_roles))
		for id := range m.removedaccount_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccounts {
		edges = append(edges, role.EdgeAccounts)
	}
	if m.clearedaccount_roles {
		edges = append(edges, role.EdgeAccountRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeAccounts:
		return m.clearedaccounts
	case role.EdgeAccountRoles:
		return m.clearedaccount_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case role.EdgeAccountRoles:
		m.ResetAccountRoles()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	value         *string
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id string) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldValue:
		return m.Value()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	name             *string
	clearedFields    map[string]struct{}
	posts            map[xid.ID]struct{}
	removedposts     map[xid.ID]struct{}
	clearedposts     bool
	nodes            map[xid.ID]struct{}
	removednodes     map[xid.ID]struct{}
	clearednodes     bool
	accounts         map[xid.ID]struct{}
	removedaccounts  map[xid.ID]struct{}
	clearedaccounts  bool
	post_tags        map[xid.ID]struct{}
	removedpost_tags map[xid.ID]struct{}
	clearedpost_tags bool
	node_tags        map[xid.ID]struct{}
	removednode_tags map[xid.ID]struct{}
	clearednode_tags bool
	done             bool
	oldValue         func(context.Context) (*Tag, error)
	predicates       []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id xid.ID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *TagMutation) AddPostIDs(ids ...xid.ID) {
	if m.posts == nil {
		m.posts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *TagMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *TagMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *TagMutation) RemovePostIDs(ids ...xid.ID) {
	if m.removedposts == nil {
		m.removedposts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *TagMutation) RemovedPostsIDs() (ids []xid.ID) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *TagMutation) PostsIDs() (ids []xid.ID) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *TagMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *TagMutation) AddNodeIDs(ids ...xid.ID) {
	if m.nodes == nil {
		m.nodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *TagMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *TagMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *TagMutation) RemoveNodeIDs(ids ...xid.ID) {
	if m.removednodes == nil {
		m.removednodes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *TagMutation) RemovedNodesIDs() (ids []xid.ID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *TagMutation) NodesIDs() (ids []xid.ID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *TagMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *TagMutation) AddAccountIDs(ids ...xid.ID) {
	if m.accounts == nil {
		m.accounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *TagMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *TagMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *TagMutation) RemoveAccountIDs(ids ...xid.ID) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *TagMutation) RemovedAccountsIDs() (ids []xid.ID) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *TagMutation) AccountsIDs() (ids []xid.ID) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *TagMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddPostTagIDs adds the "post_tags" edge to the TagPost entity by ids.
func (m *TagMutation) AddPostTagIDs(ids ...xid.ID) {
	if m.post_tags == nil {
		m.post_tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.post_tags[ids[i]] = struct{}{}
	}
}

// ClearPostTags clears the "post_tags" edge to the TagPost entity.
func (m *TagMutation) ClearPostTags() {
	m.clearedpost_tags = true
}

// PostTagsCleared reports if the "post_tags" edge to the TagPost entity was cleared.
func (m *TagMutation) PostTagsCleared() bool {
	return m.clearedpost_tags
}

// RemovePostTagIDs removes the "post_tags" edge to the TagPost entity by IDs.
func (m *TagMutation) RemovePostTagIDs(ids ...xid.ID) {
	if m.removedpost_tags == nil {
		m.removedpost_tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.post_tags, ids[i])
		m.removedpost_tags[ids[i]] = struct{}{}
	}
}

// RemovedPostTags returns the removed IDs of the "post_tags" edge to the TagPost entity.
func (m *TagMutation) RemovedPostTagsIDs() (ids []xid.ID) {
	for id := range m.removedpost_tags {
		ids = append(ids, id)
	}
	return
}

// PostTagsIDs returns the "post_tags" edge IDs in the mutation.
func (m *TagMutation) PostTagsIDs() (ids []xid.ID) {
	for id := range m.post_tags {
		ids = append(ids, id)
	}
	return
}

// ResetPostTags resets all changes to the "post_tags" edge.
func (m *TagMutation) ResetPostTags() {
	m.post_tags = nil
	m.clearedpost_tags = false
	m.removedpost_tags = nil
}

// AddNodeTagIDs adds the "node_tags" edge to the TagNode entity by ids.
func (m *TagMutation) AddNodeTagIDs(ids ...xid.ID) {
	if m.node_tags == nil {
		m.node_tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.node_tags[ids[i]] = struct{}{}
	}
}

// ClearNodeTags clears the "node_tags" edge to the TagNode entity.
func (m *TagMutation) ClearNodeTags() {
	m.clearednode_tags = true
}

// NodeTagsCleared reports if the "node_tags" edge to the TagNode entity was cleared.
func (m *TagMutation) NodeTagsCleared() bool {
	return m.clearednode_tags
}

// RemoveNodeTagIDs removes the "node_tags" edge to the TagNode entity by IDs.
func (m *TagMutation) RemoveNodeTagIDs(ids ...xid.ID) {
	if m.removednode_tags == nil {
		m.removednode_tags = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.node_tags, ids[i])
		m.removednode_tags[ids[i]] = struct{}{}
	}
}

// RemovedNodeTags returns the removed IDs of the "node_tags" edge to the TagNode entity.
func (m *TagMutation) RemovedNodeTagsIDs() (ids []xid.ID) {
	for id := range m.removednode_tags {
		ids = append(ids, id)
	}
	return
}

// NodeTagsIDs returns the "node_tags" edge IDs in the mutation.
func (m *TagMutation) NodeTagsIDs() (ids []xid.ID) {
	for id := range m.node_tags {
		ids = append(ids, id)
	}
	return
}

// ResetNodeTags resets all changes to the "node_tags" edge.
func (m *TagMutation) ResetNodeTags() {
	m.node_tags = nil
	m.clearednode_tags = false
	m.removednode_tags = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.posts != nil {
		edges = append(edges, tag.EdgePosts)
	}
	if m.nodes != nil {
		edges = append(edges, tag.EdgeNodes)
	}
	if m.accounts != nil {
		edges = append(edges, tag.EdgeAccounts)
	}
	if m.post_tags != nil {
		edges = append(edges, tag.EdgePostTags)
	}
	if m.node_tags != nil {
		edges = append(edges, tag.EdgeNodeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgePostTags:
		ids := make([]ent.Value, 0, len(m.post_tags))
		for id := range m.post_tags {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeNodeTags:
		ids := make([]ent.Value, 0, len(m.node_tags))
		for id := range m.node_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedposts != nil {
		edges = append(edges, tag.EdgePosts)
	}
	if m.removednodes != nil {
		edges = append(edges, tag.EdgeNodes)
	}
	if m.removedaccounts != nil {
		edges = append(edges, tag.EdgeAccounts)
	}
	if m.removedpost_tags != nil {
		edges = append(edges, tag.EdgePostTags)
	}
	if m.removednode_tags != nil {
		edges = append(edges, tag.EdgeNodeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgePostTags:
		ids := make([]ent.Value, 0, len(m.removedpost_tags))
		for id := range m.removedpost_tags {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeNodeTags:
		ids := make([]ent.Value, 0, len(m.removednode_tags))
		for id := range m.removednode_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedposts {
		edges = append(edges, tag.EdgePosts)
	}
	if m.clearednodes {
		edges = append(edges, tag.EdgeNodes)
	}
	if m.clearedaccounts {
		edges = append(edges, tag.EdgeAccounts)
	}
	if m.clearedpost_tags {
		edges = append(edges, tag.EdgePostTags)
	}
	if m.clearednode_tags {
		edges = append(edges, tag.EdgeNodeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgePosts:
		return m.clearedposts
	case tag.EdgeNodes:
		return m.clearednodes
	case tag.EdgeAccounts:
		return m.clearedaccounts
	case tag.EdgePostTags:
		return m.clearedpost_tags
	case tag.EdgeNodeTags:
		return m.clearednode_tags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgePosts:
		m.ResetPosts()
		return nil
	case tag.EdgeNodes:
		m.ResetNodes()
		return nil
	case tag.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case tag.EdgePostTags:
		m.ResetPostTags()
		return nil
	case tag.EdgeNodeTags:
		m.ResetNodeTags()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TagNodeMutation represents an operation that mutates the TagNode nodes in the graph.
type TagNodeMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	clearedFields map[string]struct{}
	tag           *xid.ID
	clearedtag    bool
	node          *xid.ID
	clearednode   bool
	done          bool
	oldValue      func(context.Context) (*TagNode, error)
	predicates    []predicate.TagNode
}

var _ ent.Mutation = (*TagNodeMutation)(nil)

// tagnodeOption allows management of the mutation configuration using functional options.
type tagnodeOption func(*TagNodeMutation)

// newTagNodeMutation creates new mutation for the TagNode entity.
func newTagNodeMutation(c config, op Op, opts ...tagnodeOption) *TagNodeMutation {
	m := &TagNodeMutation{
		config:        c,
		op:            op,
		typ:           TypeTagNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagNodeID sets the ID field of the mutation.
func withTagNodeID(id xid.ID) tagnodeOption {
	return func(m *TagNodeMutation) {
		var (
			err   error
			once  sync.Once
			value *TagNode
		)
		m.oldValue = func(ctx context.Context) (*TagNode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TagNode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTagNode sets the old TagNode of the mutation.
func withTagNode(node *TagNode) tagnodeOption {
	return func(m *TagNodeMutation) {
		m.oldValue = func(context.Context) (*TagNode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TagNode entities.
func (m *TagNodeMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagNodeMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagNodeMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TagNode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTagID sets the "tag_id" field.
func (m *TagNodeMutation) SetTagID(x xid.ID) {
	m.tag = &x
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *TagNodeMutation) TagID() (r xid.ID, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTagID returns the old "tag_id" field's value of the TagNode entity.
// If the TagNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagNodeMutation) OldTagID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagID: %w", err)
	}
	return oldValue.TagID, nil
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *TagNodeMutation) ResetTagID() {
	m.tag = nil
}

// SetNodeID sets the "node_id" field.
func (m *TagNodeMutation) SetNodeID(x xid.ID) {
	m.node = &x
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *TagNodeMutation) NodeID() (r xid.ID, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the TagNode entity.
// If the TagNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagNodeMutation) OldNodeID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *TagNodeMutation) ResetNodeID() {
	m.node = nil
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *TagNodeMutation) ClearTag() {
	m.clearedtag = true
	m.clearedFields[tagnode.FieldTagID] = struct{}{}
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *TagNodeMutation) TagCleared() bool {
	return m.clearedtag
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *TagNodeMutation) TagIDs() (ids []xid.ID) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *TagNodeMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// ClearNode clears the "node" edge to the Node entity.
func (m *TagNodeMutation) ClearNode() {
	m.clearednode = true
	m.clearedFields[tagnode.FieldNodeID] = struct{}{}
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *TagNodeMutation) NodeCleared() bool {
	return m.clearednode
}

// NodeIDs returns the "node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeID instead. It exists only for internal usage by the builders.
func (m *TagNodeMutation) NodeIDs() (ids []xid.ID) {
	if id := m.node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *TagNodeMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
}

// Where appends a list predicates to the TagNodeMutation builder.
func (m *TagNodeMutation) Where(ps ...predicate.TagNode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagNodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagNodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TagNode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagNodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagNodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TagNode).
func (m *TagNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagNodeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tag != nil {
		fields = append(fields, tagnode.FieldTagID)
	}
	if m.node != nil {
		fields = append(fields, tagnode.FieldNodeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tagnode.FieldTagID:
		return m.TagID()
	case tagnode.FieldNodeID:
		return m.NodeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tagnode.FieldTagID:
		return m.OldTagID(ctx)
	case tagnode.FieldNodeID:
		return m.OldNodeID(ctx)
	}
	return nil, fmt.Errorf("unknown TagNode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tagnode.FieldTagID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	case tagnode.FieldNodeID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	}
	return fmt.Errorf("unknown TagNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagNodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagNodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TagNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagNodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagNodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TagNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagNodeMutation) ResetField(name string) error {
	switch name {
	case tagnode.FieldTagID:
		m.ResetTagID()
		return nil
	case tagnode.FieldNodeID:
		m.ResetNodeID()
		return nil
	}
	return fmt.Errorf("unknown TagNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tag != nil {
		edges = append(edges, tagnode.EdgeTag)
	}
	if m.node != nil {
		edges = append(edges, tagnode.EdgeNode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagNodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tagnode.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	case tagnode.EdgeNode:
		if id := m.node; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagNodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtag {
		edges = append(edges, tagnode.EdgeTag)
	}
	if m.clearednode {
		edges = append(edges, tagnode.EdgeNode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagNodeMutation) EdgeCleared(name string) bool {
	switch name {
	case tagnode.EdgeTag:
		return m.clearedtag
	case tagnode.EdgeNode:
		return m.clearednode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagNodeMutation) ClearEdge(name string) error {
	switch name {
	case tagnode.EdgeTag:
		m.ClearTag()
		return nil
	case tagnode.EdgeNode:
		m.ClearNode()
		return nil
	}
	return fmt.Errorf("unknown TagNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagNodeMutation) ResetEdge(name string) error {
	switch name {
	case tagnode.EdgeTag:
		m.ResetTag()
		return nil
	case tagnode.EdgeNode:
		m.ResetNode()
		return nil
	}
	return fmt.Errorf("unknown TagNode edge %s", name)
}

// TagPostMutation represents an operation that mutates the TagPost nodes in the graph.
type TagPostMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	clearedFields map[string]struct{}
	tag           *xid.ID
	clearedtag    bool
	post          *xid.ID
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*TagPost, error)
	predicates    []predicate.TagPost
}

var _ ent.Mutation = (*TagPostMutation)(nil)

// tagpostOption allows management of the mutation configuration using functional options.
type tagpostOption func(*TagPostMutation)

// newTagPostMutation creates new mutation for the TagPost entity.
func newTagPostMutation(c config, op Op, opts ...tagpostOption) *TagPostMutation {
	m := &TagPostMutation{
		config:        c,
		op:            op,
		typ:           TypeTagPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagPostID sets the ID field of the mutation.
func withTagPostID(id xid.ID) tagpostOption {
	return func(m *TagPostMutation) {
		var (
			err   error
			once  sync.Once
			value *TagPost
		)
		m.oldValue = func(ctx context.Context) (*TagPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TagPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTagPost sets the old TagPost of the mutation.
func withTagPost(node *TagPost) tagpostOption {
	return func(m *TagPostMutation) {
		m.oldValue = func(context.Context) (*TagPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TagPost entities.
func (m *TagPostMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagPostMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagPostMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TagPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTagID sets the "tag_id" field.
func (m *TagPostMutation) SetTagID(x xid.ID) {
	m.tag = &x
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *TagPostMutation) TagID() (r xid.ID, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTagID returns the old "tag_id" field's value of the TagPost entity.
// If the TagPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagPostMutation) OldTagID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagID: %w", err)
	}
	return oldValue.TagID, nil
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *TagPostMutation) ResetTagID() {
	m.tag = nil
}

// SetPostID sets the "post_id" field.
func (m *TagPostMutation) SetPostID(x xid.ID) {
	m.post = &x
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *TagPostMutation) PostID() (r xid.ID, exists bool) {
	v := m.post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the TagPost entity.
// If the TagPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagPostMutation) OldPostID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *TagPostMutation) ResetPostID() {
	m.post = nil
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *TagPostMutation) ClearTag() {
	m.clearedtag = true
	m.clearedFields[tagpost.FieldTagID] = struct{}{}
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *TagPostMutation) TagCleared() bool {
	return m.clearedtag
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *TagPostMutation) TagIDs() (ids []xid.ID) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *TagPostMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// ClearPost clears the "post" edge to the Post entity.
func (m *TagPostMutation) ClearPost() {
	m.clearedpost = true
	m.clearedFields[tagpost.FieldPostID] = struct{}{}
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *TagPostMutation) PostCleared() bool {
	return m.clearedpost
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *TagPostMutation) PostIDs() (ids []xid.ID) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *TagPostMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the TagPostMutation builder.
func (m *TagPostMutation) Where(ps ...predicate.TagPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TagPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TagPost).
func (m *TagPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagPostMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tag != nil {
		fields = append(fields, tagpost.FieldTagID)
	}
	if m.post != nil {
		fields = append(fields, tagpost.FieldPostID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tagpost.FieldTagID:
		return m.TagID()
	case tagpost.FieldPostID:
		return m.PostID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tagpost.FieldTagID:
		return m.OldTagID(ctx)
	case tagpost.FieldPostID:
		return m.OldPostID(ctx)
	}
	return nil, fmt.Errorf("unknown TagPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tagpost.FieldTagID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	case tagpost.FieldPostID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	}
	return fmt.Errorf("unknown TagPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagPostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagPostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TagPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagPostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagPostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TagPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagPostMutation) ResetField(name string) error {
	switch name {
	case tagpost.FieldTagID:
		m.ResetTagID()
		return nil
	case tagpost.FieldPostID:
		m.ResetPostID()
		return nil
	}
	return fmt.Errorf("unknown TagPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tag != nil {
		edges = append(edges, tagpost.EdgeTag)
	}
	if m.post != nil {
		edges = append(edges, tagpost.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tagpost.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	case tagpost.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagPostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtag {
		edges = append(edges, tagpost.EdgeTag)
	}
	if m.clearedpost {
		edges = append(edges, tagpost.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagPostMutation) EdgeCleared(name string) bool {
	switch name {
	case tagpost.EdgeTag:
		return m.clearedtag
	case tagpost.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagPostMutation) ClearEdge(name string) error {
	switch name {
	case tagpost.EdgeTag:
		m.ClearTag()
		return nil
	case tagpost.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown TagPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagPostMutation) ResetEdge(name string) error {
	switch name {
	case tagpost.EdgeTag:
		m.ResetTag()
		return nil
	case tagpost.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown TagPost edge %s", name)
}
