// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/Southclaws/storyden/internal/ent/migrate"
	"github.com/rs/xid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/Southclaws/storyden/internal/ent/account"
	"github.com/Southclaws/storyden/internal/ent/accountfollow"
	"github.com/Southclaws/storyden/internal/ent/accountroles"
	"github.com/Southclaws/storyden/internal/ent/asset"
	"github.com/Southclaws/storyden/internal/ent/auditlog"
	"github.com/Southclaws/storyden/internal/ent/authentication"
	"github.com/Southclaws/storyden/internal/ent/category"
	"github.com/Southclaws/storyden/internal/ent/collection"
	"github.com/Southclaws/storyden/internal/ent/collectionnode"
	"github.com/Southclaws/storyden/internal/ent/collectionpost"
	"github.com/Southclaws/storyden/internal/ent/email"
	"github.com/Southclaws/storyden/internal/ent/event"
	"github.com/Southclaws/storyden/internal/ent/eventparticipant"
	"github.com/Southclaws/storyden/internal/ent/invitation"
	"github.com/Southclaws/storyden/internal/ent/likepost"
	"github.com/Southclaws/storyden/internal/ent/link"
	"github.com/Southclaws/storyden/internal/ent/mentionprofile"
	"github.com/Southclaws/storyden/internal/ent/node"
	"github.com/Southclaws/storyden/internal/ent/notification"
	entplugin "github.com/Southclaws/storyden/internal/ent/plugin"
	"github.com/Southclaws/storyden/internal/ent/post"
	"github.com/Southclaws/storyden/internal/ent/postread"
	"github.com/Southclaws/storyden/internal/ent/property"
	"github.com/Southclaws/storyden/internal/ent/propertyschema"
	"github.com/Southclaws/storyden/internal/ent/propertyschemafield"
	"github.com/Southclaws/storyden/internal/ent/question"
	"github.com/Southclaws/storyden/internal/ent/react"
	"github.com/Southclaws/storyden/internal/ent/report"
	"github.com/Southclaws/storyden/internal/ent/role"
	"github.com/Southclaws/storyden/internal/ent/session"
	"github.com/Southclaws/storyden/internal/ent/setting"
	"github.com/Southclaws/storyden/internal/ent/tag"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Account is the client for interacting with the Account builders.
	Account *AccountClient
	// AccountFollow is the client for interacting with the AccountFollow builders.
	AccountFollow *AccountFollowClient
	// AccountRoles is the client for interacting with the AccountRoles builders.
	AccountRoles *AccountRolesClient
	// Asset is the client for interacting with the Asset builders.
	Asset *AssetClient
	// AuditLog is the client for interacting with the AuditLog builders.
	AuditLog *AuditLogClient
	// Authentication is the client for interacting with the Authentication builders.
	Authentication *AuthenticationClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// Collection is the client for interacting with the Collection builders.
	Collection *CollectionClient
	// CollectionNode is the client for interacting with the CollectionNode builders.
	CollectionNode *CollectionNodeClient
	// CollectionPost is the client for interacting with the CollectionPost builders.
	CollectionPost *CollectionPostClient
	// Email is the client for interacting with the Email builders.
	Email *EmailClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// EventParticipant is the client for interacting with the EventParticipant builders.
	EventParticipant *EventParticipantClient
	// Invitation is the client for interacting with the Invitation builders.
	Invitation *InvitationClient
	// LikePost is the client for interacting with the LikePost builders.
	LikePost *LikePostClient
	// Link is the client for interacting with the Link builders.
	Link *LinkClient
	// MentionProfile is the client for interacting with the MentionProfile builders.
	MentionProfile *MentionProfileClient
	// Node is the client for interacting with the Node builders.
	Node *NodeClient
	// Notification is the client for interacting with the Notification builders.
	Notification *NotificationClient
	// Plugin is the client for interacting with the Plugin builders.
	Plugin *PluginClient
	// Post is the client for interacting with the Post builders.
	Post *PostClient
	// PostRead is the client for interacting with the PostRead builders.
	PostRead *PostReadClient
	// Property is the client for interacting with the Property builders.
	Property *PropertyClient
	// PropertySchema is the client for interacting with the PropertySchema builders.
	PropertySchema *PropertySchemaClient
	// PropertySchemaField is the client for interacting with the PropertySchemaField builders.
	PropertySchemaField *PropertySchemaFieldClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// React is the client for interacting with the React builders.
	React *ReactClient
	// Report is the client for interacting with the Report builders.
	Report *ReportClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// Setting is the client for interacting with the Setting builders.
	Setting *SettingClient
	// Tag is the client for interacting with the Tag builders.
	Tag *TagClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Account = NewAccountClient(c.config)
	c.AccountFollow = NewAccountFollowClient(c.config)
	c.AccountRoles = NewAccountRolesClient(c.config)
	c.Asset = NewAssetClient(c.config)
	c.AuditLog = NewAuditLogClient(c.config)
	c.Authentication = NewAuthenticationClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.Collection = NewCollectionClient(c.config)
	c.CollectionNode = NewCollectionNodeClient(c.config)
	c.CollectionPost = NewCollectionPostClient(c.config)
	c.Email = NewEmailClient(c.config)
	c.Event = NewEventClient(c.config)
	c.EventParticipant = NewEventParticipantClient(c.config)
	c.Invitation = NewInvitationClient(c.config)
	c.LikePost = NewLikePostClient(c.config)
	c.Link = NewLinkClient(c.config)
	c.MentionProfile = NewMentionProfileClient(c.config)
	c.Node = NewNodeClient(c.config)
	c.Notification = NewNotificationClient(c.config)
	c.Plugin = NewPluginClient(c.config)
	c.Post = NewPostClient(c.config)
	c.PostRead = NewPostReadClient(c.config)
	c.Property = NewPropertyClient(c.config)
	c.PropertySchema = NewPropertySchemaClient(c.config)
	c.PropertySchemaField = NewPropertySchemaFieldClient(c.config)
	c.Question = NewQuestionClient(c.config)
	c.React = NewReactClient(c.config)
	c.Report = NewReportClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.Setting = NewSettingClient(c.config)
	c.Tag = NewTagClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		Account:             NewAccountClient(cfg),
		AccountFollow:       NewAccountFollowClient(cfg),
		AccountRoles:        NewAccountRolesClient(cfg),
		Asset:               NewAssetClient(cfg),
		AuditLog:            NewAuditLogClient(cfg),
		Authentication:      NewAuthenticationClient(cfg),
		Category:            NewCategoryClient(cfg),
		Collection:          NewCollectionClient(cfg),
		CollectionNode:      NewCollectionNodeClient(cfg),
		CollectionPost:      NewCollectionPostClient(cfg),
		Email:               NewEmailClient(cfg),
		Event:               NewEventClient(cfg),
		EventParticipant:    NewEventParticipantClient(cfg),
		Invitation:          NewInvitationClient(cfg),
		LikePost:            NewLikePostClient(cfg),
		Link:                NewLinkClient(cfg),
		MentionProfile:      NewMentionProfileClient(cfg),
		Node:                NewNodeClient(cfg),
		Notification:        NewNotificationClient(cfg),
		Plugin:              NewPluginClient(cfg),
		Post:                NewPostClient(cfg),
		PostRead:            NewPostReadClient(cfg),
		Property:            NewPropertyClient(cfg),
		PropertySchema:      NewPropertySchemaClient(cfg),
		PropertySchemaField: NewPropertySchemaFieldClient(cfg),
		Question:            NewQuestionClient(cfg),
		React:               NewReactClient(cfg),
		Report:              NewReportClient(cfg),
		Role:                NewRoleClient(cfg),
		Session:             NewSessionClient(cfg),
		Setting:             NewSettingClient(cfg),
		Tag:                 NewTagClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		Account:             NewAccountClient(cfg),
		AccountFollow:       NewAccountFollowClient(cfg),
		AccountRoles:        NewAccountRolesClient(cfg),
		Asset:               NewAssetClient(cfg),
		AuditLog:            NewAuditLogClient(cfg),
		Authentication:      NewAuthenticationClient(cfg),
		Category:            NewCategoryClient(cfg),
		Collection:          NewCollectionClient(cfg),
		CollectionNode:      NewCollectionNodeClient(cfg),
		CollectionPost:      NewCollectionPostClient(cfg),
		Email:               NewEmailClient(cfg),
		Event:               NewEventClient(cfg),
		EventParticipant:    NewEventParticipantClient(cfg),
		Invitation:          NewInvitationClient(cfg),
		LikePost:            NewLikePostClient(cfg),
		Link:                NewLinkClient(cfg),
		MentionProfile:      NewMentionProfileClient(cfg),
		Node:                NewNodeClient(cfg),
		Notification:        NewNotificationClient(cfg),
		Plugin:              NewPluginClient(cfg),
		Post:                NewPostClient(cfg),
		PostRead:            NewPostReadClient(cfg),
		Property:            NewPropertyClient(cfg),
		PropertySchema:      NewPropertySchemaClient(cfg),
		PropertySchemaField: NewPropertySchemaFieldClient(cfg),
		Question:            NewQuestionClient(cfg),
		React:               NewReactClient(cfg),
		Report:              NewReportClient(cfg),
		Role:                NewRoleClient(cfg),
		Session:             NewSessionClient(cfg),
		Setting:             NewSettingClient(cfg),
		Tag:                 NewTagClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Account.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Account, c.AccountFollow, c.AccountRoles, c.Asset, c.AuditLog,
		c.Authentication, c.Category, c.Collection, c.CollectionNode, c.CollectionPost,
		c.Email, c.Event, c.EventParticipant, c.Invitation, c.LikePost, c.Link,
		c.MentionProfile, c.Node, c.Notification, c.Plugin, c.Post, c.PostRead,
		c.Property, c.PropertySchema, c.PropertySchemaField, c.Question, c.React,
		c.Report, c.Role, c.Session, c.Setting, c.Tag,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Account, c.AccountFollow, c.AccountRoles, c.Asset, c.AuditLog,
		c.Authentication, c.Category, c.Collection, c.CollectionNode, c.CollectionPost,
		c.Email, c.Event, c.EventParticipant, c.Invitation, c.LikePost, c.Link,
		c.MentionProfile, c.Node, c.Notification, c.Plugin, c.Post, c.PostRead,
		c.Property, c.PropertySchema, c.PropertySchemaField, c.Question, c.React,
		c.Report, c.Role, c.Session, c.Setting, c.Tag,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccountMutation:
		return c.Account.mutate(ctx, m)
	case *AccountFollowMutation:
		return c.AccountFollow.mutate(ctx, m)
	case *AccountRolesMutation:
		return c.AccountRoles.mutate(ctx, m)
	case *AssetMutation:
		return c.Asset.mutate(ctx, m)
	case *AuditLogMutation:
		return c.AuditLog.mutate(ctx, m)
	case *AuthenticationMutation:
		return c.Authentication.mutate(ctx, m)
	case *CategoryMutation:
		return c.Category.mutate(ctx, m)
	case *CollectionMutation:
		return c.Collection.mutate(ctx, m)
	case *CollectionNodeMutation:
		return c.CollectionNode.mutate(ctx, m)
	case *CollectionPostMutation:
		return c.CollectionPost.mutate(ctx, m)
	case *EmailMutation:
		return c.Email.mutate(ctx, m)
	case *EventMutation:
		return c.Event.mutate(ctx, m)
	case *EventParticipantMutation:
		return c.EventParticipant.mutate(ctx, m)
	case *InvitationMutation:
		return c.Invitation.mutate(ctx, m)
	case *LikePostMutation:
		return c.LikePost.mutate(ctx, m)
	case *LinkMutation:
		return c.Link.mutate(ctx, m)
	case *MentionProfileMutation:
		return c.MentionProfile.mutate(ctx, m)
	case *NodeMutation:
		return c.Node.mutate(ctx, m)
	case *NotificationMutation:
		return c.Notification.mutate(ctx, m)
	case *PluginMutation:
		return c.Plugin.mutate(ctx, m)
	case *PostMutation:
		return c.Post.mutate(ctx, m)
	case *PostReadMutation:
		return c.PostRead.mutate(ctx, m)
	case *PropertyMutation:
		return c.Property.mutate(ctx, m)
	case *PropertySchemaMutation:
		return c.PropertySchema.mutate(ctx, m)
	case *PropertySchemaFieldMutation:
		return c.PropertySchemaField.mutate(ctx, m)
	case *QuestionMutation:
		return c.Question.mutate(ctx, m)
	case *ReactMutation:
		return c.React.mutate(ctx, m)
	case *ReportMutation:
		return c.Report.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *SettingMutation:
		return c.Setting.mutate(ctx, m)
	case *TagMutation:
		return c.Tag.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AccountClient is a client for the Account schema.
type AccountClient struct {
	config
}

// NewAccountClient returns a client for the Account from the given config.
func NewAccountClient(c config) *AccountClient {
	return &AccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `account.Hooks(f(g(h())))`.
func (c *AccountClient) Use(hooks ...Hook) {
	c.hooks.Account = append(c.hooks.Account, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `account.Intercept(f(g(h())))`.
func (c *AccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.Account = append(c.inters.Account, interceptors...)
}

// Create returns a builder for creating a Account entity.
func (c *AccountClient) Create() *AccountCreate {
	mutation := newAccountMutation(c.config, OpCreate)
	return &AccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Account entities.
func (c *AccountClient) CreateBulk(builders ...*AccountCreate) *AccountCreateBulk {
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountClient) MapCreateBulk(slice any, setFunc func(*AccountCreate, int)) *AccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountCreateBulk{err: fmt.Errorf("calling to AccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Account.
func (c *AccountClient) Update() *AccountUpdate {
	mutation := newAccountMutation(c.config, OpUpdate)
	return &AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountClient) UpdateOne(_m *Account) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccount(_m))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountClient) UpdateOneID(id xid.ID) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccountID(id))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Account.
func (c *AccountClient) Delete() *AccountDelete {
	mutation := newAccountMutation(c.config, OpDelete)
	return &AccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountClient) DeleteOne(_m *Account) *AccountDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountClient) DeleteOneID(id xid.ID) *AccountDeleteOne {
	builder := c.Delete().Where(account.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountDeleteOne{builder}
}

// Query returns a query builder for Account.
func (c *AccountClient) Query() *AccountQuery {
	return &AccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a Account entity by its id.
func (c *AccountClient) Get(ctx context.Context, id xid.ID) (*Account, error) {
	return c.Query().Where(account.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountClient) GetX(ctx context.Context, id xid.ID) *Account {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a Account.
func (c *AccountClient) QuerySessions(_m *Account) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.SessionsTable, account.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlugins queries the plugins edge of a Account.
func (c *AccountClient) QueryPlugins(_m *Account) *PluginQuery {
	query := (&PluginClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(entplugin.Table, entplugin.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.PluginsTable, account.PluginsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmails queries the emails edge of a Account.
func (c *AccountClient) QueryEmails(_m *Account) *EmailQuery {
	query := (&EmailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(email.Table, email.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.EmailsTable, account.EmailsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Account.
func (c *AccountClient) QueryNotifications(_m *Account) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.NotificationsTable, account.NotificationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTriggeredNotifications queries the triggered_notifications edge of a Account.
func (c *AccountClient) QueryTriggeredNotifications(_m *Account) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.TriggeredNotificationsTable, account.TriggeredNotificationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowing queries the following edge of a Account.
func (c *AccountClient) QueryFollowing(_m *Account) *AccountFollowQuery {
	query := (&AccountFollowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(accountfollow.Table, accountfollow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.FollowingTable, account.FollowingColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowedBy queries the followed_by edge of a Account.
func (c *AccountClient) QueryFollowedBy(_m *Account) *AccountFollowQuery {
	query := (&AccountFollowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(accountfollow.Table, accountfollow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.FollowedByTable, account.FollowedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvitations queries the invitations edge of a Account.
func (c *AccountClient) QueryInvitations(_m *Account) *InvitationQuery {
	query := (&InvitationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(invitation.Table, invitation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.InvitationsTable, account.InvitationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvitedBy queries the invited_by edge of a Account.
func (c *AccountClient) QueryInvitedBy(_m *Account) *InvitationQuery {
	query := (&InvitationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(invitation.Table, invitation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, account.InvitedByTable, account.InvitedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPosts queries the posts edge of a Account.
func (c *AccountClient) QueryPosts(_m *Account) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.PostsTable, account.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestions queries the questions edge of a Account.
func (c *AccountClient) QueryQuestions(_m *Account) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.QuestionsTable, account.QuestionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReacts queries the reacts edge of a Account.
func (c *AccountClient) QueryReacts(_m *Account) *ReactQuery {
	query := (&ReactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(react.Table, react.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.ReactsTable, account.ReactsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikes queries the likes edge of a Account.
func (c *AccountClient) QueryLikes(_m *Account) *LikePostQuery {
	query := (&LikePostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(likepost.Table, likepost.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.LikesTable, account.LikesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMentions queries the mentions edge of a Account.
func (c *AccountClient) QueryMentions(_m *Account) *MentionProfileQuery {
	query := (&MentionProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(mentionprofile.Table, mentionprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.MentionsTable, account.MentionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoles queries the roles edge of a Account.
func (c *AccountClient) QueryRoles(_m *Account) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, account.RolesTable, account.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthentication queries the authentication edge of a Account.
func (c *AccountClient) QueryAuthentication(_m *Account) *AuthenticationQuery {
	query := (&AuthenticationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(authentication.Table, authentication.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.AuthenticationTable, account.AuthenticationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a Account.
func (c *AccountClient) QueryTags(_m *Account) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, account.TagsTable, account.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollections queries the collections edge of a Account.
func (c *AccountClient) QueryCollections(_m *Account) *CollectionQuery {
	query := (&CollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(collection.Table, collection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.CollectionsTable, account.CollectionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a Account.
func (c *AccountClient) QueryNodes(_m *Account) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.NodesTable, account.NodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Account.
func (c *AccountClient) QueryAssets(_m *Account) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.AssetsTable, account.AssetsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Account.
func (c *AccountClient) QueryEvents(_m *Account) *EventParticipantQuery {
	query := (&EventParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(eventparticipant.Table, eventparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.EventsTable, account.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPostReads queries the post_reads edge of a Account.
func (c *AccountClient) QueryPostReads(_m *Account) *PostReadQuery {
	query := (&PostReadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(postread.Table, postread.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.PostReadsTable, account.PostReadsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReports queries the reports edge of a Account.
func (c *AccountClient) QueryReports(_m *Account) *ReportQuery {
	query := (&ReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(report.Table, report.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.ReportsTable, account.ReportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHandledReports queries the handled_reports edge of a Account.
func (c *AccountClient) QueryHandledReports(_m *Account) *ReportQuery {
	query := (&ReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(report.Table, report.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.HandledReportsTable, account.HandledReportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuditLogs queries the audit_logs edge of a Account.
func (c *AccountClient) QueryAuditLogs(_m *Account) *AuditLogQuery {
	query := (&AuditLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(auditlog.Table, auditlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.AuditLogsTable, account.AuditLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccountRoles queries the account_roles edge of a Account.
func (c *AccountClient) QueryAccountRoles(_m *Account) *AccountRolesQuery {
	query := (&AccountRolesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(accountroles.Table, accountroles.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, account.AccountRolesTable, account.AccountRolesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountClient) Hooks() []Hook {
	return c.hooks.Account
}

// Interceptors returns the client interceptors.
func (c *AccountClient) Interceptors() []Interceptor {
	return c.inters.Account
}

func (c *AccountClient) mutate(ctx context.Context, m *AccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Account mutation op: %q", m.Op())
	}
}

// AccountFollowClient is a client for the AccountFollow schema.
type AccountFollowClient struct {
	config
}

// NewAccountFollowClient returns a client for the AccountFollow from the given config.
func NewAccountFollowClient(c config) *AccountFollowClient {
	return &AccountFollowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accountfollow.Hooks(f(g(h())))`.
func (c *AccountFollowClient) Use(hooks ...Hook) {
	c.hooks.AccountFollow = append(c.hooks.AccountFollow, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accountfollow.Intercept(f(g(h())))`.
func (c *AccountFollowClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccountFollow = append(c.inters.AccountFollow, interceptors...)
}

// Create returns a builder for creating a AccountFollow entity.
func (c *AccountFollowClient) Create() *AccountFollowCreate {
	mutation := newAccountFollowMutation(c.config, OpCreate)
	return &AccountFollowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccountFollow entities.
func (c *AccountFollowClient) CreateBulk(builders ...*AccountFollowCreate) *AccountFollowCreateBulk {
	return &AccountFollowCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountFollowClient) MapCreateBulk(slice any, setFunc func(*AccountFollowCreate, int)) *AccountFollowCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountFollowCreateBulk{err: fmt.Errorf("calling to AccountFollowClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountFollowCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountFollowCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccountFollow.
func (c *AccountFollowClient) Update() *AccountFollowUpdate {
	mutation := newAccountFollowMutation(c.config, OpUpdate)
	return &AccountFollowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountFollowClient) UpdateOne(_m *AccountFollow) *AccountFollowUpdateOne {
	mutation := newAccountFollowMutation(c.config, OpUpdateOne, withAccountFollow(_m))
	return &AccountFollowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountFollowClient) UpdateOneID(id xid.ID) *AccountFollowUpdateOne {
	mutation := newAccountFollowMutation(c.config, OpUpdateOne, withAccountFollowID(id))
	return &AccountFollowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccountFollow.
func (c *AccountFollowClient) Delete() *AccountFollowDelete {
	mutation := newAccountFollowMutation(c.config, OpDelete)
	return &AccountFollowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountFollowClient) DeleteOne(_m *AccountFollow) *AccountFollowDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountFollowClient) DeleteOneID(id xid.ID) *AccountFollowDeleteOne {
	builder := c.Delete().Where(accountfollow.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountFollowDeleteOne{builder}
}

// Query returns a query builder for AccountFollow.
func (c *AccountFollowClient) Query() *AccountFollowQuery {
	return &AccountFollowQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccountFollow},
		inters: c.Interceptors(),
	}
}

// Get returns a AccountFollow entity by its id.
func (c *AccountFollowClient) Get(ctx context.Context, id xid.ID) (*AccountFollow, error) {
	return c.Query().Where(accountfollow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountFollowClient) GetX(ctx context.Context, id xid.ID) *AccountFollow {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFollower queries the follower edge of a AccountFollow.
func (c *AccountFollowClient) QueryFollower(_m *AccountFollow) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountfollow.Table, accountfollow.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accountfollow.FollowerTable, accountfollow.FollowerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowing queries the following edge of a AccountFollow.
func (c *AccountFollowClient) QueryFollowing(_m *AccountFollow) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountfollow.Table, accountfollow.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accountfollow.FollowingTable, accountfollow.FollowingColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountFollowClient) Hooks() []Hook {
	return c.hooks.AccountFollow
}

// Interceptors returns the client interceptors.
func (c *AccountFollowClient) Interceptors() []Interceptor {
	return c.inters.AccountFollow
}

func (c *AccountFollowClient) mutate(ctx context.Context, m *AccountFollowMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountFollowCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountFollowUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountFollowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountFollowDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AccountFollow mutation op: %q", m.Op())
	}
}

// AccountRolesClient is a client for the AccountRoles schema.
type AccountRolesClient struct {
	config
}

// NewAccountRolesClient returns a client for the AccountRoles from the given config.
func NewAccountRolesClient(c config) *AccountRolesClient {
	return &AccountRolesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accountroles.Hooks(f(g(h())))`.
func (c *AccountRolesClient) Use(hooks ...Hook) {
	c.hooks.AccountRoles = append(c.hooks.AccountRoles, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accountroles.Intercept(f(g(h())))`.
func (c *AccountRolesClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccountRoles = append(c.inters.AccountRoles, interceptors...)
}

// Create returns a builder for creating a AccountRoles entity.
func (c *AccountRolesClient) Create() *AccountRolesCreate {
	mutation := newAccountRolesMutation(c.config, OpCreate)
	return &AccountRolesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccountRoles entities.
func (c *AccountRolesClient) CreateBulk(builders ...*AccountRolesCreate) *AccountRolesCreateBulk {
	return &AccountRolesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountRolesClient) MapCreateBulk(slice any, setFunc func(*AccountRolesCreate, int)) *AccountRolesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountRolesCreateBulk{err: fmt.Errorf("calling to AccountRolesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountRolesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountRolesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccountRoles.
func (c *AccountRolesClient) Update() *AccountRolesUpdate {
	mutation := newAccountRolesMutation(c.config, OpUpdate)
	return &AccountRolesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountRolesClient) UpdateOne(_m *AccountRoles) *AccountRolesUpdateOne {
	mutation := newAccountRolesMutation(c.config, OpUpdateOne, withAccountRoles(_m))
	return &AccountRolesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountRolesClient) UpdateOneID(id xid.ID) *AccountRolesUpdateOne {
	mutation := newAccountRolesMutation(c.config, OpUpdateOne, withAccountRolesID(id))
	return &AccountRolesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccountRoles.
func (c *AccountRolesClient) Delete() *AccountRolesDelete {
	mutation := newAccountRolesMutation(c.config, OpDelete)
	return &AccountRolesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountRolesClient) DeleteOne(_m *AccountRoles) *AccountRolesDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountRolesClient) DeleteOneID(id xid.ID) *AccountRolesDeleteOne {
	builder := c.Delete().Where(accountroles.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountRolesDeleteOne{builder}
}

// Query returns a query builder for AccountRoles.
func (c *AccountRolesClient) Query() *AccountRolesQuery {
	return &AccountRolesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccountRoles},
		inters: c.Interceptors(),
	}
}

// Get returns a AccountRoles entity by its id.
func (c *AccountRolesClient) Get(ctx context.Context, id xid.ID) (*AccountRoles, error) {
	return c.Query().Where(accountroles.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountRolesClient) GetX(ctx context.Context, id xid.ID) *AccountRoles {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a AccountRoles.
func (c *AccountRolesClient) QueryAccount(_m *AccountRoles) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountroles.Table, accountroles.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, accountroles.AccountTable, accountroles.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRole queries the role edge of a AccountRoles.
func (c *AccountRolesClient) QueryRole(_m *AccountRoles) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountroles.Table, accountroles.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, accountroles.RoleTable, accountroles.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountRolesClient) Hooks() []Hook {
	return c.hooks.AccountRoles
}

// Interceptors returns the client interceptors.
func (c *AccountRolesClient) Interceptors() []Interceptor {
	return c.inters.AccountRoles
}

func (c *AccountRolesClient) mutate(ctx context.Context, m *AccountRolesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountRolesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountRolesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountRolesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountRolesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AccountRoles mutation op: %q", m.Op())
	}
}

// AssetClient is a client for the Asset schema.
type AssetClient struct {
	config
}

// NewAssetClient returns a client for the Asset from the given config.
func NewAssetClient(c config) *AssetClient {
	return &AssetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `asset.Hooks(f(g(h())))`.
func (c *AssetClient) Use(hooks ...Hook) {
	c.hooks.Asset = append(c.hooks.Asset, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `asset.Intercept(f(g(h())))`.
func (c *AssetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Asset = append(c.inters.Asset, interceptors...)
}

// Create returns a builder for creating a Asset entity.
func (c *AssetClient) Create() *AssetCreate {
	mutation := newAssetMutation(c.config, OpCreate)
	return &AssetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Asset entities.
func (c *AssetClient) CreateBulk(builders ...*AssetCreate) *AssetCreateBulk {
	return &AssetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssetClient) MapCreateBulk(slice any, setFunc func(*AssetCreate, int)) *AssetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssetCreateBulk{err: fmt.Errorf("calling to AssetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Asset.
func (c *AssetClient) Update() *AssetUpdate {
	mutation := newAssetMutation(c.config, OpUpdate)
	return &AssetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssetClient) UpdateOne(_m *Asset) *AssetUpdateOne {
	mutation := newAssetMutation(c.config, OpUpdateOne, withAsset(_m))
	return &AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssetClient) UpdateOneID(id xid.ID) *AssetUpdateOne {
	mutation := newAssetMutation(c.config, OpUpdateOne, withAssetID(id))
	return &AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Asset.
func (c *AssetClient) Delete() *AssetDelete {
	mutation := newAssetMutation(c.config, OpDelete)
	return &AssetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssetClient) DeleteOne(_m *Asset) *AssetDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssetClient) DeleteOneID(id xid.ID) *AssetDeleteOne {
	builder := c.Delete().Where(asset.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssetDeleteOne{builder}
}

// Query returns a query builder for Asset.
func (c *AssetClient) Query() *AssetQuery {
	return &AssetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAsset},
		inters: c.Interceptors(),
	}
}

// Get returns a Asset entity by its id.
func (c *AssetClient) Get(ctx context.Context, id xid.ID) (*Asset, error) {
	return c.Query().Where(asset.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssetClient) GetX(ctx context.Context, id xid.ID) *Asset {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPosts queries the posts edge of a Asset.
func (c *AssetClient) QueryPosts(_m *Asset) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, asset.PostsTable, asset.PostsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a Asset.
func (c *AssetClient) QueryNodes(_m *Asset) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, asset.NodesTable, asset.NodesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLinks queries the links edge of a Asset.
func (c *AssetClient) QueryLinks(_m *Asset) *LinkQuery {
	query := (&LinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(link.Table, link.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, asset.LinksTable, asset.LinksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a Asset.
func (c *AssetClient) QueryOwner(_m *Asset) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, asset.OwnerTable, asset.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Asset.
func (c *AssetClient) QueryParent(_m *Asset) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, asset.ParentTable, asset.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Asset.
func (c *AssetClient) QueryAssets(_m *Asset) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.AssetsTable, asset.AssetsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Asset.
func (c *AssetClient) QueryEvent(_m *Asset) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.EventTable, asset.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssetClient) Hooks() []Hook {
	return c.hooks.Asset
}

// Interceptors returns the client interceptors.
func (c *AssetClient) Interceptors() []Interceptor {
	return c.inters.Asset
}

func (c *AssetClient) mutate(ctx context.Context, m *AssetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Asset mutation op: %q", m.Op())
	}
}

// AuditLogClient is a client for the AuditLog schema.
type AuditLogClient struct {
	config
}

// NewAuditLogClient returns a client for the AuditLog from the given config.
func NewAuditLogClient(c config) *AuditLogClient {
	return &AuditLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auditlog.Hooks(f(g(h())))`.
func (c *AuditLogClient) Use(hooks ...Hook) {
	c.hooks.AuditLog = append(c.hooks.AuditLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auditlog.Intercept(f(g(h())))`.
func (c *AuditLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuditLog = append(c.inters.AuditLog, interceptors...)
}

// Create returns a builder for creating a AuditLog entity.
func (c *AuditLogClient) Create() *AuditLogCreate {
	mutation := newAuditLogMutation(c.config, OpCreate)
	return &AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuditLog entities.
func (c *AuditLogClient) CreateBulk(builders ...*AuditLogCreate) *AuditLogCreateBulk {
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuditLogClient) MapCreateBulk(slice any, setFunc func(*AuditLogCreate, int)) *AuditLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuditLogCreateBulk{err: fmt.Errorf("calling to AuditLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuditLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuditLog.
func (c *AuditLogClient) Update() *AuditLogUpdate {
	mutation := newAuditLogMutation(c.config, OpUpdate)
	return &AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuditLogClient) UpdateOne(_m *AuditLog) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLog(_m))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuditLogClient) UpdateOneID(id xid.ID) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLogID(id))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuditLog.
func (c *AuditLogClient) Delete() *AuditLogDelete {
	mutation := newAuditLogMutation(c.config, OpDelete)
	return &AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuditLogClient) DeleteOne(_m *AuditLog) *AuditLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuditLogClient) DeleteOneID(id xid.ID) *AuditLogDeleteOne {
	builder := c.Delete().Where(auditlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuditLogDeleteOne{builder}
}

// Query returns a query builder for AuditLog.
func (c *AuditLogClient) Query() *AuditLogQuery {
	return &AuditLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuditLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AuditLog entity by its id.
func (c *AuditLogClient) Get(ctx context.Context, id xid.ID) (*AuditLog, error) {
	return c.Query().Where(auditlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuditLogClient) GetX(ctx context.Context, id xid.ID) *AuditLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnactedBy queries the enacted_by edge of a AuditLog.
func (c *AuditLogClient) QueryEnactedBy(_m *AuditLog) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(auditlog.Table, auditlog.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, auditlog.EnactedByTable, auditlog.EnactedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuditLogClient) Hooks() []Hook {
	return c.hooks.AuditLog
}

// Interceptors returns the client interceptors.
func (c *AuditLogClient) Interceptors() []Interceptor {
	return c.inters.AuditLog
}

func (c *AuditLogClient) mutate(ctx context.Context, m *AuditLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuditLog mutation op: %q", m.Op())
	}
}

// AuthenticationClient is a client for the Authentication schema.
type AuthenticationClient struct {
	config
}

// NewAuthenticationClient returns a client for the Authentication from the given config.
func NewAuthenticationClient(c config) *AuthenticationClient {
	return &AuthenticationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authentication.Hooks(f(g(h())))`.
func (c *AuthenticationClient) Use(hooks ...Hook) {
	c.hooks.Authentication = append(c.hooks.Authentication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authentication.Intercept(f(g(h())))`.
func (c *AuthenticationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Authentication = append(c.inters.Authentication, interceptors...)
}

// Create returns a builder for creating a Authentication entity.
func (c *AuthenticationClient) Create() *AuthenticationCreate {
	mutation := newAuthenticationMutation(c.config, OpCreate)
	return &AuthenticationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Authentication entities.
func (c *AuthenticationClient) CreateBulk(builders ...*AuthenticationCreate) *AuthenticationCreateBulk {
	return &AuthenticationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthenticationClient) MapCreateBulk(slice any, setFunc func(*AuthenticationCreate, int)) *AuthenticationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthenticationCreateBulk{err: fmt.Errorf("calling to AuthenticationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthenticationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthenticationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Authentication.
func (c *AuthenticationClient) Update() *AuthenticationUpdate {
	mutation := newAuthenticationMutation(c.config, OpUpdate)
	return &AuthenticationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthenticationClient) UpdateOne(_m *Authentication) *AuthenticationUpdateOne {
	mutation := newAuthenticationMutation(c.config, OpUpdateOne, withAuthentication(_m))
	return &AuthenticationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthenticationClient) UpdateOneID(id xid.ID) *AuthenticationUpdateOne {
	mutation := newAuthenticationMutation(c.config, OpUpdateOne, withAuthenticationID(id))
	return &AuthenticationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Authentication.
func (c *AuthenticationClient) Delete() *AuthenticationDelete {
	mutation := newAuthenticationMutation(c.config, OpDelete)
	return &AuthenticationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthenticationClient) DeleteOne(_m *Authentication) *AuthenticationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthenticationClient) DeleteOneID(id xid.ID) *AuthenticationDeleteOne {
	builder := c.Delete().Where(authentication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthenticationDeleteOne{builder}
}

// Query returns a query builder for Authentication.
func (c *AuthenticationClient) Query() *AuthenticationQuery {
	return &AuthenticationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthentication},
		inters: c.Interceptors(),
	}
}

// Get returns a Authentication entity by its id.
func (c *AuthenticationClient) Get(ctx context.Context, id xid.ID) (*Authentication, error) {
	return c.Query().Where(authentication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthenticationClient) GetX(ctx context.Context, id xid.ID) *Authentication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a Authentication.
func (c *AuthenticationClient) QueryAccount(_m *Authentication) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authentication.Table, authentication.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, authentication.AccountTable, authentication.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthenticationClient) Hooks() []Hook {
	return c.hooks.Authentication
}

// Interceptors returns the client interceptors.
func (c *AuthenticationClient) Interceptors() []Interceptor {
	return c.inters.Authentication
}

func (c *AuthenticationClient) mutate(ctx context.Context, m *AuthenticationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthenticationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthenticationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthenticationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthenticationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Authentication mutation op: %q", m.Op())
	}
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `category.Intercept(f(g(h())))`.
func (c *CategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Category = append(c.inters.Category, interceptors...)
}

// Create returns a builder for creating a Category entity.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Category entities.
func (c *CategoryClient) CreateBulk(builders ...*CategoryCreate) *CategoryCreateBulk {
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CategoryClient) MapCreateBulk(slice any, setFunc func(*CategoryCreate, int)) *CategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CategoryCreateBulk{err: fmt.Errorf("calling to CategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(_m *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(_m))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id xid.ID) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategoryClient) DeleteOne(_m *Category) *CategoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategoryClient) DeleteOneID(id xid.ID) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Query returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id xid.ID) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id xid.ID) *Category {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPosts queries the posts edge of a Category.
func (c *CategoryClient) QueryPosts(_m *Category) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.PostsTable, category.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Category.
func (c *CategoryClient) QueryParent(_m *Category) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, category.ParentTable, category.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Category.
func (c *CategoryClient) QueryChildren(_m *Category) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.ChildrenTable, category.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCoverImage queries the cover_image edge of a Category.
func (c *CategoryClient) QueryCoverImage(_m *Category) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, category.CoverImageTable, category.CoverImageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	return c.hooks.Category
}

// Interceptors returns the client interceptors.
func (c *CategoryClient) Interceptors() []Interceptor {
	return c.inters.Category
}

func (c *CategoryClient) mutate(ctx context.Context, m *CategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Category mutation op: %q", m.Op())
	}
}

// CollectionClient is a client for the Collection schema.
type CollectionClient struct {
	config
}

// NewCollectionClient returns a client for the Collection from the given config.
func NewCollectionClient(c config) *CollectionClient {
	return &CollectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `collection.Hooks(f(g(h())))`.
func (c *CollectionClient) Use(hooks ...Hook) {
	c.hooks.Collection = append(c.hooks.Collection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `collection.Intercept(f(g(h())))`.
func (c *CollectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Collection = append(c.inters.Collection, interceptors...)
}

// Create returns a builder for creating a Collection entity.
func (c *CollectionClient) Create() *CollectionCreate {
	mutation := newCollectionMutation(c.config, OpCreate)
	return &CollectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Collection entities.
func (c *CollectionClient) CreateBulk(builders ...*CollectionCreate) *CollectionCreateBulk {
	return &CollectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CollectionClient) MapCreateBulk(slice any, setFunc func(*CollectionCreate, int)) *CollectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CollectionCreateBulk{err: fmt.Errorf("calling to CollectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CollectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CollectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Collection.
func (c *CollectionClient) Update() *CollectionUpdate {
	mutation := newCollectionMutation(c.config, OpUpdate)
	return &CollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CollectionClient) UpdateOne(_m *Collection) *CollectionUpdateOne {
	mutation := newCollectionMutation(c.config, OpUpdateOne, withCollection(_m))
	return &CollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CollectionClient) UpdateOneID(id xid.ID) *CollectionUpdateOne {
	mutation := newCollectionMutation(c.config, OpUpdateOne, withCollectionID(id))
	return &CollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Collection.
func (c *CollectionClient) Delete() *CollectionDelete {
	mutation := newCollectionMutation(c.config, OpDelete)
	return &CollectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CollectionClient) DeleteOne(_m *Collection) *CollectionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CollectionClient) DeleteOneID(id xid.ID) *CollectionDeleteOne {
	builder := c.Delete().Where(collection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CollectionDeleteOne{builder}
}

// Query returns a query builder for Collection.
func (c *CollectionClient) Query() *CollectionQuery {
	return &CollectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCollection},
		inters: c.Interceptors(),
	}
}

// Get returns a Collection entity by its id.
func (c *CollectionClient) Get(ctx context.Context, id xid.ID) (*Collection, error) {
	return c.Query().Where(collection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CollectionClient) GetX(ctx context.Context, id xid.ID) *Collection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Collection.
func (c *CollectionClient) QueryOwner(_m *Collection) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, collection.OwnerTable, collection.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCoverImage queries the cover_image edge of a Collection.
func (c *CollectionClient) QueryCoverImage(_m *Collection) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, collection.CoverImageTable, collection.CoverImageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPosts queries the posts edge of a Collection.
func (c *CollectionClient) QueryPosts(_m *Collection) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, collection.PostsTable, collection.PostsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a Collection.
func (c *CollectionClient) QueryNodes(_m *Collection) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, collection.NodesTable, collection.NodesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollectionPosts queries the collection_posts edge of a Collection.
func (c *CollectionClient) QueryCollectionPosts(_m *Collection) *CollectionPostQuery {
	query := (&CollectionPostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(collectionpost.Table, collectionpost.CollectionColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, collection.CollectionPostsTable, collection.CollectionPostsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollectionNodes queries the collection_nodes edge of a Collection.
func (c *CollectionClient) QueryCollectionNodes(_m *Collection) *CollectionNodeQuery {
	query := (&CollectionNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(collectionnode.Table, collectionnode.CollectionColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, collection.CollectionNodesTable, collection.CollectionNodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CollectionClient) Hooks() []Hook {
	return c.hooks.Collection
}

// Interceptors returns the client interceptors.
func (c *CollectionClient) Interceptors() []Interceptor {
	return c.inters.Collection
}

func (c *CollectionClient) mutate(ctx context.Context, m *CollectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CollectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CollectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Collection mutation op: %q", m.Op())
	}
}

// CollectionNodeClient is a client for the CollectionNode schema.
type CollectionNodeClient struct {
	config
}

// NewCollectionNodeClient returns a client for the CollectionNode from the given config.
func NewCollectionNodeClient(c config) *CollectionNodeClient {
	return &CollectionNodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `collectionnode.Hooks(f(g(h())))`.
func (c *CollectionNodeClient) Use(hooks ...Hook) {
	c.hooks.CollectionNode = append(c.hooks.CollectionNode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `collectionnode.Intercept(f(g(h())))`.
func (c *CollectionNodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.CollectionNode = append(c.inters.CollectionNode, interceptors...)
}

// Create returns a builder for creating a CollectionNode entity.
func (c *CollectionNodeClient) Create() *CollectionNodeCreate {
	mutation := newCollectionNodeMutation(c.config, OpCreate)
	return &CollectionNodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CollectionNode entities.
func (c *CollectionNodeClient) CreateBulk(builders ...*CollectionNodeCreate) *CollectionNodeCreateBulk {
	return &CollectionNodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CollectionNodeClient) MapCreateBulk(slice any, setFunc func(*CollectionNodeCreate, int)) *CollectionNodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CollectionNodeCreateBulk{err: fmt.Errorf("calling to CollectionNodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CollectionNodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CollectionNodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CollectionNode.
func (c *CollectionNodeClient) Update() *CollectionNodeUpdate {
	mutation := newCollectionNodeMutation(c.config, OpUpdate)
	return &CollectionNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CollectionNodeClient) UpdateOne(_m *CollectionNode) *CollectionNodeUpdateOne {
	mutation := newCollectionNodeMutation(c.config, OpUpdateOne)
	mutation.collection = &_m.CollectionID
	mutation.node = &_m.NodeID
	return &CollectionNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CollectionNode.
func (c *CollectionNodeClient) Delete() *CollectionNodeDelete {
	mutation := newCollectionNodeMutation(c.config, OpDelete)
	return &CollectionNodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for CollectionNode.
func (c *CollectionNodeClient) Query() *CollectionNodeQuery {
	return &CollectionNodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCollectionNode},
		inters: c.Interceptors(),
	}
}

// QueryCollection queries the collection edge of a CollectionNode.
func (c *CollectionNodeClient) QueryCollection(_m *CollectionNode) *CollectionQuery {
	return c.Query().
		Where(collectionnode.CollectionID(_m.CollectionID), collectionnode.NodeID(_m.NodeID)).
		QueryCollection()
}

// QueryNode queries the node edge of a CollectionNode.
func (c *CollectionNodeClient) QueryNode(_m *CollectionNode) *NodeQuery {
	return c.Query().
		Where(collectionnode.CollectionID(_m.CollectionID), collectionnode.NodeID(_m.NodeID)).
		QueryNode()
}

// Hooks returns the client hooks.
func (c *CollectionNodeClient) Hooks() []Hook {
	return c.hooks.CollectionNode
}

// Interceptors returns the client interceptors.
func (c *CollectionNodeClient) Interceptors() []Interceptor {
	return c.inters.CollectionNode
}

func (c *CollectionNodeClient) mutate(ctx context.Context, m *CollectionNodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CollectionNodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CollectionNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CollectionNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CollectionNodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CollectionNode mutation op: %q", m.Op())
	}
}

// CollectionPostClient is a client for the CollectionPost schema.
type CollectionPostClient struct {
	config
}

// NewCollectionPostClient returns a client for the CollectionPost from the given config.
func NewCollectionPostClient(c config) *CollectionPostClient {
	return &CollectionPostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `collectionpost.Hooks(f(g(h())))`.
func (c *CollectionPostClient) Use(hooks ...Hook) {
	c.hooks.CollectionPost = append(c.hooks.CollectionPost, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `collectionpost.Intercept(f(g(h())))`.
func (c *CollectionPostClient) Intercept(interceptors ...Interceptor) {
	c.inters.CollectionPost = append(c.inters.CollectionPost, interceptors...)
}

// Create returns a builder for creating a CollectionPost entity.
func (c *CollectionPostClient) Create() *CollectionPostCreate {
	mutation := newCollectionPostMutation(c.config, OpCreate)
	return &CollectionPostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CollectionPost entities.
func (c *CollectionPostClient) CreateBulk(builders ...*CollectionPostCreate) *CollectionPostCreateBulk {
	return &CollectionPostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CollectionPostClient) MapCreateBulk(slice any, setFunc func(*CollectionPostCreate, int)) *CollectionPostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CollectionPostCreateBulk{err: fmt.Errorf("calling to CollectionPostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CollectionPostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CollectionPostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CollectionPost.
func (c *CollectionPostClient) Update() *CollectionPostUpdate {
	mutation := newCollectionPostMutation(c.config, OpUpdate)
	return &CollectionPostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CollectionPostClient) UpdateOne(_m *CollectionPost) *CollectionPostUpdateOne {
	mutation := newCollectionPostMutation(c.config, OpUpdateOne)
	mutation.collection = &_m.CollectionID
	mutation.post = &_m.PostID
	return &CollectionPostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CollectionPost.
func (c *CollectionPostClient) Delete() *CollectionPostDelete {
	mutation := newCollectionPostMutation(c.config, OpDelete)
	return &CollectionPostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for CollectionPost.
func (c *CollectionPostClient) Query() *CollectionPostQuery {
	return &CollectionPostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCollectionPost},
		inters: c.Interceptors(),
	}
}

// QueryCollection queries the collection edge of a CollectionPost.
func (c *CollectionPostClient) QueryCollection(_m *CollectionPost) *CollectionQuery {
	return c.Query().
		Where(collectionpost.CollectionID(_m.CollectionID), collectionpost.PostID(_m.PostID)).
		QueryCollection()
}

// QueryPost queries the post edge of a CollectionPost.
func (c *CollectionPostClient) QueryPost(_m *CollectionPost) *PostQuery {
	return c.Query().
		Where(collectionpost.CollectionID(_m.CollectionID), collectionpost.PostID(_m.PostID)).
		QueryPost()
}

// Hooks returns the client hooks.
func (c *CollectionPostClient) Hooks() []Hook {
	return c.hooks.CollectionPost
}

// Interceptors returns the client interceptors.
func (c *CollectionPostClient) Interceptors() []Interceptor {
	return c.inters.CollectionPost
}

func (c *CollectionPostClient) mutate(ctx context.Context, m *CollectionPostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CollectionPostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CollectionPostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CollectionPostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CollectionPostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CollectionPost mutation op: %q", m.Op())
	}
}

// EmailClient is a client for the Email schema.
type EmailClient struct {
	config
}

// NewEmailClient returns a client for the Email from the given config.
func NewEmailClient(c config) *EmailClient {
	return &EmailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `email.Hooks(f(g(h())))`.
func (c *EmailClient) Use(hooks ...Hook) {
	c.hooks.Email = append(c.hooks.Email, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `email.Intercept(f(g(h())))`.
func (c *EmailClient) Intercept(interceptors ...Interceptor) {
	c.inters.Email = append(c.inters.Email, interceptors...)
}

// Create returns a builder for creating a Email entity.
func (c *EmailClient) Create() *EmailCreate {
	mutation := newEmailMutation(c.config, OpCreate)
	return &EmailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Email entities.
func (c *EmailClient) CreateBulk(builders ...*EmailCreate) *EmailCreateBulk {
	return &EmailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailClient) MapCreateBulk(slice any, setFunc func(*EmailCreate, int)) *EmailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailCreateBulk{err: fmt.Errorf("calling to EmailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Email.
func (c *EmailClient) Update() *EmailUpdate {
	mutation := newEmailMutation(c.config, OpUpdate)
	return &EmailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailClient) UpdateOne(_m *Email) *EmailUpdateOne {
	mutation := newEmailMutation(c.config, OpUpdateOne, withEmail(_m))
	return &EmailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailClient) UpdateOneID(id xid.ID) *EmailUpdateOne {
	mutation := newEmailMutation(c.config, OpUpdateOne, withEmailID(id))
	return &EmailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Email.
func (c *EmailClient) Delete() *EmailDelete {
	mutation := newEmailMutation(c.config, OpDelete)
	return &EmailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailClient) DeleteOne(_m *Email) *EmailDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailClient) DeleteOneID(id xid.ID) *EmailDeleteOne {
	builder := c.Delete().Where(email.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailDeleteOne{builder}
}

// Query returns a query builder for Email.
func (c *EmailClient) Query() *EmailQuery {
	return &EmailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmail},
		inters: c.Interceptors(),
	}
}

// Get returns a Email entity by its id.
func (c *EmailClient) Get(ctx context.Context, id xid.ID) (*Email, error) {
	return c.Query().Where(email.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailClient) GetX(ctx context.Context, id xid.ID) *Email {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a Email.
func (c *EmailClient) QueryAccount(_m *Email) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(email.Table, email.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, email.AccountTable, email.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailClient) Hooks() []Hook {
	return c.hooks.Email
}

// Interceptors returns the client interceptors.
func (c *EmailClient) Interceptors() []Interceptor {
	return c.inters.Email
}

func (c *EmailClient) mutate(ctx context.Context, m *EmailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Email mutation op: %q", m.Op())
	}
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event.Intercept(f(g(h())))`.
func (c *EventClient) Intercept(interceptors ...Interceptor) {
	c.inters.Event = append(c.inters.Event, interceptors...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventClient) MapCreateBulk(slice any, setFunc func(*EventCreate, int)) *EventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventCreateBulk{err: fmt.Errorf("calling to EventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(_m *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(_m))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id xid.ID) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(_m *Event) *EventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id xid.ID) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id xid.ID) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id xid.ID) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParticipants queries the participants edge of a Event.
func (c *EventClient) QueryParticipants(_m *Event) *EventParticipantQuery {
	query := (&EventParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(eventparticipant.Table, eventparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.ParticipantsTable, event.ParticipantsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThread queries the thread edge of a Event.
func (c *EventClient) QueryThread(_m *Event) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, event.ThreadTable, event.ThreadColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrimaryImage queries the primary_image edge of a Event.
func (c *EventClient) QueryPrimaryImage(_m *Event) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, event.PrimaryImageTable, event.PrimaryImageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	return c.hooks.Event
}

// Interceptors returns the client interceptors.
func (c *EventClient) Interceptors() []Interceptor {
	return c.inters.Event
}

func (c *EventClient) mutate(ctx context.Context, m *EventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Event mutation op: %q", m.Op())
	}
}

// EventParticipantClient is a client for the EventParticipant schema.
type EventParticipantClient struct {
	config
}

// NewEventParticipantClient returns a client for the EventParticipant from the given config.
func NewEventParticipantClient(c config) *EventParticipantClient {
	return &EventParticipantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventparticipant.Hooks(f(g(h())))`.
func (c *EventParticipantClient) Use(hooks ...Hook) {
	c.hooks.EventParticipant = append(c.hooks.EventParticipant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventparticipant.Intercept(f(g(h())))`.
func (c *EventParticipantClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventParticipant = append(c.inters.EventParticipant, interceptors...)
}

// Create returns a builder for creating a EventParticipant entity.
func (c *EventParticipantClient) Create() *EventParticipantCreate {
	mutation := newEventParticipantMutation(c.config, OpCreate)
	return &EventParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventParticipant entities.
func (c *EventParticipantClient) CreateBulk(builders ...*EventParticipantCreate) *EventParticipantCreateBulk {
	return &EventParticipantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventParticipantClient) MapCreateBulk(slice any, setFunc func(*EventParticipantCreate, int)) *EventParticipantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventParticipantCreateBulk{err: fmt.Errorf("calling to EventParticipantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventParticipantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventParticipantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventParticipant.
func (c *EventParticipantClient) Update() *EventParticipantUpdate {
	mutation := newEventParticipantMutation(c.config, OpUpdate)
	return &EventParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventParticipantClient) UpdateOne(_m *EventParticipant) *EventParticipantUpdateOne {
	mutation := newEventParticipantMutation(c.config, OpUpdateOne, withEventParticipant(_m))
	return &EventParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventParticipantClient) UpdateOneID(id xid.ID) *EventParticipantUpdateOne {
	mutation := newEventParticipantMutation(c.config, OpUpdateOne, withEventParticipantID(id))
	return &EventParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventParticipant.
func (c *EventParticipantClient) Delete() *EventParticipantDelete {
	mutation := newEventParticipantMutation(c.config, OpDelete)
	return &EventParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventParticipantClient) DeleteOne(_m *EventParticipant) *EventParticipantDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventParticipantClient) DeleteOneID(id xid.ID) *EventParticipantDeleteOne {
	builder := c.Delete().Where(eventparticipant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventParticipantDeleteOne{builder}
}

// Query returns a query builder for EventParticipant.
func (c *EventParticipantClient) Query() *EventParticipantQuery {
	return &EventParticipantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventParticipant},
		inters: c.Interceptors(),
	}
}

// Get returns a EventParticipant entity by its id.
func (c *EventParticipantClient) Get(ctx context.Context, id xid.ID) (*EventParticipant, error) {
	return c.Query().Where(eventparticipant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventParticipantClient) GetX(ctx context.Context, id xid.ID) *EventParticipant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a EventParticipant.
func (c *EventParticipantClient) QueryAccount(_m *EventParticipant) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventparticipant.Table, eventparticipant.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, eventparticipant.AccountTable, eventparticipant.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a EventParticipant.
func (c *EventParticipantClient) QueryEvent(_m *EventParticipant) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventparticipant.Table, eventparticipant.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, eventparticipant.EventTable, eventparticipant.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventParticipantClient) Hooks() []Hook {
	return c.hooks.EventParticipant
}

// Interceptors returns the client interceptors.
func (c *EventParticipantClient) Interceptors() []Interceptor {
	return c.inters.EventParticipant
}

func (c *EventParticipantClient) mutate(ctx context.Context, m *EventParticipantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EventParticipant mutation op: %q", m.Op())
	}
}

// InvitationClient is a client for the Invitation schema.
type InvitationClient struct {
	config
}

// NewInvitationClient returns a client for the Invitation from the given config.
func NewInvitationClient(c config) *InvitationClient {
	return &InvitationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invitation.Hooks(f(g(h())))`.
func (c *InvitationClient) Use(hooks ...Hook) {
	c.hooks.Invitation = append(c.hooks.Invitation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invitation.Intercept(f(g(h())))`.
func (c *InvitationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Invitation = append(c.inters.Invitation, interceptors...)
}

// Create returns a builder for creating a Invitation entity.
func (c *InvitationClient) Create() *InvitationCreate {
	mutation := newInvitationMutation(c.config, OpCreate)
	return &InvitationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invitation entities.
func (c *InvitationClient) CreateBulk(builders ...*InvitationCreate) *InvitationCreateBulk {
	return &InvitationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvitationClient) MapCreateBulk(slice any, setFunc func(*InvitationCreate, int)) *InvitationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvitationCreateBulk{err: fmt.Errorf("calling to InvitationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvitationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvitationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invitation.
func (c *InvitationClient) Update() *InvitationUpdate {
	mutation := newInvitationMutation(c.config, OpUpdate)
	return &InvitationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvitationClient) UpdateOne(_m *Invitation) *InvitationUpdateOne {
	mutation := newInvitationMutation(c.config, OpUpdateOne, withInvitation(_m))
	return &InvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvitationClient) UpdateOneID(id xid.ID) *InvitationUpdateOne {
	mutation := newInvitationMutation(c.config, OpUpdateOne, withInvitationID(id))
	return &InvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invitation.
func (c *InvitationClient) Delete() *InvitationDelete {
	mutation := newInvitationMutation(c.config, OpDelete)
	return &InvitationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvitationClient) DeleteOne(_m *Invitation) *InvitationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvitationClient) DeleteOneID(id xid.ID) *InvitationDeleteOne {
	builder := c.Delete().Where(invitation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvitationDeleteOne{builder}
}

// Query returns a query builder for Invitation.
func (c *InvitationClient) Query() *InvitationQuery {
	return &InvitationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvitation},
		inters: c.Interceptors(),
	}
}

// Get returns a Invitation entity by its id.
func (c *InvitationClient) Get(ctx context.Context, id xid.ID) (*Invitation, error) {
	return c.Query().Where(invitation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvitationClient) GetX(ctx context.Context, id xid.ID) *Invitation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCreator queries the creator edge of a Invitation.
func (c *InvitationClient) QueryCreator(_m *Invitation) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invitation.Table, invitation.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invitation.CreatorTable, invitation.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvited queries the invited edge of a Invitation.
func (c *InvitationClient) QueryInvited(_m *Invitation) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invitation.Table, invitation.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, invitation.InvitedTable, invitation.InvitedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InvitationClient) Hooks() []Hook {
	return c.hooks.Invitation
}

// Interceptors returns the client interceptors.
func (c *InvitationClient) Interceptors() []Interceptor {
	return c.inters.Invitation
}

func (c *InvitationClient) mutate(ctx context.Context, m *InvitationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvitationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvitationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvitationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Invitation mutation op: %q", m.Op())
	}
}

// LikePostClient is a client for the LikePost schema.
type LikePostClient struct {
	config
}

// NewLikePostClient returns a client for the LikePost from the given config.
func NewLikePostClient(c config) *LikePostClient {
	return &LikePostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `likepost.Hooks(f(g(h())))`.
func (c *LikePostClient) Use(hooks ...Hook) {
	c.hooks.LikePost = append(c.hooks.LikePost, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `likepost.Intercept(f(g(h())))`.
func (c *LikePostClient) Intercept(interceptors ...Interceptor) {
	c.inters.LikePost = append(c.inters.LikePost, interceptors...)
}

// Create returns a builder for creating a LikePost entity.
func (c *LikePostClient) Create() *LikePostCreate {
	mutation := newLikePostMutation(c.config, OpCreate)
	return &LikePostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LikePost entities.
func (c *LikePostClient) CreateBulk(builders ...*LikePostCreate) *LikePostCreateBulk {
	return &LikePostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LikePostClient) MapCreateBulk(slice any, setFunc func(*LikePostCreate, int)) *LikePostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LikePostCreateBulk{err: fmt.Errorf("calling to LikePostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LikePostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LikePostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LikePost.
func (c *LikePostClient) Update() *LikePostUpdate {
	mutation := newLikePostMutation(c.config, OpUpdate)
	return &LikePostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LikePostClient) UpdateOne(_m *LikePost) *LikePostUpdateOne {
	mutation := newLikePostMutation(c.config, OpUpdateOne, withLikePost(_m))
	return &LikePostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LikePostClient) UpdateOneID(id xid.ID) *LikePostUpdateOne {
	mutation := newLikePostMutation(c.config, OpUpdateOne, withLikePostID(id))
	return &LikePostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LikePost.
func (c *LikePostClient) Delete() *LikePostDelete {
	mutation := newLikePostMutation(c.config, OpDelete)
	return &LikePostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LikePostClient) DeleteOne(_m *LikePost) *LikePostDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LikePostClient) DeleteOneID(id xid.ID) *LikePostDeleteOne {
	builder := c.Delete().Where(likepost.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LikePostDeleteOne{builder}
}

// Query returns a query builder for LikePost.
func (c *LikePostClient) Query() *LikePostQuery {
	return &LikePostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLikePost},
		inters: c.Interceptors(),
	}
}

// Get returns a LikePost entity by its id.
func (c *LikePostClient) Get(ctx context.Context, id xid.ID) (*LikePost, error) {
	return c.Query().Where(likepost.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LikePostClient) GetX(ctx context.Context, id xid.ID) *LikePost {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a LikePost.
func (c *LikePostClient) QueryAccount(_m *LikePost) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(likepost.Table, likepost.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, likepost.AccountTable, likepost.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPost queries the Post edge of a LikePost.
func (c *LikePostClient) QueryPost(_m *LikePost) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(likepost.Table, likepost.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, likepost.PostTable, likepost.PostColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LikePostClient) Hooks() []Hook {
	return c.hooks.LikePost
}

// Interceptors returns the client interceptors.
func (c *LikePostClient) Interceptors() []Interceptor {
	return c.inters.LikePost
}

func (c *LikePostClient) mutate(ctx context.Context, m *LikePostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LikePostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LikePostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LikePostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LikePostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LikePost mutation op: %q", m.Op())
	}
}

// LinkClient is a client for the Link schema.
type LinkClient struct {
	config
}

// NewLinkClient returns a client for the Link from the given config.
func NewLinkClient(c config) *LinkClient {
	return &LinkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `link.Hooks(f(g(h())))`.
func (c *LinkClient) Use(hooks ...Hook) {
	c.hooks.Link = append(c.hooks.Link, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `link.Intercept(f(g(h())))`.
func (c *LinkClient) Intercept(interceptors ...Interceptor) {
	c.inters.Link = append(c.inters.Link, interceptors...)
}

// Create returns a builder for creating a Link entity.
func (c *LinkClient) Create() *LinkCreate {
	mutation := newLinkMutation(c.config, OpCreate)
	return &LinkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Link entities.
func (c *LinkClient) CreateBulk(builders ...*LinkCreate) *LinkCreateBulk {
	return &LinkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LinkClient) MapCreateBulk(slice any, setFunc func(*LinkCreate, int)) *LinkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LinkCreateBulk{err: fmt.Errorf("calling to LinkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LinkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LinkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Link.
func (c *LinkClient) Update() *LinkUpdate {
	mutation := newLinkMutation(c.config, OpUpdate)
	return &LinkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LinkClient) UpdateOne(_m *Link) *LinkUpdateOne {
	mutation := newLinkMutation(c.config, OpUpdateOne, withLink(_m))
	return &LinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LinkClient) UpdateOneID(id xid.ID) *LinkUpdateOne {
	mutation := newLinkMutation(c.config, OpUpdateOne, withLinkID(id))
	return &LinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Link.
func (c *LinkClient) Delete() *LinkDelete {
	mutation := newLinkMutation(c.config, OpDelete)
	return &LinkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LinkClient) DeleteOne(_m *Link) *LinkDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LinkClient) DeleteOneID(id xid.ID) *LinkDeleteOne {
	builder := c.Delete().Where(link.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LinkDeleteOne{builder}
}

// Query returns a query builder for Link.
func (c *LinkClient) Query() *LinkQuery {
	return &LinkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLink},
		inters: c.Interceptors(),
	}
}

// Get returns a Link entity by its id.
func (c *LinkClient) Get(ctx context.Context, id xid.ID) (*Link, error) {
	return c.Query().Where(link.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LinkClient) GetX(ctx context.Context, id xid.ID) *Link {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPosts queries the posts edge of a Link.
func (c *LinkClient) QueryPosts(_m *Link) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(link.Table, link.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, link.PostsTable, link.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPostContentReferences queries the post_content_references edge of a Link.
func (c *LinkClient) QueryPostContentReferences(_m *Link) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(link.Table, link.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, link.PostContentReferencesTable, link.PostContentReferencesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a Link.
func (c *LinkClient) QueryNodes(_m *Link) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(link.Table, link.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, link.NodesTable, link.NodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodeContentReferences queries the node_content_references edge of a Link.
func (c *LinkClient) QueryNodeContentReferences(_m *Link) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(link.Table, link.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, link.NodeContentReferencesTable, link.NodeContentReferencesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrimaryImage queries the primary_image edge of a Link.
func (c *LinkClient) QueryPrimaryImage(_m *Link) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(link.Table, link.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, link.PrimaryImageTable, link.PrimaryImageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFaviconImage queries the favicon_image edge of a Link.
func (c *LinkClient) QueryFaviconImage(_m *Link) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(link.Table, link.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, link.FaviconImageTable, link.FaviconImageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Link.
func (c *LinkClient) QueryAssets(_m *Link) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(link.Table, link.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, link.AssetsTable, link.AssetsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LinkClient) Hooks() []Hook {
	return c.hooks.Link
}

// Interceptors returns the client interceptors.
func (c *LinkClient) Interceptors() []Interceptor {
	return c.inters.Link
}

func (c *LinkClient) mutate(ctx context.Context, m *LinkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LinkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LinkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LinkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Link mutation op: %q", m.Op())
	}
}

// MentionProfileClient is a client for the MentionProfile schema.
type MentionProfileClient struct {
	config
}

// NewMentionProfileClient returns a client for the MentionProfile from the given config.
func NewMentionProfileClient(c config) *MentionProfileClient {
	return &MentionProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mentionprofile.Hooks(f(g(h())))`.
func (c *MentionProfileClient) Use(hooks ...Hook) {
	c.hooks.MentionProfile = append(c.hooks.MentionProfile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mentionprofile.Intercept(f(g(h())))`.
func (c *MentionProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.MentionProfile = append(c.inters.MentionProfile, interceptors...)
}

// Create returns a builder for creating a MentionProfile entity.
func (c *MentionProfileClient) Create() *MentionProfileCreate {
	mutation := newMentionProfileMutation(c.config, OpCreate)
	return &MentionProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MentionProfile entities.
func (c *MentionProfileClient) CreateBulk(builders ...*MentionProfileCreate) *MentionProfileCreateBulk {
	return &MentionProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MentionProfileClient) MapCreateBulk(slice any, setFunc func(*MentionProfileCreate, int)) *MentionProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MentionProfileCreateBulk{err: fmt.Errorf("calling to MentionProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MentionProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MentionProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MentionProfile.
func (c *MentionProfileClient) Update() *MentionProfileUpdate {
	mutation := newMentionProfileMutation(c.config, OpUpdate)
	return &MentionProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MentionProfileClient) UpdateOne(_m *MentionProfile) *MentionProfileUpdateOne {
	mutation := newMentionProfileMutation(c.config, OpUpdateOne, withMentionProfile(_m))
	return &MentionProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MentionProfileClient) UpdateOneID(id xid.ID) *MentionProfileUpdateOne {
	mutation := newMentionProfileMutation(c.config, OpUpdateOne, withMentionProfileID(id))
	return &MentionProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MentionProfile.
func (c *MentionProfileClient) Delete() *MentionProfileDelete {
	mutation := newMentionProfileMutation(c.config, OpDelete)
	return &MentionProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MentionProfileClient) DeleteOne(_m *MentionProfile) *MentionProfileDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MentionProfileClient) DeleteOneID(id xid.ID) *MentionProfileDeleteOne {
	builder := c.Delete().Where(mentionprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MentionProfileDeleteOne{builder}
}

// Query returns a query builder for MentionProfile.
func (c *MentionProfileClient) Query() *MentionProfileQuery {
	return &MentionProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMentionProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a MentionProfile entity by its id.
func (c *MentionProfileClient) Get(ctx context.Context, id xid.ID) (*MentionProfile, error) {
	return c.Query().Where(mentionprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MentionProfileClient) GetX(ctx context.Context, id xid.ID) *MentionProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a MentionProfile.
func (c *MentionProfileClient) QueryAccount(_m *MentionProfile) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mentionprofile.Table, mentionprofile.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mentionprofile.AccountTable, mentionprofile.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPost queries the Post edge of a MentionProfile.
func (c *MentionProfileClient) QueryPost(_m *MentionProfile) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mentionprofile.Table, mentionprofile.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mentionprofile.PostTable, mentionprofile.PostColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MentionProfileClient) Hooks() []Hook {
	return c.hooks.MentionProfile
}

// Interceptors returns the client interceptors.
func (c *MentionProfileClient) Interceptors() []Interceptor {
	return c.inters.MentionProfile
}

func (c *MentionProfileClient) mutate(ctx context.Context, m *MentionProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MentionProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MentionProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MentionProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MentionProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MentionProfile mutation op: %q", m.Op())
	}
}

// NodeClient is a client for the Node schema.
type NodeClient struct {
	config
}

// NewNodeClient returns a client for the Node from the given config.
func NewNodeClient(c config) *NodeClient {
	return &NodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `node.Hooks(f(g(h())))`.
func (c *NodeClient) Use(hooks ...Hook) {
	c.hooks.Node = append(c.hooks.Node, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `node.Intercept(f(g(h())))`.
func (c *NodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Node = append(c.inters.Node, interceptors...)
}

// Create returns a builder for creating a Node entity.
func (c *NodeClient) Create() *NodeCreate {
	mutation := newNodeMutation(c.config, OpCreate)
	return &NodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Node entities.
func (c *NodeClient) CreateBulk(builders ...*NodeCreate) *NodeCreateBulk {
	return &NodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NodeClient) MapCreateBulk(slice any, setFunc func(*NodeCreate, int)) *NodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NodeCreateBulk{err: fmt.Errorf("calling to NodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Node.
func (c *NodeClient) Update() *NodeUpdate {
	mutation := newNodeMutation(c.config, OpUpdate)
	return &NodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NodeClient) UpdateOne(_m *Node) *NodeUpdateOne {
	mutation := newNodeMutation(c.config, OpUpdateOne, withNode(_m))
	return &NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NodeClient) UpdateOneID(id xid.ID) *NodeUpdateOne {
	mutation := newNodeMutation(c.config, OpUpdateOne, withNodeID(id))
	return &NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Node.
func (c *NodeClient) Delete() *NodeDelete {
	mutation := newNodeMutation(c.config, OpDelete)
	return &NodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NodeClient) DeleteOne(_m *Node) *NodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NodeClient) DeleteOneID(id xid.ID) *NodeDeleteOne {
	builder := c.Delete().Where(node.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NodeDeleteOne{builder}
}

// Query returns a query builder for Node.
func (c *NodeClient) Query() *NodeQuery {
	return &NodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNode},
		inters: c.Interceptors(),
	}
}

// Get returns a Node entity by its id.
func (c *NodeClient) Get(ctx context.Context, id xid.ID) (*Node, error) {
	return c.Query().Where(node.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NodeClient) GetX(ctx context.Context, id xid.ID) *Node {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Node.
func (c *NodeClient) QueryOwner(_m *Node) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, node.OwnerTable, node.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Node.
func (c *NodeClient) QueryParent(_m *Node) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, node.ParentTable, node.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a Node.
func (c *NodeClient) QueryNodes(_m *Node) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.NodesTable, node.NodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrimaryImage queries the primary_image edge of a Node.
func (c *NodeClient) QueryPrimaryImage(_m *Node) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, node.PrimaryImageTable, node.PrimaryImageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Node.
func (c *NodeClient) QueryAssets(_m *Node) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, node.AssetsTable, node.AssetsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a Node.
func (c *NodeClient) QueryTags(_m *Node) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, node.TagsTable, node.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProperties queries the properties edge of a Node.
func (c *NodeClient) QueryProperties(_m *Node) *PropertyQuery {
	query := (&PropertyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(property.Table, property.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, node.PropertiesTable, node.PropertiesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPropertySchema queries the property_schema edge of a Node.
func (c *NodeClient) QueryPropertySchema(_m *Node) *PropertySchemaQuery {
	query := (&PropertySchemaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(propertyschema.Table, propertyschema.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, node.PropertySchemaTable, node.PropertySchemaColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLink queries the link edge of a Node.
func (c *NodeClient) QueryLink(_m *Node) *LinkQuery {
	query := (&LinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(link.Table, link.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, node.LinkTable, node.LinkColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContentLinks queries the content_links edge of a Node.
func (c *NodeClient) QueryContentLinks(_m *Node) *LinkQuery {
	query := (&LinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(link.Table, link.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, node.ContentLinksTable, node.ContentLinksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollections queries the collections edge of a Node.
func (c *NodeClient) QueryCollections(_m *Node) *CollectionQuery {
	query := (&CollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(collection.Table, collection.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, node.CollectionsTable, node.CollectionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollectionNodes queries the collection_nodes edge of a Node.
func (c *NodeClient) QueryCollectionNodes(_m *Node) *CollectionNodeQuery {
	query := (&CollectionNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(node.Table, node.FieldID, id),
			sqlgraph.To(collectionnode.Table, collectionnode.NodeColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, node.CollectionNodesTable, node.CollectionNodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NodeClient) Hooks() []Hook {
	return c.hooks.Node
}

// Interceptors returns the client interceptors.
func (c *NodeClient) Interceptors() []Interceptor {
	return c.inters.Node
}

func (c *NodeClient) mutate(ctx context.Context, m *NodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Node mutation op: %q", m.Op())
	}
}

// NotificationClient is a client for the Notification schema.
type NotificationClient struct {
	config
}

// NewNotificationClient returns a client for the Notification from the given config.
func NewNotificationClient(c config) *NotificationClient {
	return &NotificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notification.Hooks(f(g(h())))`.
func (c *NotificationClient) Use(hooks ...Hook) {
	c.hooks.Notification = append(c.hooks.Notification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notification.Intercept(f(g(h())))`.
func (c *NotificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Notification = append(c.inters.Notification, interceptors...)
}

// Create returns a builder for creating a Notification entity.
func (c *NotificationClient) Create() *NotificationCreate {
	mutation := newNotificationMutation(c.config, OpCreate)
	return &NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Notification entities.
func (c *NotificationClient) CreateBulk(builders ...*NotificationCreate) *NotificationCreateBulk {
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationClient) MapCreateBulk(slice any, setFunc func(*NotificationCreate, int)) *NotificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationCreateBulk{err: fmt.Errorf("calling to NotificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Notification.
func (c *NotificationClient) Update() *NotificationUpdate {
	mutation := newNotificationMutation(c.config, OpUpdate)
	return &NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationClient) UpdateOne(_m *Notification) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotification(_m))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationClient) UpdateOneID(id xid.ID) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotificationID(id))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Notification.
func (c *NotificationClient) Delete() *NotificationDelete {
	mutation := newNotificationMutation(c.config, OpDelete)
	return &NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationClient) DeleteOne(_m *Notification) *NotificationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationClient) DeleteOneID(id xid.ID) *NotificationDeleteOne {
	builder := c.Delete().Where(notification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationDeleteOne{builder}
}

// Query returns a query builder for Notification.
func (c *NotificationClient) Query() *NotificationQuery {
	return &NotificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotification},
		inters: c.Interceptors(),
	}
}

// Get returns a Notification entity by its id.
func (c *NotificationClient) Get(ctx context.Context, id xid.ID) (*Notification, error) {
	return c.Query().Where(notification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationClient) GetX(ctx context.Context, id xid.ID) *Notification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Notification.
func (c *NotificationClient) QueryOwner(_m *Notification) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notification.OwnerTable, notification.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySource queries the source edge of a Notification.
func (c *NotificationClient) QuerySource(_m *Notification) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notification.SourceTable, notification.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationClient) Hooks() []Hook {
	return c.hooks.Notification
}

// Interceptors returns the client interceptors.
func (c *NotificationClient) Interceptors() []Interceptor {
	return c.inters.Notification
}

func (c *NotificationClient) mutate(ctx context.Context, m *NotificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Notification mutation op: %q", m.Op())
	}
}

// PluginClient is a client for the Plugin schema.
type PluginClient struct {
	config
}

// NewPluginClient returns a client for the Plugin from the given config.
func NewPluginClient(c config) *PluginClient {
	return &PluginClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entplugin.Hooks(f(g(h())))`.
func (c *PluginClient) Use(hooks ...Hook) {
	c.hooks.Plugin = append(c.hooks.Plugin, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entplugin.Intercept(f(g(h())))`.
func (c *PluginClient) Intercept(interceptors ...Interceptor) {
	c.inters.Plugin = append(c.inters.Plugin, interceptors...)
}

// Create returns a builder for creating a Plugin entity.
func (c *PluginClient) Create() *PluginCreate {
	mutation := newPluginMutation(c.config, OpCreate)
	return &PluginCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Plugin entities.
func (c *PluginClient) CreateBulk(builders ...*PluginCreate) *PluginCreateBulk {
	return &PluginCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PluginClient) MapCreateBulk(slice any, setFunc func(*PluginCreate, int)) *PluginCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PluginCreateBulk{err: fmt.Errorf("calling to PluginClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PluginCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PluginCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Plugin.
func (c *PluginClient) Update() *PluginUpdate {
	mutation := newPluginMutation(c.config, OpUpdate)
	return &PluginUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PluginClient) UpdateOne(_m *Plugin) *PluginUpdateOne {
	mutation := newPluginMutation(c.config, OpUpdateOne, withPlugin(_m))
	return &PluginUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PluginClient) UpdateOneID(id xid.ID) *PluginUpdateOne {
	mutation := newPluginMutation(c.config, OpUpdateOne, withPluginID(id))
	return &PluginUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Plugin.
func (c *PluginClient) Delete() *PluginDelete {
	mutation := newPluginMutation(c.config, OpDelete)
	return &PluginDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PluginClient) DeleteOne(_m *Plugin) *PluginDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PluginClient) DeleteOneID(id xid.ID) *PluginDeleteOne {
	builder := c.Delete().Where(entplugin.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PluginDeleteOne{builder}
}

// Query returns a query builder for Plugin.
func (c *PluginClient) Query() *PluginQuery {
	return &PluginQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlugin},
		inters: c.Interceptors(),
	}
}

// Get returns a Plugin entity by its id.
func (c *PluginClient) Get(ctx context.Context, id xid.ID) (*Plugin, error) {
	return c.Query().Where(entplugin.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PluginClient) GetX(ctx context.Context, id xid.ID) *Plugin {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a Plugin.
func (c *PluginClient) QueryAccount(_m *Plugin) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entplugin.Table, entplugin.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entplugin.AccountTable, entplugin.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PluginClient) Hooks() []Hook {
	return c.hooks.Plugin
}

// Interceptors returns the client interceptors.
func (c *PluginClient) Interceptors() []Interceptor {
	return c.inters.Plugin
}

func (c *PluginClient) mutate(ctx context.Context, m *PluginMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PluginCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PluginUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PluginUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PluginDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Plugin mutation op: %q", m.Op())
	}
}

// PostClient is a client for the Post schema.
type PostClient struct {
	config
}

// NewPostClient returns a client for the Post from the given config.
func NewPostClient(c config) *PostClient {
	return &PostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `post.Hooks(f(g(h())))`.
func (c *PostClient) Use(hooks ...Hook) {
	c.hooks.Post = append(c.hooks.Post, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `post.Intercept(f(g(h())))`.
func (c *PostClient) Intercept(interceptors ...Interceptor) {
	c.inters.Post = append(c.inters.Post, interceptors...)
}

// Create returns a builder for creating a Post entity.
func (c *PostClient) Create() *PostCreate {
	mutation := newPostMutation(c.config, OpCreate)
	return &PostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Post entities.
func (c *PostClient) CreateBulk(builders ...*PostCreate) *PostCreateBulk {
	return &PostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostClient) MapCreateBulk(slice any, setFunc func(*PostCreate, int)) *PostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostCreateBulk{err: fmt.Errorf("calling to PostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Post.
func (c *PostClient) Update() *PostUpdate {
	mutation := newPostMutation(c.config, OpUpdate)
	return &PostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostClient) UpdateOne(_m *Post) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPost(_m))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostClient) UpdateOneID(id xid.ID) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPostID(id))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Post.
func (c *PostClient) Delete() *PostDelete {
	mutation := newPostMutation(c.config, OpDelete)
	return &PostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostClient) DeleteOne(_m *Post) *PostDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostClient) DeleteOneID(id xid.ID) *PostDeleteOne {
	builder := c.Delete().Where(post.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostDeleteOne{builder}
}

// Query returns a query builder for Post.
func (c *PostClient) Query() *PostQuery {
	return &PostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePost},
		inters: c.Interceptors(),
	}
}

// Get returns a Post entity by its id.
func (c *PostClient) Get(ctx context.Context, id xid.ID) (*Post, error) {
	return c.Query().Where(post.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostClient) GetX(ctx context.Context, id xid.ID) *Post {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthor queries the author edge of a Post.
func (c *PostClient) QueryAuthor(_m *Post) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.AuthorTable, post.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategory queries the category edge of a Post.
func (c *PostClient) QueryCategory(_m *Post) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.CategoryTable, post.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a Post.
func (c *PostClient) QueryTags(_m *Post) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, post.TagsTable, post.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoot queries the root edge of a Post.
func (c *PostClient) QueryRoot(_m *Post) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.RootTable, post.RootColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPosts queries the posts edge of a Post.
func (c *PostClient) QueryPosts(_m *Post) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.PostsTable, post.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReplyTo queries the replyTo edge of a Post.
func (c *PostClient) QueryReplyTo(_m *Post) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.ReplyToTable, post.ReplyToColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReplies queries the replies edge of a Post.
func (c *PostClient) QueryReplies(_m *Post) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.RepliesTable, post.RepliesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReacts queries the reacts edge of a Post.
func (c *PostClient) QueryReacts(_m *Post) *ReactQuery {
	query := (&ReactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(react.Table, react.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.ReactsTable, post.ReactsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikes queries the likes edge of a Post.
func (c *PostClient) QueryLikes(_m *Post) *LikePostQuery {
	query := (&LikePostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(likepost.Table, likepost.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.LikesTable, post.LikesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMentions queries the mentions edge of a Post.
func (c *PostClient) QueryMentions(_m *Post) *MentionProfileQuery {
	query := (&MentionProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(mentionprofile.Table, mentionprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.MentionsTable, post.MentionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Post.
func (c *PostClient) QueryAssets(_m *Post) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, post.AssetsTable, post.AssetsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollections queries the collections edge of a Post.
func (c *PostClient) QueryCollections(_m *Post) *CollectionQuery {
	query := (&CollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(collection.Table, collection.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, post.CollectionsTable, post.CollectionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLink queries the link edge of a Post.
func (c *PostClient) QueryLink(_m *Post) *LinkQuery {
	query := (&LinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(link.Table, link.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.LinkTable, post.LinkColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContentLinks queries the content_links edge of a Post.
func (c *PostClient) QueryContentLinks(_m *Post) *LinkQuery {
	query := (&LinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(link.Table, link.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, post.ContentLinksTable, post.ContentLinksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Post.
func (c *PostClient) QueryEvent(_m *Post) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.EventTable, post.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPostReads queries the post_reads edge of a Post.
func (c *PostClient) QueryPostReads(_m *Post) *PostReadQuery {
	query := (&PostReadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(postread.Table, postread.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, post.PostReadsTable, post.PostReadsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostClient) Hooks() []Hook {
	return c.hooks.Post
}

// Interceptors returns the client interceptors.
func (c *PostClient) Interceptors() []Interceptor {
	return c.inters.Post
}

func (c *PostClient) mutate(ctx context.Context, m *PostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Post mutation op: %q", m.Op())
	}
}

// PostReadClient is a client for the PostRead schema.
type PostReadClient struct {
	config
}

// NewPostReadClient returns a client for the PostRead from the given config.
func NewPostReadClient(c config) *PostReadClient {
	return &PostReadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `postread.Hooks(f(g(h())))`.
func (c *PostReadClient) Use(hooks ...Hook) {
	c.hooks.PostRead = append(c.hooks.PostRead, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `postread.Intercept(f(g(h())))`.
func (c *PostReadClient) Intercept(interceptors ...Interceptor) {
	c.inters.PostRead = append(c.inters.PostRead, interceptors...)
}

// Create returns a builder for creating a PostRead entity.
func (c *PostReadClient) Create() *PostReadCreate {
	mutation := newPostReadMutation(c.config, OpCreate)
	return &PostReadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PostRead entities.
func (c *PostReadClient) CreateBulk(builders ...*PostReadCreate) *PostReadCreateBulk {
	return &PostReadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostReadClient) MapCreateBulk(slice any, setFunc func(*PostReadCreate, int)) *PostReadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostReadCreateBulk{err: fmt.Errorf("calling to PostReadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostReadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostReadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PostRead.
func (c *PostReadClient) Update() *PostReadUpdate {
	mutation := newPostReadMutation(c.config, OpUpdate)
	return &PostReadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostReadClient) UpdateOne(_m *PostRead) *PostReadUpdateOne {
	mutation := newPostReadMutation(c.config, OpUpdateOne, withPostRead(_m))
	return &PostReadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostReadClient) UpdateOneID(id xid.ID) *PostReadUpdateOne {
	mutation := newPostReadMutation(c.config, OpUpdateOne, withPostReadID(id))
	return &PostReadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PostRead.
func (c *PostReadClient) Delete() *PostReadDelete {
	mutation := newPostReadMutation(c.config, OpDelete)
	return &PostReadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostReadClient) DeleteOne(_m *PostRead) *PostReadDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostReadClient) DeleteOneID(id xid.ID) *PostReadDeleteOne {
	builder := c.Delete().Where(postread.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostReadDeleteOne{builder}
}

// Query returns a query builder for PostRead.
func (c *PostReadClient) Query() *PostReadQuery {
	return &PostReadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePostRead},
		inters: c.Interceptors(),
	}
}

// Get returns a PostRead entity by its id.
func (c *PostReadClient) Get(ctx context.Context, id xid.ID) (*PostRead, error) {
	return c.Query().Where(postread.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostReadClient) GetX(ctx context.Context, id xid.ID) *PostRead {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRootPost queries the root_post edge of a PostRead.
func (c *PostReadClient) QueryRootPost(_m *PostRead) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(postread.Table, postread.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, postread.RootPostTable, postread.RootPostColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccount queries the account edge of a PostRead.
func (c *PostReadClient) QueryAccount(_m *PostRead) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(postread.Table, postread.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, postread.AccountTable, postread.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostReadClient) Hooks() []Hook {
	return c.hooks.PostRead
}

// Interceptors returns the client interceptors.
func (c *PostReadClient) Interceptors() []Interceptor {
	return c.inters.PostRead
}

func (c *PostReadClient) mutate(ctx context.Context, m *PostReadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostReadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostReadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostReadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostReadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PostRead mutation op: %q", m.Op())
	}
}

// PropertyClient is a client for the Property schema.
type PropertyClient struct {
	config
}

// NewPropertyClient returns a client for the Property from the given config.
func NewPropertyClient(c config) *PropertyClient {
	return &PropertyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `property.Hooks(f(g(h())))`.
func (c *PropertyClient) Use(hooks ...Hook) {
	c.hooks.Property = append(c.hooks.Property, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `property.Intercept(f(g(h())))`.
func (c *PropertyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Property = append(c.inters.Property, interceptors...)
}

// Create returns a builder for creating a Property entity.
func (c *PropertyClient) Create() *PropertyCreate {
	mutation := newPropertyMutation(c.config, OpCreate)
	return &PropertyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Property entities.
func (c *PropertyClient) CreateBulk(builders ...*PropertyCreate) *PropertyCreateBulk {
	return &PropertyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PropertyClient) MapCreateBulk(slice any, setFunc func(*PropertyCreate, int)) *PropertyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PropertyCreateBulk{err: fmt.Errorf("calling to PropertyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PropertyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PropertyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Property.
func (c *PropertyClient) Update() *PropertyUpdate {
	mutation := newPropertyMutation(c.config, OpUpdate)
	return &PropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PropertyClient) UpdateOne(_m *Property) *PropertyUpdateOne {
	mutation := newPropertyMutation(c.config, OpUpdateOne, withProperty(_m))
	return &PropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PropertyClient) UpdateOneID(id xid.ID) *PropertyUpdateOne {
	mutation := newPropertyMutation(c.config, OpUpdateOne, withPropertyID(id))
	return &PropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Property.
func (c *PropertyClient) Delete() *PropertyDelete {
	mutation := newPropertyMutation(c.config, OpDelete)
	return &PropertyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PropertyClient) DeleteOne(_m *Property) *PropertyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PropertyClient) DeleteOneID(id xid.ID) *PropertyDeleteOne {
	builder := c.Delete().Where(property.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PropertyDeleteOne{builder}
}

// Query returns a query builder for Property.
func (c *PropertyClient) Query() *PropertyQuery {
	return &PropertyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProperty},
		inters: c.Interceptors(),
	}
}

// Get returns a Property entity by its id.
func (c *PropertyClient) Get(ctx context.Context, id xid.ID) (*Property, error) {
	return c.Query().Where(property.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PropertyClient) GetX(ctx context.Context, id xid.ID) *Property {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNode queries the node edge of a Property.
func (c *PropertyClient) QueryNode(_m *Property) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(property.Table, property.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, property.NodeTable, property.NodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySchema queries the schema edge of a Property.
func (c *PropertyClient) QuerySchema(_m *Property) *PropertySchemaFieldQuery {
	query := (&PropertySchemaFieldClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(property.Table, property.FieldID, id),
			sqlgraph.To(propertyschemafield.Table, propertyschemafield.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, property.SchemaTable, property.SchemaColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PropertyClient) Hooks() []Hook {
	return c.hooks.Property
}

// Interceptors returns the client interceptors.
func (c *PropertyClient) Interceptors() []Interceptor {
	return c.inters.Property
}

func (c *PropertyClient) mutate(ctx context.Context, m *PropertyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PropertyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PropertyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PropertyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PropertyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Property mutation op: %q", m.Op())
	}
}

// PropertySchemaClient is a client for the PropertySchema schema.
type PropertySchemaClient struct {
	config
}

// NewPropertySchemaClient returns a client for the PropertySchema from the given config.
func NewPropertySchemaClient(c config) *PropertySchemaClient {
	return &PropertySchemaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `propertyschema.Hooks(f(g(h())))`.
func (c *PropertySchemaClient) Use(hooks ...Hook) {
	c.hooks.PropertySchema = append(c.hooks.PropertySchema, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `propertyschema.Intercept(f(g(h())))`.
func (c *PropertySchemaClient) Intercept(interceptors ...Interceptor) {
	c.inters.PropertySchema = append(c.inters.PropertySchema, interceptors...)
}

// Create returns a builder for creating a PropertySchema entity.
func (c *PropertySchemaClient) Create() *PropertySchemaCreate {
	mutation := newPropertySchemaMutation(c.config, OpCreate)
	return &PropertySchemaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PropertySchema entities.
func (c *PropertySchemaClient) CreateBulk(builders ...*PropertySchemaCreate) *PropertySchemaCreateBulk {
	return &PropertySchemaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PropertySchemaClient) MapCreateBulk(slice any, setFunc func(*PropertySchemaCreate, int)) *PropertySchemaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PropertySchemaCreateBulk{err: fmt.Errorf("calling to PropertySchemaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PropertySchemaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PropertySchemaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PropertySchema.
func (c *PropertySchemaClient) Update() *PropertySchemaUpdate {
	mutation := newPropertySchemaMutation(c.config, OpUpdate)
	return &PropertySchemaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PropertySchemaClient) UpdateOne(_m *PropertySchema) *PropertySchemaUpdateOne {
	mutation := newPropertySchemaMutation(c.config, OpUpdateOne, withPropertySchema(_m))
	return &PropertySchemaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PropertySchemaClient) UpdateOneID(id xid.ID) *PropertySchemaUpdateOne {
	mutation := newPropertySchemaMutation(c.config, OpUpdateOne, withPropertySchemaID(id))
	return &PropertySchemaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PropertySchema.
func (c *PropertySchemaClient) Delete() *PropertySchemaDelete {
	mutation := newPropertySchemaMutation(c.config, OpDelete)
	return &PropertySchemaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PropertySchemaClient) DeleteOne(_m *PropertySchema) *PropertySchemaDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PropertySchemaClient) DeleteOneID(id xid.ID) *PropertySchemaDeleteOne {
	builder := c.Delete().Where(propertyschema.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PropertySchemaDeleteOne{builder}
}

// Query returns a query builder for PropertySchema.
func (c *PropertySchemaClient) Query() *PropertySchemaQuery {
	return &PropertySchemaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePropertySchema},
		inters: c.Interceptors(),
	}
}

// Get returns a PropertySchema entity by its id.
func (c *PropertySchemaClient) Get(ctx context.Context, id xid.ID) (*PropertySchema, error) {
	return c.Query().Where(propertyschema.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PropertySchemaClient) GetX(ctx context.Context, id xid.ID) *PropertySchema {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNode queries the node edge of a PropertySchema.
func (c *PropertySchemaClient) QueryNode(_m *PropertySchema) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(propertyschema.Table, propertyschema.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, propertyschema.NodeTable, propertyschema.NodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFields queries the fields edge of a PropertySchema.
func (c *PropertySchemaClient) QueryFields(_m *PropertySchema) *PropertySchemaFieldQuery {
	query := (&PropertySchemaFieldClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(propertyschema.Table, propertyschema.FieldID, id),
			sqlgraph.To(propertyschemafield.Table, propertyschemafield.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, propertyschema.FieldsTable, propertyschema.FieldsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PropertySchemaClient) Hooks() []Hook {
	return c.hooks.PropertySchema
}

// Interceptors returns the client interceptors.
func (c *PropertySchemaClient) Interceptors() []Interceptor {
	return c.inters.PropertySchema
}

func (c *PropertySchemaClient) mutate(ctx context.Context, m *PropertySchemaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PropertySchemaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PropertySchemaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PropertySchemaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PropertySchemaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PropertySchema mutation op: %q", m.Op())
	}
}

// PropertySchemaFieldClient is a client for the PropertySchemaField schema.
type PropertySchemaFieldClient struct {
	config
}

// NewPropertySchemaFieldClient returns a client for the PropertySchemaField from the given config.
func NewPropertySchemaFieldClient(c config) *PropertySchemaFieldClient {
	return &PropertySchemaFieldClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `propertyschemafield.Hooks(f(g(h())))`.
func (c *PropertySchemaFieldClient) Use(hooks ...Hook) {
	c.hooks.PropertySchemaField = append(c.hooks.PropertySchemaField, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `propertyschemafield.Intercept(f(g(h())))`.
func (c *PropertySchemaFieldClient) Intercept(interceptors ...Interceptor) {
	c.inters.PropertySchemaField = append(c.inters.PropertySchemaField, interceptors...)
}

// Create returns a builder for creating a PropertySchemaField entity.
func (c *PropertySchemaFieldClient) Create() *PropertySchemaFieldCreate {
	mutation := newPropertySchemaFieldMutation(c.config, OpCreate)
	return &PropertySchemaFieldCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PropertySchemaField entities.
func (c *PropertySchemaFieldClient) CreateBulk(builders ...*PropertySchemaFieldCreate) *PropertySchemaFieldCreateBulk {
	return &PropertySchemaFieldCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PropertySchemaFieldClient) MapCreateBulk(slice any, setFunc func(*PropertySchemaFieldCreate, int)) *PropertySchemaFieldCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PropertySchemaFieldCreateBulk{err: fmt.Errorf("calling to PropertySchemaFieldClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PropertySchemaFieldCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PropertySchemaFieldCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PropertySchemaField.
func (c *PropertySchemaFieldClient) Update() *PropertySchemaFieldUpdate {
	mutation := newPropertySchemaFieldMutation(c.config, OpUpdate)
	return &PropertySchemaFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PropertySchemaFieldClient) UpdateOne(_m *PropertySchemaField) *PropertySchemaFieldUpdateOne {
	mutation := newPropertySchemaFieldMutation(c.config, OpUpdateOne, withPropertySchemaField(_m))
	return &PropertySchemaFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PropertySchemaFieldClient) UpdateOneID(id xid.ID) *PropertySchemaFieldUpdateOne {
	mutation := newPropertySchemaFieldMutation(c.config, OpUpdateOne, withPropertySchemaFieldID(id))
	return &PropertySchemaFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PropertySchemaField.
func (c *PropertySchemaFieldClient) Delete() *PropertySchemaFieldDelete {
	mutation := newPropertySchemaFieldMutation(c.config, OpDelete)
	return &PropertySchemaFieldDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PropertySchemaFieldClient) DeleteOne(_m *PropertySchemaField) *PropertySchemaFieldDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PropertySchemaFieldClient) DeleteOneID(id xid.ID) *PropertySchemaFieldDeleteOne {
	builder := c.Delete().Where(propertyschemafield.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PropertySchemaFieldDeleteOne{builder}
}

// Query returns a query builder for PropertySchemaField.
func (c *PropertySchemaFieldClient) Query() *PropertySchemaFieldQuery {
	return &PropertySchemaFieldQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePropertySchemaField},
		inters: c.Interceptors(),
	}
}

// Get returns a PropertySchemaField entity by its id.
func (c *PropertySchemaFieldClient) Get(ctx context.Context, id xid.ID) (*PropertySchemaField, error) {
	return c.Query().Where(propertyschemafield.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PropertySchemaFieldClient) GetX(ctx context.Context, id xid.ID) *PropertySchemaField {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySchema queries the schema edge of a PropertySchemaField.
func (c *PropertySchemaFieldClient) QuerySchema(_m *PropertySchemaField) *PropertySchemaQuery {
	query := (&PropertySchemaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(propertyschemafield.Table, propertyschemafield.FieldID, id),
			sqlgraph.To(propertyschema.Table, propertyschema.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, propertyschemafield.SchemaTable, propertyschemafield.SchemaColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProperties queries the properties edge of a PropertySchemaField.
func (c *PropertySchemaFieldClient) QueryProperties(_m *PropertySchemaField) *PropertyQuery {
	query := (&PropertyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(propertyschemafield.Table, propertyschemafield.FieldID, id),
			sqlgraph.To(property.Table, property.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, propertyschemafield.PropertiesTable, propertyschemafield.PropertiesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PropertySchemaFieldClient) Hooks() []Hook {
	return c.hooks.PropertySchemaField
}

// Interceptors returns the client interceptors.
func (c *PropertySchemaFieldClient) Interceptors() []Interceptor {
	return c.inters.PropertySchemaField
}

func (c *PropertySchemaFieldClient) mutate(ctx context.Context, m *PropertySchemaFieldMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PropertySchemaFieldCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PropertySchemaFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PropertySchemaFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PropertySchemaFieldDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PropertySchemaField mutation op: %q", m.Op())
	}
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `question.Hooks(f(g(h())))`.
func (c *QuestionClient) Use(hooks ...Hook) {
	c.hooks.Question = append(c.hooks.Question, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `question.Intercept(f(g(h())))`.
func (c *QuestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Question = append(c.inters.Question, interceptors...)
}

// Create returns a builder for creating a Question entity.
func (c *QuestionClient) Create() *QuestionCreate {
	mutation := newQuestionMutation(c.config, OpCreate)
	return &QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Question entities.
func (c *QuestionClient) CreateBulk(builders ...*QuestionCreate) *QuestionCreateBulk {
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionClient) MapCreateBulk(slice any, setFunc func(*QuestionCreate, int)) *QuestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionCreateBulk{err: fmt.Errorf("calling to QuestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	mutation := newQuestionMutation(c.config, OpUpdate)
	return &QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(_m *Question) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestion(_m))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id xid.ID) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestionID(id))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	mutation := newQuestionMutation(c.config, OpDelete)
	return &QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionClient) DeleteOne(_m *Question) *QuestionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionClient) DeleteOneID(id xid.ID) *QuestionDeleteOne {
	builder := c.Delete().Where(question.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionDeleteOne{builder}
}

// Query returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestion},
		inters: c.Interceptors(),
	}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id xid.ID) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id xid.ID) *Question {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthor queries the author edge of a Question.
func (c *QuestionClient) QueryAuthor(_m *Question) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, question.AuthorTable, question.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Question.
func (c *QuestionClient) QueryParent(_m *Question) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, question.ParentTable, question.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentQuestion queries the parent_question edge of a Question.
func (c *QuestionClient) QueryParentQuestion(_m *Question) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.ParentQuestionTable, question.ParentQuestionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionClient) Hooks() []Hook {
	return c.hooks.Question
}

// Interceptors returns the client interceptors.
func (c *QuestionClient) Interceptors() []Interceptor {
	return c.inters.Question
}

func (c *QuestionClient) mutate(ctx context.Context, m *QuestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Question mutation op: %q", m.Op())
	}
}

// ReactClient is a client for the React schema.
type ReactClient struct {
	config
}

// NewReactClient returns a client for the React from the given config.
func NewReactClient(c config) *ReactClient {
	return &ReactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `react.Hooks(f(g(h())))`.
func (c *ReactClient) Use(hooks ...Hook) {
	c.hooks.React = append(c.hooks.React, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `react.Intercept(f(g(h())))`.
func (c *ReactClient) Intercept(interceptors ...Interceptor) {
	c.inters.React = append(c.inters.React, interceptors...)
}

// Create returns a builder for creating a React entity.
func (c *ReactClient) Create() *ReactCreate {
	mutation := newReactMutation(c.config, OpCreate)
	return &ReactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of React entities.
func (c *ReactClient) CreateBulk(builders ...*ReactCreate) *ReactCreateBulk {
	return &ReactCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReactClient) MapCreateBulk(slice any, setFunc func(*ReactCreate, int)) *ReactCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReactCreateBulk{err: fmt.Errorf("calling to ReactClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReactCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for React.
func (c *ReactClient) Update() *ReactUpdate {
	mutation := newReactMutation(c.config, OpUpdate)
	return &ReactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReactClient) UpdateOne(_m *React) *ReactUpdateOne {
	mutation := newReactMutation(c.config, OpUpdateOne, withReact(_m))
	return &ReactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReactClient) UpdateOneID(id xid.ID) *ReactUpdateOne {
	mutation := newReactMutation(c.config, OpUpdateOne, withReactID(id))
	return &ReactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for React.
func (c *ReactClient) Delete() *ReactDelete {
	mutation := newReactMutation(c.config, OpDelete)
	return &ReactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReactClient) DeleteOne(_m *React) *ReactDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReactClient) DeleteOneID(id xid.ID) *ReactDeleteOne {
	builder := c.Delete().Where(react.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReactDeleteOne{builder}
}

// Query returns a query builder for React.
func (c *ReactClient) Query() *ReactQuery {
	return &ReactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReact},
		inters: c.Interceptors(),
	}
}

// Get returns a React entity by its id.
func (c *ReactClient) Get(ctx context.Context, id xid.ID) (*React, error) {
	return c.Query().Where(react.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReactClient) GetX(ctx context.Context, id xid.ID) *React {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a React.
func (c *ReactClient) QueryAccount(_m *React) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(react.Table, react.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, react.AccountTable, react.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPost queries the Post edge of a React.
func (c *ReactClient) QueryPost(_m *React) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(react.Table, react.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, react.PostTable, react.PostColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReactClient) Hooks() []Hook {
	return c.hooks.React
}

// Interceptors returns the client interceptors.
func (c *ReactClient) Interceptors() []Interceptor {
	return c.inters.React
}

func (c *ReactClient) mutate(ctx context.Context, m *ReactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown React mutation op: %q", m.Op())
	}
}

// ReportClient is a client for the Report schema.
type ReportClient struct {
	config
}

// NewReportClient returns a client for the Report from the given config.
func NewReportClient(c config) *ReportClient {
	return &ReportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `report.Hooks(f(g(h())))`.
func (c *ReportClient) Use(hooks ...Hook) {
	c.hooks.Report = append(c.hooks.Report, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `report.Intercept(f(g(h())))`.
func (c *ReportClient) Intercept(interceptors ...Interceptor) {
	c.inters.Report = append(c.inters.Report, interceptors...)
}

// Create returns a builder for creating a Report entity.
func (c *ReportClient) Create() *ReportCreate {
	mutation := newReportMutation(c.config, OpCreate)
	return &ReportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Report entities.
func (c *ReportClient) CreateBulk(builders ...*ReportCreate) *ReportCreateBulk {
	return &ReportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReportClient) MapCreateBulk(slice any, setFunc func(*ReportCreate, int)) *ReportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReportCreateBulk{err: fmt.Errorf("calling to ReportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Report.
func (c *ReportClient) Update() *ReportUpdate {
	mutation := newReportMutation(c.config, OpUpdate)
	return &ReportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReportClient) UpdateOne(_m *Report) *ReportUpdateOne {
	mutation := newReportMutation(c.config, OpUpdateOne, withReport(_m))
	return &ReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReportClient) UpdateOneID(id xid.ID) *ReportUpdateOne {
	mutation := newReportMutation(c.config, OpUpdateOne, withReportID(id))
	return &ReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Report.
func (c *ReportClient) Delete() *ReportDelete {
	mutation := newReportMutation(c.config, OpDelete)
	return &ReportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReportClient) DeleteOne(_m *Report) *ReportDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReportClient) DeleteOneID(id xid.ID) *ReportDeleteOne {
	builder := c.Delete().Where(report.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReportDeleteOne{builder}
}

// Query returns a query builder for Report.
func (c *ReportClient) Query() *ReportQuery {
	return &ReportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReport},
		inters: c.Interceptors(),
	}
}

// Get returns a Report entity by its id.
func (c *ReportClient) Get(ctx context.Context, id xid.ID) (*Report, error) {
	return c.Query().Where(report.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReportClient) GetX(ctx context.Context, id xid.ID) *Report {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReportedBy queries the reported_by edge of a Report.
func (c *ReportClient) QueryReportedBy(_m *Report) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(report.Table, report.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, report.ReportedByTable, report.ReportedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHandledBy queries the handled_by edge of a Report.
func (c *ReportClient) QueryHandledBy(_m *Report) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(report.Table, report.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, report.HandledByTable, report.HandledByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReportClient) Hooks() []Hook {
	return c.hooks.Report
}

// Interceptors returns the client interceptors.
func (c *ReportClient) Interceptors() []Interceptor {
	return c.inters.Report
}

func (c *ReportClient) mutate(ctx context.Context, m *ReportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Report mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(_m *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(_m))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id xid.ID) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(_m *Role) *RoleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id xid.ID) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id xid.ID) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id xid.ID) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccounts queries the accounts edge of a Role.
func (c *RoleClient) QueryAccounts(_m *Role) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, role.AccountsTable, role.AccountsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccountRoles queries the account_roles edge of a Role.
func (c *RoleClient) QueryAccountRoles(_m *Role) *AccountRolesQuery {
	query := (&AccountRolesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(accountroles.Table, accountroles.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, role.AccountRolesTable, role.AccountRolesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	return c.hooks.Role
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	return c.inters.Role
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(_m *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(_m))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id xid.ID) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(_m *Session) *SessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id xid.ID) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id xid.ID) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id xid.ID) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a Session.
func (c *SessionClient) QueryAccount(_m *Session) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.AccountTable, session.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// SettingClient is a client for the Setting schema.
type SettingClient struct {
	config
}

// NewSettingClient returns a client for the Setting from the given config.
func NewSettingClient(c config) *SettingClient {
	return &SettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `setting.Hooks(f(g(h())))`.
func (c *SettingClient) Use(hooks ...Hook) {
	c.hooks.Setting = append(c.hooks.Setting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `setting.Intercept(f(g(h())))`.
func (c *SettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Setting = append(c.inters.Setting, interceptors...)
}

// Create returns a builder for creating a Setting entity.
func (c *SettingClient) Create() *SettingCreate {
	mutation := newSettingMutation(c.config, OpCreate)
	return &SettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Setting entities.
func (c *SettingClient) CreateBulk(builders ...*SettingCreate) *SettingCreateBulk {
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SettingClient) MapCreateBulk(slice any, setFunc func(*SettingCreate, int)) *SettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SettingCreateBulk{err: fmt.Errorf("calling to SettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Setting.
func (c *SettingClient) Update() *SettingUpdate {
	mutation := newSettingMutation(c.config, OpUpdate)
	return &SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettingClient) UpdateOne(_m *Setting) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSetting(_m))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettingClient) UpdateOneID(id string) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSettingID(id))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Setting.
func (c *SettingClient) Delete() *SettingDelete {
	mutation := newSettingMutation(c.config, OpDelete)
	return &SettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettingClient) DeleteOne(_m *Setting) *SettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettingClient) DeleteOneID(id string) *SettingDeleteOne {
	builder := c.Delete().Where(setting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettingDeleteOne{builder}
}

// Query returns a query builder for Setting.
func (c *SettingClient) Query() *SettingQuery {
	return &SettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a Setting entity by its id.
func (c *SettingClient) Get(ctx context.Context, id string) (*Setting, error) {
	return c.Query().Where(setting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettingClient) GetX(ctx context.Context, id string) *Setting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SettingClient) Hooks() []Hook {
	return c.hooks.Setting
}

// Interceptors returns the client interceptors.
func (c *SettingClient) Interceptors() []Interceptor {
	return c.inters.Setting
}

func (c *SettingClient) mutate(ctx context.Context, m *SettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Setting mutation op: %q", m.Op())
	}
}

// TagClient is a client for the Tag schema.
type TagClient struct {
	config
}

// NewTagClient returns a client for the Tag from the given config.
func NewTagClient(c config) *TagClient {
	return &TagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tag.Hooks(f(g(h())))`.
func (c *TagClient) Use(hooks ...Hook) {
	c.hooks.Tag = append(c.hooks.Tag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tag.Intercept(f(g(h())))`.
func (c *TagClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tag = append(c.inters.Tag, interceptors...)
}

// Create returns a builder for creating a Tag entity.
func (c *TagClient) Create() *TagCreate {
	mutation := newTagMutation(c.config, OpCreate)
	return &TagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tag entities.
func (c *TagClient) CreateBulk(builders ...*TagCreate) *TagCreateBulk {
	return &TagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TagClient) MapCreateBulk(slice any, setFunc func(*TagCreate, int)) *TagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TagCreateBulk{err: fmt.Errorf("calling to TagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tag.
func (c *TagClient) Update() *TagUpdate {
	mutation := newTagMutation(c.config, OpUpdate)
	return &TagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TagClient) UpdateOne(_m *Tag) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTag(_m))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TagClient) UpdateOneID(id xid.ID) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTagID(id))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tag.
func (c *TagClient) Delete() *TagDelete {
	mutation := newTagMutation(c.config, OpDelete)
	return &TagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TagClient) DeleteOne(_m *Tag) *TagDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TagClient) DeleteOneID(id xid.ID) *TagDeleteOne {
	builder := c.Delete().Where(tag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TagDeleteOne{builder}
}

// Query returns a query builder for Tag.
func (c *TagClient) Query() *TagQuery {
	return &TagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTag},
		inters: c.Interceptors(),
	}
}

// Get returns a Tag entity by its id.
func (c *TagClient) Get(ctx context.Context, id xid.ID) (*Tag, error) {
	return c.Query().Where(tag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TagClient) GetX(ctx context.Context, id xid.ID) *Tag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPosts queries the posts edge of a Tag.
func (c *TagClient) QueryPosts(_m *Tag) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, tag.PostsTable, tag.PostsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNodes queries the nodes edge of a Tag.
func (c *TagClient) QueryNodes(_m *Tag) *NodeQuery {
	query := (&NodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(node.Table, node.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, tag.NodesTable, tag.NodesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccounts queries the accounts edge of a Tag.
func (c *TagClient) QueryAccounts(_m *Tag) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tag.AccountsTable, tag.AccountsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TagClient) Hooks() []Hook {
	return c.hooks.Tag
}

// Interceptors returns the client interceptors.
func (c *TagClient) Interceptors() []Interceptor {
	return c.inters.Tag
}

func (c *TagClient) mutate(ctx context.Context, m *TagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tag mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Account, AccountFollow, AccountRoles, Asset, AuditLog, Authentication, Category,
		Collection, CollectionNode, CollectionPost, Email, Event, EventParticipant,
		Invitation, LikePost, Link, MentionProfile, Node, Notification, Plugin, Post,
		PostRead, Property, PropertySchema, PropertySchemaField, Question, React,
		Report, Role, Session, Setting, Tag []ent.Hook
	}
	inters struct {
		Account, AccountFollow, AccountRoles, Asset, AuditLog, Authentication, Category,
		Collection, CollectionNode, CollectionPost, Email, Event, EventParticipant,
		Invitation, LikePost, Link, MentionProfile, Node, Notification, Plugin, Post,
		PostRead, Property, PropertySchema, PropertySchemaField, Question, React,
		Report, Role, Session, Setting, Tag []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
