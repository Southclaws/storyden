// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Southclaws/lexorank"
	"github.com/Southclaws/storyden/internal/ent/account"
	"github.com/Southclaws/storyden/internal/ent/asset"
	"github.com/Southclaws/storyden/internal/ent/link"
	"github.com/Southclaws/storyden/internal/ent/node"
	"github.com/Southclaws/storyden/internal/ent/propertyschema"
	"github.com/rs/xid"
)

// Node is the model entity for the Node schema.
type Node struct {
	config `json:"-"`
	// ID of the ent.
	ID xid.ID `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
	// IndexedAt holds the value of the "indexed_at" field.
	IndexedAt *time.Time `json:"indexed_at,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Slug holds the value of the "slug" field.
	Slug string `json:"slug,omitempty"`
	// Description holds the value of the "description" field.
	Description *string `json:"description,omitempty"`
	// Content holds the value of the "content" field.
	Content *string `json:"content,omitempty"`
	// ParentNodeID holds the value of the "parent_node_id" field.
	ParentNodeID xid.ID `json:"parent_node_id,omitempty"`
	// HideChildTree holds the value of the "hide_child_tree" field.
	HideChildTree bool `json:"hide_child_tree,omitempty"`
	// AccountID holds the value of the "account_id" field.
	AccountID xid.ID `json:"account_id,omitempty"`
	// PropertySchemaID holds the value of the "property_schema_id" field.
	PropertySchemaID *xid.ID `json:"property_schema_id,omitempty"`
	// PrimaryAssetID holds the value of the "primary_asset_id" field.
	PrimaryAssetID *xid.ID `json:"primary_asset_id,omitempty"`
	// LinkID holds the value of the "link_id" field.
	LinkID xid.ID `json:"link_id,omitempty"`
	// Visibility holds the value of the "visibility" field.
	Visibility node.Visibility `json:"visibility,omitempty"`
	// Sort holds the value of the "sort" field.
	Sort lexorank.Key `json:"sort,omitempty"`
	// Metadata holds the value of the "metadata" field.
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the NodeQuery when eager-loading is set.
	Edges        NodeEdges `json:"edges"`
	selectValues sql.SelectValues
}

// NodeEdges holds the relations/edges for other nodes in the graph.
type NodeEdges struct {
	// Owner holds the value of the owner edge.
	Owner *Account `json:"owner,omitempty"`
	// A many-to-many recursive self reference. The parent node, if any.
	Parent *Node `json:"parent,omitempty"`
	// Nodes holds the value of the nodes edge.
	Nodes []*Node `json:"nodes,omitempty"`
	// PrimaryImage holds the value of the primary_image edge.
	PrimaryImage *Asset `json:"primary_image,omitempty"`
	// Assets holds the value of the assets edge.
	Assets []*Asset `json:"assets,omitempty"`
	// Tags holds the value of the tags edge.
	Tags []*Tag `json:"tags,omitempty"`
	// Properties holds the value of the properties edge.
	Properties []*Property `json:"properties,omitempty"`
	// PropertySchema holds the value of the property_schema edge.
	PropertySchema *PropertySchema `json:"property_schema,omitempty"`
	// Link holds the value of the link edge.
	Link *Link `json:"link,omitempty"`
	// ContentLinks holds the value of the content_links edge.
	ContentLinks []*Link `json:"content_links,omitempty"`
	// Collections holds the value of the collections edge.
	Collections []*Collection `json:"collections,omitempty"`
	// Comments holds the value of the comments edge.
	Comments []*Post `json:"comments,omitempty"`
	// CollectionNodes holds the value of the collection_nodes edge.
	CollectionNodes []*CollectionNode `json:"collection_nodes,omitempty"`
	// ThreadNodes holds the value of the thread_nodes edge.
	ThreadNodes []*PostNode `json:"thread_nodes,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [14]bool
}

// OwnerOrErr returns the Owner value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e NodeEdges) OwnerOrErr() (*Account, error) {
	if e.Owner != nil {
		return e.Owner, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: account.Label}
	}
	return nil, &NotLoadedError{edge: "owner"}
}

// ParentOrErr returns the Parent value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e NodeEdges) ParentOrErr() (*Node, error) {
	if e.Parent != nil {
		return e.Parent, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: node.Label}
	}
	return nil, &NotLoadedError{edge: "parent"}
}

// NodesOrErr returns the Nodes value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) NodesOrErr() ([]*Node, error) {
	if e.loadedTypes[2] {
		return e.Nodes, nil
	}
	return nil, &NotLoadedError{edge: "nodes"}
}

// PrimaryImageOrErr returns the PrimaryImage value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e NodeEdges) PrimaryImageOrErr() (*Asset, error) {
	if e.PrimaryImage != nil {
		return e.PrimaryImage, nil
	} else if e.loadedTypes[3] {
		return nil, &NotFoundError{label: asset.Label}
	}
	return nil, &NotLoadedError{edge: "primary_image"}
}

// AssetsOrErr returns the Assets value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) AssetsOrErr() ([]*Asset, error) {
	if e.loadedTypes[4] {
		return e.Assets, nil
	}
	return nil, &NotLoadedError{edge: "assets"}
}

// TagsOrErr returns the Tags value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) TagsOrErr() ([]*Tag, error) {
	if e.loadedTypes[5] {
		return e.Tags, nil
	}
	return nil, &NotLoadedError{edge: "tags"}
}

// PropertiesOrErr returns the Properties value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) PropertiesOrErr() ([]*Property, error) {
	if e.loadedTypes[6] {
		return e.Properties, nil
	}
	return nil, &NotLoadedError{edge: "properties"}
}

// PropertySchemaOrErr returns the PropertySchema value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e NodeEdges) PropertySchemaOrErr() (*PropertySchema, error) {
	if e.PropertySchema != nil {
		return e.PropertySchema, nil
	} else if e.loadedTypes[7] {
		return nil, &NotFoundError{label: propertyschema.Label}
	}
	return nil, &NotLoadedError{edge: "property_schema"}
}

// LinkOrErr returns the Link value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e NodeEdges) LinkOrErr() (*Link, error) {
	if e.Link != nil {
		return e.Link, nil
	} else if e.loadedTypes[8] {
		return nil, &NotFoundError{label: link.Label}
	}
	return nil, &NotLoadedError{edge: "link"}
}

// ContentLinksOrErr returns the ContentLinks value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) ContentLinksOrErr() ([]*Link, error) {
	if e.loadedTypes[9] {
		return e.ContentLinks, nil
	}
	return nil, &NotLoadedError{edge: "content_links"}
}

// CollectionsOrErr returns the Collections value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) CollectionsOrErr() ([]*Collection, error) {
	if e.loadedTypes[10] {
		return e.Collections, nil
	}
	return nil, &NotLoadedError{edge: "collections"}
}

// CommentsOrErr returns the Comments value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) CommentsOrErr() ([]*Post, error) {
	if e.loadedTypes[11] {
		return e.Comments, nil
	}
	return nil, &NotLoadedError{edge: "comments"}
}

// CollectionNodesOrErr returns the CollectionNodes value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) CollectionNodesOrErr() ([]*CollectionNode, error) {
	if e.loadedTypes[12] {
		return e.CollectionNodes, nil
	}
	return nil, &NotLoadedError{edge: "collection_nodes"}
}

// ThreadNodesOrErr returns the ThreadNodes value or an error if the edge
// was not loaded in eager-loading.
func (e NodeEdges) ThreadNodesOrErr() ([]*PostNode, error) {
	if e.loadedTypes[13] {
		return e.ThreadNodes, nil
	}
	return nil, &NotLoadedError{edge: "thread_nodes"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Node) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case node.FieldPropertySchemaID, node.FieldPrimaryAssetID:
			values[i] = &sql.NullScanner{S: new(xid.ID)}
		case node.FieldMetadata:
			values[i] = new([]byte)
		case node.FieldSort:
			values[i] = new(lexorank.Key)
		case node.FieldHideChildTree:
			values[i] = new(sql.NullBool)
		case node.FieldName, node.FieldSlug, node.FieldDescription, node.FieldContent, node.FieldVisibility:
			values[i] = new(sql.NullString)
		case node.FieldCreatedAt, node.FieldUpdatedAt, node.FieldDeletedAt, node.FieldIndexedAt:
			values[i] = new(sql.NullTime)
		case node.FieldID, node.FieldParentNodeID, node.FieldAccountID, node.FieldLinkID:
			values[i] = new(xid.ID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Node fields.
func (_m *Node) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case node.FieldID:
			if value, ok := values[i].(*xid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				_m.ID = *value
			}
		case node.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case node.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case node.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				_m.DeletedAt = new(time.Time)
				*_m.DeletedAt = value.Time
			}
		case node.FieldIndexedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field indexed_at", values[i])
			} else if value.Valid {
				_m.IndexedAt = new(time.Time)
				*_m.IndexedAt = value.Time
			}
		case node.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				_m.Name = value.String
			}
		case node.FieldSlug:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field slug", values[i])
			} else if value.Valid {
				_m.Slug = value.String
			}
		case node.FieldDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field description", values[i])
			} else if value.Valid {
				_m.Description = new(string)
				*_m.Description = value.String
			}
		case node.FieldContent:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field content", values[i])
			} else if value.Valid {
				_m.Content = new(string)
				*_m.Content = value.String
			}
		case node.FieldParentNodeID:
			if value, ok := values[i].(*xid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field parent_node_id", values[i])
			} else if value != nil {
				_m.ParentNodeID = *value
			}
		case node.FieldHideChildTree:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field hide_child_tree", values[i])
			} else if value.Valid {
				_m.HideChildTree = value.Bool
			}
		case node.FieldAccountID:
			if value, ok := values[i].(*xid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field account_id", values[i])
			} else if value != nil {
				_m.AccountID = *value
			}
		case node.FieldPropertySchemaID:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field property_schema_id", values[i])
			} else if value.Valid {
				_m.PropertySchemaID = new(xid.ID)
				*_m.PropertySchemaID = *value.S.(*xid.ID)
			}
		case node.FieldPrimaryAssetID:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field primary_asset_id", values[i])
			} else if value.Valid {
				_m.PrimaryAssetID = new(xid.ID)
				*_m.PrimaryAssetID = *value.S.(*xid.ID)
			}
		case node.FieldLinkID:
			if value, ok := values[i].(*xid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field link_id", values[i])
			} else if value != nil {
				_m.LinkID = *value
			}
		case node.FieldVisibility:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field visibility", values[i])
			} else if value.Valid {
				_m.Visibility = node.Visibility(value.String)
			}
		case node.FieldSort:
			if value, ok := values[i].(*lexorank.Key); !ok {
				return fmt.Errorf("unexpected type %T for field sort", values[i])
			} else if value != nil {
				_m.Sort = *value
			}
		case node.FieldMetadata:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field metadata", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Metadata); err != nil {
					return fmt.Errorf("unmarshal field metadata: %w", err)
				}
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Node.
// This includes values selected through modifiers, order, etc.
func (_m *Node) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryOwner queries the "owner" edge of the Node entity.
func (_m *Node) QueryOwner() *AccountQuery {
	return NewNodeClient(_m.config).QueryOwner(_m)
}

// QueryParent queries the "parent" edge of the Node entity.
func (_m *Node) QueryParent() *NodeQuery {
	return NewNodeClient(_m.config).QueryParent(_m)
}

// QueryNodes queries the "nodes" edge of the Node entity.
func (_m *Node) QueryNodes() *NodeQuery {
	return NewNodeClient(_m.config).QueryNodes(_m)
}

// QueryPrimaryImage queries the "primary_image" edge of the Node entity.
func (_m *Node) QueryPrimaryImage() *AssetQuery {
	return NewNodeClient(_m.config).QueryPrimaryImage(_m)
}

// QueryAssets queries the "assets" edge of the Node entity.
func (_m *Node) QueryAssets() *AssetQuery {
	return NewNodeClient(_m.config).QueryAssets(_m)
}

// QueryTags queries the "tags" edge of the Node entity.
func (_m *Node) QueryTags() *TagQuery {
	return NewNodeClient(_m.config).QueryTags(_m)
}

// QueryProperties queries the "properties" edge of the Node entity.
func (_m *Node) QueryProperties() *PropertyQuery {
	return NewNodeClient(_m.config).QueryProperties(_m)
}

// QueryPropertySchema queries the "property_schema" edge of the Node entity.
func (_m *Node) QueryPropertySchema() *PropertySchemaQuery {
	return NewNodeClient(_m.config).QueryPropertySchema(_m)
}

// QueryLink queries the "link" edge of the Node entity.
func (_m *Node) QueryLink() *LinkQuery {
	return NewNodeClient(_m.config).QueryLink(_m)
}

// QueryContentLinks queries the "content_links" edge of the Node entity.
func (_m *Node) QueryContentLinks() *LinkQuery {
	return NewNodeClient(_m.config).QueryContentLinks(_m)
}

// QueryCollections queries the "collections" edge of the Node entity.
func (_m *Node) QueryCollections() *CollectionQuery {
	return NewNodeClient(_m.config).QueryCollections(_m)
}

// QueryComments queries the "comments" edge of the Node entity.
func (_m *Node) QueryComments() *PostQuery {
	return NewNodeClient(_m.config).QueryComments(_m)
}

// QueryCollectionNodes queries the "collection_nodes" edge of the Node entity.
func (_m *Node) QueryCollectionNodes() *CollectionNodeQuery {
	return NewNodeClient(_m.config).QueryCollectionNodes(_m)
}

// QueryThreadNodes queries the "thread_nodes" edge of the Node entity.
func (_m *Node) QueryThreadNodes() *PostNodeQuery {
	return NewNodeClient(_m.config).QueryThreadNodes(_m)
}

// Update returns a builder for updating this Node.
// Note that you need to call Node.Unwrap() before calling this method if this Node
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Node) Update() *NodeUpdateOne {
	return NewNodeClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the Node entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Node) Unwrap() *Node {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: Node is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *Node) String() string {
	var builder strings.Builder
	builder.WriteString("Node(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := _m.DeletedAt; v != nil {
		builder.WriteString("deleted_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := _m.IndexedAt; v != nil {
		builder.WriteString("indexed_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(_m.Name)
	builder.WriteString(", ")
	builder.WriteString("slug=")
	builder.WriteString(_m.Slug)
	builder.WriteString(", ")
	if v := _m.Description; v != nil {
		builder.WriteString("description=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.Content; v != nil {
		builder.WriteString("content=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("parent_node_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.ParentNodeID))
	builder.WriteString(", ")
	builder.WriteString("hide_child_tree=")
	builder.WriteString(fmt.Sprintf("%v", _m.HideChildTree))
	builder.WriteString(", ")
	builder.WriteString("account_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.AccountID))
	builder.WriteString(", ")
	if v := _m.PropertySchemaID; v != nil {
		builder.WriteString("property_schema_id=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := _m.PrimaryAssetID; v != nil {
		builder.WriteString("primary_asset_id=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("link_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.LinkID))
	builder.WriteString(", ")
	builder.WriteString("visibility=")
	builder.WriteString(fmt.Sprintf("%v", _m.Visibility))
	builder.WriteString(", ")
	builder.WriteString("sort=")
	builder.WriteString(fmt.Sprintf("%v", _m.Sort))
	builder.WriteString(", ")
	builder.WriteString("metadata=")
	builder.WriteString(fmt.Sprintf("%v", _m.Metadata))
	builder.WriteByte(')')
	return builder.String()
}

// Nodes is a parsable slice of Node.
type Nodes []*Node
